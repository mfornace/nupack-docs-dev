{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Overview \u00b6 About \u00b6 NUPACK is a growing software suite for the analysis and design of nucleic acid structures, devices, and systems serving the needs of researchers in the fields of nucleic acid nanotechnology, molecular programming, synthetic biology, and across the life sciences more broadly. Much of this software can be conveniently run using the NUPACK web application at nupack.org [ Zadeh11a ]. This User Guide provides documentation for the NUPACK Python module. When finishing a project that has benefited from NUPACK calculations, please remember to cite the NUPACK web application and algorithms appropriately; citations are an important component in helping to secure funding for NUPACK development and maintenance. Please email us with questions, comments, feature requests, and bug reports at support@nupack.org . \u2014 The NUPACK Team Problem Categories \u00b6 NUPACK algorithms address two fundamental classes of problems: Sequence analysis: given a set of DNA or RNA strands, analyze the equilibrium base-pairing properties over a specified ensemble. Sequence design: given a set of desired equilibrium base-pairing properties, design the sequences of a set of DNA or RNA strands over a specified ensemble. Sequence design is performed subject to diverse user-specified sequence constraints including composition constraints, complementarity constraints, pattern prevention constraints, and biological constraints. Figure : Sequence analysis and design using NUPACK. NUPACK algorithms operate over two fundamental ensembles: Complex ensemble: the ensemble of all (unpseudoknotted connected) secondary structures for an arbitrary number of interacting RNA or DNA strands. Test tube ensemble: the ensemble of a dilute solution containing an arbitrary number of RNA or DNA strand species (introduced at user-specified concentrations) interacting to form an arbitrary number of complex species. Furthermore, to enable reaction pathway engineering of dynamic hybridization cascades or large-scale structural engineering including pseudoknots, NUPACK generalizes sequence analysis and design to multi-complex and multi-tube ensembles [ Wolfe17 ]. NUPACK capabilities are presented in three categories: Analysis: Analyze the equilibrium base-pairing properties one or more test tube ensembles (or one or more complex ensembles). These are the all-purpose sequence analysis tools. Design: Design the the sequences for one or more test tube ensembles (or one or more complex ensembles). These are the all-purpose sequence design tools. Utilities: Analyze or design a single complex ensemble. These are quick tools applicable when your ensemble is a single complex. Examples Load Python NUPACK module from nupack import * Specify a physical model model1 = Model ( material = 'rna' , celsius = 37 ) Analyze a test tube # specify strands A = Strand ( 'CTGATCGAT' , name = 'Strand A' ) B = Strand ( 'GATCGTAGTC' , name = 'Strand B' ) # specify tube t1 = Tube ( strands = { A : 1e-8 , B : 1e-9 }, complexes = SetSpec ( max_size = 2 ), name = 'Tube 1' ) # all complexes of up to 2 strands # run tube analysis job my_results = tube_analysis ( tubes = [ t1 ], model = model1 ) Design a test tube a = Domain ( 'A4' , name = 'Domain a' ) b = Domain ( 'N10' , name = 'Domain b' ) # equivalent sequence specification c = Domain ( 'R5N5' , name = 'Domain c' ) # specify target strands A = TargetStrand ([ a , a , b ], name = 'Strand A' ) B = TargetStrand ([ ~ b , ~ c ], name = 'Strand B' ) # ~e denotes the reverse complement of e C = TargetStrand ([ c ], name = 'Strand C' ) # specify target complexes C1 = TargetComplex ([ A , B , C ], '.8(10+)10(10+)10' , name = 'Complex C1' ) C2 = TargetComplex ([ B , C ], '.10(10+)10' , name = 'Complex C2' ) # specify target tube tt1 = TargetTube ( on_targets = { C1 : 1e-8 , C2 : 1e-8 }, off_targets = SetSpec ( max_size = 3 ), # all off-target complexes of up to 3 strands name = 'TargetTube 1' ) # specify tube design problem my_des = tube_design ( tubes = [ tt1 ], hard_constraints = [], soft_constraints = [], defect_weights = None , options = None , model = model1 ) # run tube design job des_results = my_des . run ( trials = 3 ) # run 3 independent design trials License \u00b6 NUPACK Software License Agreement for Non-Commercial Academic Use Copyright \u00a9 2003\u20132022. California Institute of Technology. All rights reserved. Use of the NUPACK Python module and/or source code (\u201cSoftware\u201d) in source form and/or binary form, with or without modification, is permitted for non-commercial academic purposes only, subject to the conditions and disclaimer stated below. Conditions 1. Redistribution of the Software in source form and/or binary form is not permitted. 2. Web applications that use the Software in source form and/or binary form are not permitted. 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote derivative works without specific prior written permission. Disclaimer The Software is provided by the copyright holders and contributors \u201cas is\u201d and any express or implied warranties, including, but not limited to, the implied warranties of merchantability and fitness for a particular purpose are disclaimed. In no event shall the copyright holder or contributors be liable for any direct, indirect, incidental, special, exemplary, or consequential damages (including, but not limited to, procurement of substitute goods or services; loss of use, data, or profits; or business interruption) however caused and on any theory of liability, whether in contract, strict liability, or tort (including negligence or otherwise) arising in any way out of the use of this software, even if advised of the possibility of such damage. Contact For any questions about this Software License Agreement please contact info@nupack.org . Citation \u00b6 For citation, please select from the list below as appropriate for your application: NUPACK Web Application Run jobs online at nupack.org J. N. Zadeh, C. D. Steenberg, J. S. Bois, B. R. Wolfe, M. B. Pierce, A. R. Khan, R. M. Dirks, N. A. Pierce. NUPACK: analysis and design of nucleic acid systems. J Comput Chem , 32:170\u2013173, 2011. ( pdf ) NUPACK Analysis Algorithms Complex analysis and test tube analysis M.E. Fornace, N.J. Porubsky, and N.A. Pierce (2020). A unified dynamic programming framework for the analysis of interacting nucleic acid strands: enhanced models, scalability, and speed. ACS Synth Biol , 9:2665-2678, 2020. ( pdf , supp info ) R. M. Dirks, J. S. Bois, J. M. Schaeffer, E. Winfree, and N. A. Pierce. Thermodynamic analysis of interacting nucleic acid strands. SIAM Rev , 49:65-88, 2007. ( pdf ) Pseudoknot analysis R. M. Dirks and N. A. Pierce. An algorithm for computing nucleic acid base-pairing probabilities including pseudoknots. J Comput Chem , 25:1295-1304, 2004. ( pdf ) R. M. Dirks and N. A. Pierce. A partition function algorithm for nucleic acid secondary structure including pseudoknots. J Comput Chem , 24:1664-1677, 2003. ( pdf , supp info ) NUPACK Design Algorithms Multi-tube design B. R. Wolfe, N. J. Porubsky, J. N. Zadeh, R. M. Dirks, and N. A. Pierce. Constrained multistate sequence design for nucleic acid reaction pathway engineering. J Am Chem Soc , 139:3134-3144, 2017. ( pdf , supp info ) Test tube design B. R. Wolfe and N. A. Pierce. Sequence design for a test tube of interacting nucleic acid strands. ACS Synth Biol , 4:1086-1100, 2015. ( pdf , supp info , supp tests ) Complex design J. N. Zadeh, B. R. Wolfe, and N. A. Pierce. Nucleic acid sequence design via efficient ensemble defect optimization. J Comput Chem , 32:439\u2013452, 2011. ( pdf , supp info , supp tests ) Design paradigms R. M. Dirks, M. Lin, E. Winfree, and N. A. Pierce. Paradigms for computational nucleic acid design. Nucl Acids Res , 32:1392-1403, 2004. ( pdf , supp info , supp seqs ) Acknowledgments \u00b6 We thank all the NUPACK users that have helped out as beta testers over the years, as well as the many NUPACK users that have emailed support@nupack.org to request features or report bugs. NUPACK is supported by the National Science Foundation (NSF-OAC-1835414) and by the Beckman Institute at Caltech (PMTC). NUPACK has previously been supported by the National Science Foundation (NSF-CCF-1317694, NSF-CCF-0832824, NSF-CHE-0533064, NSF-DMS-0506468, NSF-CAREER-0448835), by the Gordon and Betty Moore Foundation (GBMF2809), by the John Simon Guggenheim Memorial Foundation, by the National Institutes of Health (P50 HG004071), by the Ralph M. Parsons Foundation, and by the Charles Lee Powell Foundation. Versions \u00b6 NUPACK 3.0 Features: complex analysis [ Dirks07 ] complex design [ Zadeh11b ] test tube analysis [ Dirks07 ] Executables: pfunc , pairs , mfe , subopt , count , energy , prob , pairs , defect , complexes , concentrations , distributions , design These executables read input files containing comment lines preceded by % ; blank lines are not permitted. Terminology and notation: details in [ Dirks07 ] NUPACK 3.1 New features: test tube design [ Wolfe15 ] New executables: tubedesign and tubedefect These executables read *.np script files written in v1 of the NUPACK scripting language In *.np script files, a comment begins with # and continues for the rest of the line; blank lines are permitted. Changes to existing executables: Name of executable design changed to complexdesign . Name of executable defect changed to complexdefect . Updates to the default options and output file formats for executables complexes , concentrations , and distributions . Use option -v3.0 to revert to NUPACK 3.0 behavior using NUPACK 3.1. Terminology and notation: details in Section 1.1 of NUPACK 3.1 User Guide NUPACK 3.2 New features: constrained multistate test tube design [ Wolfe17 ] New executables: multitubedesign and multitubedefect These executables read *.np script files written in v2 of the NUPACK scripting language. In *.np script files, a comment begins with # and continues for the rest of the line; blank lines are permitted. Terminology and notation: details in Section 1.1 of NUPACK 3.2 User Guide NUPACK 4.0 New features: unified dynamic programming framework [ Fornace20 ] all-new code base all-new NUPACK Python module Commands: Scripting is done in Python Indices start at 0 (previous versions indexed starting at 1) Terminology and notation: details in [ Fornace20 ] Revision notes: 4.0.0.20: Release of first public beta 4.0.0.21: Fix SSM display issue and wobble evaluation bug in design 4.0.0.23: Fix incorrect rounding of ensemble_size result 4.0.0.24: Fix diverging estimate of defects seen in design checkpoints 4.0.0.25: Fix concentration failure resulting from division by 0 4.0.0.26: Fix number of samples given for indistinguishable complexes 4.0.0.27: Add native support for Mac arm64 (M1) architectures 4.0.0.28: Add native support for Linux arch64 architecture, support Python 3.10, fix similarity soft constraint when specifying multiple domains 4.0.1.0: Add fraction_unpaired_bases functionality, revise implementation of parallelism and cache usage, improve input validation 4.0.1.1: Enable parallelism by default, add the threads setting, and set design to only use up to N threads on a machine with N cores 4.0.1.2: Remove support for Python 3.6, fix several bugs in 4.0.1 to do with parallel submission of designs, reloading designs, and other minor user interface problems 4.0.1.3: Fix unbounded growth in memory cache, optimize parallelism in design further, minor interface improvements 4.0.1.4: Fix concentration equilibration initial guess which occasionally caused lack of convergence 4.0.1.5: Fix large memory usage in analysis jobs containing many complexes, improve cache constraint 4.0.1.6: Fix missing nt() method in Domain class 4.0.1.7: Fix memory leak in Python when running many analyses sequentially 4.0.1.8: Add support for Python 3.11 4.0.1.9: Add support for Python 3.12 and fix rare issue in equilibrium concentration convergence 4.0.1.10: Fix issue when specifying mixtures of sequences containing U and T and provide binaries with more conservative instruction sets for Linux 4.0.1.11: Fix output printing for sequences containing U and T to match user inputs when possible Zadeh11a Zadeh J.N., Steenberg C.D., Bois J.S., Wolfe B.R., Pierce M.B., Khan A.R., Dirks R.M., Pierce N.A.: NUPACK: Analysis and Design of Nucleic Acid Systems . J. Comput. Chem.. 32 , (2011) Wolfe17 Wolfe B.R., Porubsky N.J., Zadeh J.N., Dirks R.M., Pierce N.A.: Constrained Multistate Sequence Design for Nucleic Acid Reaction Pathway Engineering . J Am. Chem. Soc.. 139 , (2017) Dirks07 Dirks R.M., Bois J.S., Schaeffer J.M., Winfree E., Pierce N.A.: Thermodynamic Analysis of Interacting Nucleic Acid Strands . SIAM Rev.. 49 , (2007) Zadeh11b Zadeh J.N., Wolfe B.R., Pierce N.A.: Nucleic Acid Sequence Design via Efficient Ensemble Defect Optimization . J. Comput. Chem.. 32 , (2011) Wolfe15 Wolfe B.R., Pierce N.A.: Nucleic Acid Sequence Design for a Test Tube of Interacting Nucleic Acid Strands . ACS Synth. Biol.. 4 , (2015) Fornace20 Fornace M.E., Porubsky N.J., Pierce N.A.: A Unified Dynamic Programming Framework for the Analysis of Interacting Nucleic Acid Strands: Enhanced Models, Scalability, and Speed . ACS Synth. Biol.. (2020)","title":"Overview"},{"location":"#overview","text":"","title":"Overview"},{"location":"#about","text":"NUPACK is a growing software suite for the analysis and design of nucleic acid structures, devices, and systems serving the needs of researchers in the fields of nucleic acid nanotechnology, molecular programming, synthetic biology, and across the life sciences more broadly. Much of this software can be conveniently run using the NUPACK web application at nupack.org [ Zadeh11a ]. This User Guide provides documentation for the NUPACK Python module. When finishing a project that has benefited from NUPACK calculations, please remember to cite the NUPACK web application and algorithms appropriately; citations are an important component in helping to secure funding for NUPACK development and maintenance. Please email us with questions, comments, feature requests, and bug reports at support@nupack.org . \u2014 The NUPACK Team","title":"About"},{"location":"#problem-categories","text":"NUPACK algorithms address two fundamental classes of problems: Sequence analysis: given a set of DNA or RNA strands, analyze the equilibrium base-pairing properties over a specified ensemble. Sequence design: given a set of desired equilibrium base-pairing properties, design the sequences of a set of DNA or RNA strands over a specified ensemble. Sequence design is performed subject to diverse user-specified sequence constraints including composition constraints, complementarity constraints, pattern prevention constraints, and biological constraints. Figure : Sequence analysis and design using NUPACK. NUPACK algorithms operate over two fundamental ensembles: Complex ensemble: the ensemble of all (unpseudoknotted connected) secondary structures for an arbitrary number of interacting RNA or DNA strands. Test tube ensemble: the ensemble of a dilute solution containing an arbitrary number of RNA or DNA strand species (introduced at user-specified concentrations) interacting to form an arbitrary number of complex species. Furthermore, to enable reaction pathway engineering of dynamic hybridization cascades or large-scale structural engineering including pseudoknots, NUPACK generalizes sequence analysis and design to multi-complex and multi-tube ensembles [ Wolfe17 ]. NUPACK capabilities are presented in three categories: Analysis: Analyze the equilibrium base-pairing properties one or more test tube ensembles (or one or more complex ensembles). These are the all-purpose sequence analysis tools. Design: Design the the sequences for one or more test tube ensembles (or one or more complex ensembles). These are the all-purpose sequence design tools. Utilities: Analyze or design a single complex ensemble. These are quick tools applicable when your ensemble is a single complex. Examples Load Python NUPACK module from nupack import * Specify a physical model model1 = Model ( material = 'rna' , celsius = 37 ) Analyze a test tube # specify strands A = Strand ( 'CTGATCGAT' , name = 'Strand A' ) B = Strand ( 'GATCGTAGTC' , name = 'Strand B' ) # specify tube t1 = Tube ( strands = { A : 1e-8 , B : 1e-9 }, complexes = SetSpec ( max_size = 2 ), name = 'Tube 1' ) # all complexes of up to 2 strands # run tube analysis job my_results = tube_analysis ( tubes = [ t1 ], model = model1 ) Design a test tube a = Domain ( 'A4' , name = 'Domain a' ) b = Domain ( 'N10' , name = 'Domain b' ) # equivalent sequence specification c = Domain ( 'R5N5' , name = 'Domain c' ) # specify target strands A = TargetStrand ([ a , a , b ], name = 'Strand A' ) B = TargetStrand ([ ~ b , ~ c ], name = 'Strand B' ) # ~e denotes the reverse complement of e C = TargetStrand ([ c ], name = 'Strand C' ) # specify target complexes C1 = TargetComplex ([ A , B , C ], '.8(10+)10(10+)10' , name = 'Complex C1' ) C2 = TargetComplex ([ B , C ], '.10(10+)10' , name = 'Complex C2' ) # specify target tube tt1 = TargetTube ( on_targets = { C1 : 1e-8 , C2 : 1e-8 }, off_targets = SetSpec ( max_size = 3 ), # all off-target complexes of up to 3 strands name = 'TargetTube 1' ) # specify tube design problem my_des = tube_design ( tubes = [ tt1 ], hard_constraints = [], soft_constraints = [], defect_weights = None , options = None , model = model1 ) # run tube design job des_results = my_des . run ( trials = 3 ) # run 3 independent design trials","title":"Problem Categories"},{"location":"#license","text":"NUPACK Software License Agreement for Non-Commercial Academic Use Copyright \u00a9 2003\u20132022. California Institute of Technology. All rights reserved. Use of the NUPACK Python module and/or source code (\u201cSoftware\u201d) in source form and/or binary form, with or without modification, is permitted for non-commercial academic purposes only, subject to the conditions and disclaimer stated below. Conditions 1. Redistribution of the Software in source form and/or binary form is not permitted. 2. Web applications that use the Software in source form and/or binary form are not permitted. 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote derivative works without specific prior written permission. Disclaimer The Software is provided by the copyright holders and contributors \u201cas is\u201d and any express or implied warranties, including, but not limited to, the implied warranties of merchantability and fitness for a particular purpose are disclaimed. In no event shall the copyright holder or contributors be liable for any direct, indirect, incidental, special, exemplary, or consequential damages (including, but not limited to, procurement of substitute goods or services; loss of use, data, or profits; or business interruption) however caused and on any theory of liability, whether in contract, strict liability, or tort (including negligence or otherwise) arising in any way out of the use of this software, even if advised of the possibility of such damage. Contact For any questions about this Software License Agreement please contact info@nupack.org .","title":"License"},{"location":"#citation","text":"For citation, please select from the list below as appropriate for your application: NUPACK Web Application Run jobs online at nupack.org J. N. Zadeh, C. D. Steenberg, J. S. Bois, B. R. Wolfe, M. B. Pierce, A. R. Khan, R. M. Dirks, N. A. Pierce. NUPACK: analysis and design of nucleic acid systems. J Comput Chem , 32:170\u2013173, 2011. ( pdf ) NUPACK Analysis Algorithms Complex analysis and test tube analysis M.E. Fornace, N.J. Porubsky, and N.A. Pierce (2020). A unified dynamic programming framework for the analysis of interacting nucleic acid strands: enhanced models, scalability, and speed. ACS Synth Biol , 9:2665-2678, 2020. ( pdf , supp info ) R. M. Dirks, J. S. Bois, J. M. Schaeffer, E. Winfree, and N. A. Pierce. Thermodynamic analysis of interacting nucleic acid strands. SIAM Rev , 49:65-88, 2007. ( pdf ) Pseudoknot analysis R. M. Dirks and N. A. Pierce. An algorithm for computing nucleic acid base-pairing probabilities including pseudoknots. J Comput Chem , 25:1295-1304, 2004. ( pdf ) R. M. Dirks and N. A. Pierce. A partition function algorithm for nucleic acid secondary structure including pseudoknots. J Comput Chem , 24:1664-1677, 2003. ( pdf , supp info ) NUPACK Design Algorithms Multi-tube design B. R. Wolfe, N. J. Porubsky, J. N. Zadeh, R. M. Dirks, and N. A. Pierce. Constrained multistate sequence design for nucleic acid reaction pathway engineering. J Am Chem Soc , 139:3134-3144, 2017. ( pdf , supp info ) Test tube design B. R. Wolfe and N. A. Pierce. Sequence design for a test tube of interacting nucleic acid strands. ACS Synth Biol , 4:1086-1100, 2015. ( pdf , supp info , supp tests ) Complex design J. N. Zadeh, B. R. Wolfe, and N. A. Pierce. Nucleic acid sequence design via efficient ensemble defect optimization. J Comput Chem , 32:439\u2013452, 2011. ( pdf , supp info , supp tests ) Design paradigms R. M. Dirks, M. Lin, E. Winfree, and N. A. Pierce. Paradigms for computational nucleic acid design. Nucl Acids Res , 32:1392-1403, 2004. ( pdf , supp info , supp seqs )","title":"Citation"},{"location":"#acknowledgments","text":"We thank all the NUPACK users that have helped out as beta testers over the years, as well as the many NUPACK users that have emailed support@nupack.org to request features or report bugs. NUPACK is supported by the National Science Foundation (NSF-OAC-1835414) and by the Beckman Institute at Caltech (PMTC). NUPACK has previously been supported by the National Science Foundation (NSF-CCF-1317694, NSF-CCF-0832824, NSF-CHE-0533064, NSF-DMS-0506468, NSF-CAREER-0448835), by the Gordon and Betty Moore Foundation (GBMF2809), by the John Simon Guggenheim Memorial Foundation, by the National Institutes of Health (P50 HG004071), by the Ralph M. Parsons Foundation, and by the Charles Lee Powell Foundation.","title":"Acknowledgments"},{"location":"#versions","text":"NUPACK 3.0 Features: complex analysis [ Dirks07 ] complex design [ Zadeh11b ] test tube analysis [ Dirks07 ] Executables: pfunc , pairs , mfe , subopt , count , energy , prob , pairs , defect , complexes , concentrations , distributions , design These executables read input files containing comment lines preceded by % ; blank lines are not permitted. Terminology and notation: details in [ Dirks07 ] NUPACK 3.1 New features: test tube design [ Wolfe15 ] New executables: tubedesign and tubedefect These executables read *.np script files written in v1 of the NUPACK scripting language In *.np script files, a comment begins with # and continues for the rest of the line; blank lines are permitted. Changes to existing executables: Name of executable design changed to complexdesign . Name of executable defect changed to complexdefect . Updates to the default options and output file formats for executables complexes , concentrations , and distributions . Use option -v3.0 to revert to NUPACK 3.0 behavior using NUPACK 3.1. Terminology and notation: details in Section 1.1 of NUPACK 3.1 User Guide NUPACK 3.2 New features: constrained multistate test tube design [ Wolfe17 ] New executables: multitubedesign and multitubedefect These executables read *.np script files written in v2 of the NUPACK scripting language. In *.np script files, a comment begins with # and continues for the rest of the line; blank lines are permitted. Terminology and notation: details in Section 1.1 of NUPACK 3.2 User Guide NUPACK 4.0 New features: unified dynamic programming framework [ Fornace20 ] all-new code base all-new NUPACK Python module Commands: Scripting is done in Python Indices start at 0 (previous versions indexed starting at 1) Terminology and notation: details in [ Fornace20 ] Revision notes: 4.0.0.20: Release of first public beta 4.0.0.21: Fix SSM display issue and wobble evaluation bug in design 4.0.0.23: Fix incorrect rounding of ensemble_size result 4.0.0.24: Fix diverging estimate of defects seen in design checkpoints 4.0.0.25: Fix concentration failure resulting from division by 0 4.0.0.26: Fix number of samples given for indistinguishable complexes 4.0.0.27: Add native support for Mac arm64 (M1) architectures 4.0.0.28: Add native support for Linux arch64 architecture, support Python 3.10, fix similarity soft constraint when specifying multiple domains 4.0.1.0: Add fraction_unpaired_bases functionality, revise implementation of parallelism and cache usage, improve input validation 4.0.1.1: Enable parallelism by default, add the threads setting, and set design to only use up to N threads on a machine with N cores 4.0.1.2: Remove support for Python 3.6, fix several bugs in 4.0.1 to do with parallel submission of designs, reloading designs, and other minor user interface problems 4.0.1.3: Fix unbounded growth in memory cache, optimize parallelism in design further, minor interface improvements 4.0.1.4: Fix concentration equilibration initial guess which occasionally caused lack of convergence 4.0.1.5: Fix large memory usage in analysis jobs containing many complexes, improve cache constraint 4.0.1.6: Fix missing nt() method in Domain class 4.0.1.7: Fix memory leak in Python when running many analyses sequentially 4.0.1.8: Add support for Python 3.11 4.0.1.9: Add support for Python 3.12 and fix rare issue in equilibrium concentration convergence 4.0.1.10: Fix issue when specifying mixtures of sequences containing U and T and provide binaries with more conservative instruction sets for Linux 4.0.1.11: Fix output printing for sequences containing U and T to match user inputs when possible Zadeh11a Zadeh J.N., Steenberg C.D., Bois J.S., Wolfe B.R., Pierce M.B., Khan A.R., Dirks R.M., Pierce N.A.: NUPACK: Analysis and Design of Nucleic Acid Systems . J. Comput. Chem.. 32 , (2011) Wolfe17 Wolfe B.R., Porubsky N.J., Zadeh J.N., Dirks R.M., Pierce N.A.: Constrained Multistate Sequence Design for Nucleic Acid Reaction Pathway Engineering . J Am. Chem. Soc.. 139 , (2017) Dirks07 Dirks R.M., Bois J.S., Schaeffer J.M., Winfree E., Pierce N.A.: Thermodynamic Analysis of Interacting Nucleic Acid Strands . SIAM Rev.. 49 , (2007) Zadeh11b Zadeh J.N., Wolfe B.R., Pierce N.A.: Nucleic Acid Sequence Design via Efficient Ensemble Defect Optimization . J. Comput. Chem.. 32 , (2011) Wolfe15 Wolfe B.R., Pierce N.A.: Nucleic Acid Sequence Design for a Test Tube of Interacting Nucleic Acid Strands . ACS Synth. Biol.. 4 , (2015) Fornace20 Fornace M.E., Porubsky N.J., Pierce N.A.: A Unified Dynamic Programming Framework for the Analysis of Interacting Nucleic Acid Strands: Enhanced Models, Scalability, and Speed . ACS Synth. Biol.. (2020)","title":"Versions"},{"location":"advanced/","text":"Advanced \u00b6 Parallelism \u00b6 By default, NUPACK 4 is fully parallelized across each analysis job , design trial , and utilities job . Parallelism may be further controlled using the config.threads setting (default 0 as of 4.0.1.1; previously 1 ): from nupack import * config . threads = 1 This setting denotes the maximum number of threads that all NUPACK calculations can use concurrently within a single Python process. With the (recommended) default setting of config.threads=0 , NUPACK jobs will be permitted to use all N cores on your machine. Two types of parallelism are enabled: Block-level parallelism . Subcomplex blocks in the dynamic program will be calculated in parallel (e.g., triangular blocks A , B , C , and rectangular blocks AB , BC , and ABC for complex ABC ; see Figure 8 of [ Fornace20 ]). This mode of parallelism will be enabled for all complexes in a multi-tube ensemble. Element-level parallelism . Subsequence elements will be calculated in parallel within a subcomplex block. This mode of parallelism will only be employed for subcomplex blocks containing at least 100 nt. An additional level of parallelism is enabled when running multiple independent design trials. For example, tube_design with trials=4 and config.threads == 1 will use min(4,N) threads. Hence, for design jobs, it is recommended that the value of config.threads be left at the default value of 0 or else be set to be no smaller than min(trials,N) . Caching \u00b6 NUPACK 4 introduces subcomplex block caching to achieve dramatic speedups by avoiding recalculation of subcomplex intermediates for a multi-tube ensemble (see Figure 8 of [ Fornace20 ]). The config.cache flag (GB; default 2.0) controls the gigabytes of memory that each analysis job , design trial , or utilities job can use. from nupack import * config . cache = 8.0 # GB This flag may be set to 0.0 to disable caching if your hardware has very little memory. Naming conventions \u00b6 Analysis objects of type Strand , Complex , Tube and design objects of type Domain , TargetStrand , TargetComplex , and TargetTube all accept a name specified using the name keyword. Note Within the context of a single calculation, every object name must be unique (e.g., each Strand , Complex , and Tube in an analysis calculation must have a unique name). The name may specified as a tuple or list instead of a str , in which case a '[]' -based string will be automatically generated. This convention is especially useful for repeated definitions: domains = [ Domain ( 'N6' , name = [ 'a' , i ]) for i in range ( 4 )] print ([ d . name for d in domains ]) # --> ['a[0]', 'a[1]', 'a[2]', 'a[3]'] See the examples below that make use of this convention to specify designs for orthogonal reaction pathways. Design orthogonal reaction pathways \u00b6 Reaction pathways can be designed by specifying target test tubes and formulating a constrained multi-tube design problem . Following the target test tube specification of [ Wolfe17 ] (see Supplemenatary Section S2.2), for a reaction pathway with M elementary steps, to design N orthogonal systems, there are N*(M+1) elementary step tubes plus 1 global crosstalk tube. Below, we provide example design specifications and Jupyter notebooks for designing N orthogonal systems for 1-step and multi-step reaction pathways: Multi-tube design (simple): design specification ( tex ) design N orthogonal one-step reaction pathways Multi-tube design (advanced): design specification ( tex ) design N orthogonal multi-step reaction pathways Note Note that target test tubes for N orthogonal systems can be concisely defined using a Python loop. Note Sample \\LaTeX \\LaTeX files are provided for the above multi-tube design specifications to assist with making new design specs in a standardized format. Fornace20 Fornace M.E., Porubsky N.J., Pierce N.A.: A Unified Dynamic Programming Framework for the Analysis of Interacting Nucleic Acid Strands: Enhanced Models, Scalability, and Speed . ACS Synth. Biol.. (2020) Wolfe17 Wolfe B.R., Porubsky N.J., Zadeh J.N., Dirks R.M., Pierce N.A.: Constrained Multistate Sequence Design for Nucleic Acid Reaction Pathway Engineering . J Am. Chem. Soc.. 139 , (2017)","title":"Advanced"},{"location":"advanced/#advanced","text":"","title":"Advanced"},{"location":"advanced/#parallelism","text":"By default, NUPACK 4 is fully parallelized across each analysis job , design trial , and utilities job . Parallelism may be further controlled using the config.threads setting (default 0 as of 4.0.1.1; previously 1 ): from nupack import * config . threads = 1 This setting denotes the maximum number of threads that all NUPACK calculations can use concurrently within a single Python process. With the (recommended) default setting of config.threads=0 , NUPACK jobs will be permitted to use all N cores on your machine. Two types of parallelism are enabled: Block-level parallelism . Subcomplex blocks in the dynamic program will be calculated in parallel (e.g., triangular blocks A , B , C , and rectangular blocks AB , BC , and ABC for complex ABC ; see Figure 8 of [ Fornace20 ]). This mode of parallelism will be enabled for all complexes in a multi-tube ensemble. Element-level parallelism . Subsequence elements will be calculated in parallel within a subcomplex block. This mode of parallelism will only be employed for subcomplex blocks containing at least 100 nt. An additional level of parallelism is enabled when running multiple independent design trials. For example, tube_design with trials=4 and config.threads == 1 will use min(4,N) threads. Hence, for design jobs, it is recommended that the value of config.threads be left at the default value of 0 or else be set to be no smaller than min(trials,N) .","title":"Parallelism"},{"location":"advanced/#caching","text":"NUPACK 4 introduces subcomplex block caching to achieve dramatic speedups by avoiding recalculation of subcomplex intermediates for a multi-tube ensemble (see Figure 8 of [ Fornace20 ]). The config.cache flag (GB; default 2.0) controls the gigabytes of memory that each analysis job , design trial , or utilities job can use. from nupack import * config . cache = 8.0 # GB This flag may be set to 0.0 to disable caching if your hardware has very little memory.","title":"Caching"},{"location":"advanced/#naming-conventions","text":"Analysis objects of type Strand , Complex , Tube and design objects of type Domain , TargetStrand , TargetComplex , and TargetTube all accept a name specified using the name keyword. Note Within the context of a single calculation, every object name must be unique (e.g., each Strand , Complex , and Tube in an analysis calculation must have a unique name). The name may specified as a tuple or list instead of a str , in which case a '[]' -based string will be automatically generated. This convention is especially useful for repeated definitions: domains = [ Domain ( 'N6' , name = [ 'a' , i ]) for i in range ( 4 )] print ([ d . name for d in domains ]) # --> ['a[0]', 'a[1]', 'a[2]', 'a[3]'] See the examples below that make use of this convention to specify designs for orthogonal reaction pathways.","title":"Naming conventions"},{"location":"advanced/#design-orthogonal-reaction-pathways","text":"Reaction pathways can be designed by specifying target test tubes and formulating a constrained multi-tube design problem . Following the target test tube specification of [ Wolfe17 ] (see Supplemenatary Section S2.2), for a reaction pathway with M elementary steps, to design N orthogonal systems, there are N*(M+1) elementary step tubes plus 1 global crosstalk tube. Below, we provide example design specifications and Jupyter notebooks for designing N orthogonal systems for 1-step and multi-step reaction pathways: Multi-tube design (simple): design specification ( tex ) design N orthogonal one-step reaction pathways Multi-tube design (advanced): design specification ( tex ) design N orthogonal multi-step reaction pathways Note Note that target test tubes for N orthogonal systems can be concisely defined using a Python loop. Note Sample \\LaTeX \\LaTeX files are provided for the above multi-tube design specifications to assist with making new design specs in a standardized format. Fornace20 Fornace M.E., Porubsky N.J., Pierce N.A.: A Unified Dynamic Programming Framework for the Analysis of Interacting Nucleic Acid Strands: Enhanced Models, Scalability, and Speed . ACS Synth. Biol.. (2020) Wolfe17 Wolfe B.R., Porubsky N.J., Zadeh J.N., Dirks R.M., Pierce N.A.: Constrained Multistate Sequence Design for Nucleic Acid Reaction Pathway Engineering . J Am. Chem. Soc.. 139 , (2017)","title":"Design orthogonal reaction pathways"},{"location":"analysis/","text":"Analysis Jobs \u00b6 NUPACK provides the capability to analyze equilibrium properties over one of two ensembles: Complex Analysis: analyze the equilibrium base-pairing properties of a complex of interacting nucleic acid strands [ Dirks07 , Fornace20 ]. Test Tube Analysis: analyze the equilibrium concentrations and base-pairing properties for a test tube of interacting nucleic acid strands [ Dirks07 , Fornace20 ]. Note that a complex ensemble is subsidiary to a test tube ensemble, so complex analysis is inherent in test tube analysis (but not vice versa). As it is typically infeasible to experimentally study a single complex in isolation, we recommend analyzing nucleic acid strands in a test tube ensemble that contains the complex of interest as well as other competing complexes that might form in solution. For example, if one is experimentally studying strands A and B that are intended to predominantly form a secondary structure within the ensemble of complex A \\cdot \\cdot B, one should not presuppose that the strands do indeed form A \\cdot \\cdot B and simply analyze the base-pairing properties of that complex. Instead, it is more physically relevant to analyze a test tube ensemble containing strands A and B interacting to form multiple complex species (e.g., A, B, A \\cdot \\cdot A, A \\cdot \\cdot B, B \\cdot \\cdot B) so as to capture both concentration information (how much A \\cdot \\cdot B forms?) and structural information (what are the base-pairing properties of A \\cdot \\cdot B when it does form?). NUPACK analysis algorithms enable simultaneous analysis of one or more test tube ensembles, providing significant cost savings if the same strands are present in more than one test tube. If for some reason, the test tube ensemble is not of interest for your application, NUPACK analysis algorithms also enable simultaneous analysis of one or more complex ensembles, providing significant cost savings if the same strands are present in more than one complex. Specify a strand \u00b6 A Strand is a single RNA or DNA molecule specified as a sequence and a strand name (keyword name ): A = Strand ( 'AGUCUAGGAUUCGGCGUGGGUUAA' , name = 'A' ) # name is required for strands B = Strand ( 'UUAACCCACGCCGAAUCCUAGACUCAAAGUAGUCUAGGAUUCGGCGUG' , name = 'B' ) C = Strand ( 'AGUCUAGGAUUCGGCGUGGGUUAACACGCCGAAUCCUAGACUACUUUG' , name = 'C' ) A Strand sequence must contain only 'ACGTU' . Two strands are treated as indistinguishable only if they have the same name and the same sequence. A Strand object supports a nt() method for calculating the number of nucleotides, for example: A . nt () # --> 24 Specify a complex ensemble \u00b6 A Complex of one or more interacting strands is specified as an ordered list of strands (i.e., an ordering of strands around a circle in a polymer graph ) and an optional complex name (keyword name ): c1 = Complex ([ A ]) # name is optional for complexes c2 = Complex ([ A , B , B , C ], name = 'ABBC' ) c3 = Complex ([ A , A ], name = 'AA' ) Note Commands that expect a Complex as an argument (e.g., c2 ) will alternatively accept a strand ordering (e.g., [A, B, B, C] ). Two complexes are considered to be the same if they represent the same strand ordering around a circle independent of rotations (e.g., Complex([A,B,C]) == Complex([B,C,A]) == Complex([C,A,B]) ). In certain cases, it may be desirable to adjust the free energy of a complex (for example, if a protein is known to stabilize the complex). For such cases, the optional keyword bonus can be used to specify an additional free energy in kcal/mol (default: 0; negative value is stabilizing, postive value is destabilizing): # destabilize c4 by 1 kcal/mol c4 = Complex ([ A , B , C ], name = 'ABC' , bonus =+ 1.0 ) # stabilize c5 by 10 kcal/mol c5 = Complex ([ A , B ], name = 'AB' , bonus =- 10.0 ) Additional fields and methods are available for a Complex object: .strands : a tuple of strands .nstrands() : the number of strands in the complex .nt() : the number of nucleotides in the complex For example: c2 . strands # --> (<Strand A>, <Strand B>, <Strand B>, <Strand C>) c2 . nstrands () # --> 4 c2 . nt () # --> 168 Specify a test tube ensemble \u00b6 A Tube is specified as a tube name (keyword name ) and a set of strands (keyword strands ), each introduced at a user-specified concentration (units of M ), that interact to form a set of complexes (keyword complexes : defaults to the strand set). The set of complexes is optionally specified using SetSpec() in any of three ways: Combinatorially using keyword max_size to automatically generate the set of all complexes up to a specified number of strands (default: max_size=1 ). Using keyword include to include an explicitly specified set of complexes (default: None ). Using keyword exclude to exclude an explicitly specified set of complexes (default: None ). For example: t1 = Tube ( strands = { A : 1e-6 , B : 1e-8 }, name = 't1' ) # complexes defaults to [A, B] t2 = Tube ( strands = { A : 1e-6 , B : 1e-8 , C : 1e-12 }, complexes = SetSpec ( max_size = 3 , include = [ c2 ,[ B , B , B , B ]], exclude = [ c1 ]), name = 't2' ) If desired, the complexes in a specified Tube can be queried as follows: print ( t1 . complexes ) # --> {<Complex A>, <Complex B>} print ( t2 . complexes ) # --> {<Complex (C+C+B)>, <Complex (B)>, # <Complex (A+C+B)>, <Complex (C+C+C)>, <Complex (C)>, <Complex (A+A+B)>, # <Complex (A+C)>, <Complex (B+B+B+B)>, <Complex (A+A)>, <Complex (A+B+B)>, # <Complex (B+B)>, <Complex (A+B)>, <Complex (B+B+B)>, <Complex (A+B+C)>, # <Complex (A+C+C)>, <Complex (A+A+A)>, <Complex (C+C)>, <Complex (A+A+C)>, # <Complex ABBC>, <Complex (C+B+B)>, <Complex (C+B)>} Note Note that include and exclude accept both complex identifiers (e.g., c2 ) and strand orderings (e.g., [B, B, B, B] ). Run a test tube analysis job \u00b6 The tube_analysis command calculates the partition function , and equilibrium concentration , for each complex species j j in one or more test tube ensembles. The test tube ensembles to be analyzed are specified using the tubes keyword. If desired, a physical model is specified using the model keyword (otherwise the default physical model is used): # specify strands a = Strand ( 'CUGAUCGAU' , name = 'a' ) b = Strand ( 'GAUCGUAGUC' , name = 'b' ) # specify tubes t1 = Tube ( strands = { a : 1e-8 , b : 1e-9 }, complexes = SetSpec ( max_size = 3 ), name = 't1' ) t2 = Tube ( strands = { a : 1e-10 , b : 1e-9 }, complexes = SetSpec ( max_size = 2 ), name = 't2' ) # analyze tubes model1 = Model () tube_results = tube_analysis ( tubes = [ t1 , t2 ], model = model1 ) tube_analysis returns an AnalysisResult object that can be viewed as a table in a Jupyter notebook, for example: tube_results Output: For each complex in the ensemble, the partition function and complex free energy (units of kcal/mol) are displayed. For each tube, the equilibrium complex concentration of each complex in the tube is displayed (units of M). Optionally, additional quantities are calculated for each complex in the specified tubes (see Job Options ). For example, additionally calculate equilibrium base-pairing probabilities , the MFE proxy structure(s) , 100 Boltzmann-sampled structures , and the ensemble size for each complex in the tube: model1 = Model () tube_results2 = tube_analysis ( tubes = [ t1 , t2 ], model = model1 , compute = [ 'pairs' , 'mfe' , 'sample' , 'ensemble_size' ], options = { 'num_sample' : 100 }) # max_size=1 default To display a summary table of results in a Jupyter notebook: tube_results2 Output: Note that pairs and sample results are too large to be included in the summary table. See below for programmatic access to these results. Note If desired, the results of a tube_analysis job can alternatively be calculated in two steps: Step 1: run a complex_analysis job (to calculate the partition function for each complex); Step 2: run a complex_concentrations job (to calculate the equilibrium concentration for each complex in the context of a test tube given user-specified strand concentrations). Most of the computational cost is in Step 1. The user-specified strand concentrations are used only in Step 2. Hence, if you intend to analyze N test tubes containing the same strand species but N different sets of strand concentrations, it is cheaper to call complex_analysis once and complex_concentrations N times, rather than to call tube_analysis N times. Specify a set of complexes \u00b6 A ComplexSet is specified as a set of strands (keyword strands ) that interact to form a set of complexes (keyword complexes : defaults to the strand set). The set of complexes is optionally specified using SetSpec() in any of three ways: Combinatorially using keyword max_size to automatically generate the set of all complexes up to a specified number of strands (default: max_size=1 ). Using keyword include to include an explicitly specified set of complexes (default: None ). Using keyword exclude to exclude an explicitly specified set of complexes (default: None ). For example: set1 = ComplexSet ( strands = [ A , B , C ]) # complexes defaults to [[A], [B], [C]] set2 = ComplexSet ( strands = [ A , B , C ], complexes = SetSpec ( max_size = 3 , include = [ c2 , [ B , B , B , B ]], exclude = [ c1 ])) Note Note that a ComplexSet and a Tube both specify a set of complexes \\Psi \\Psi that form from a set of strands \\Psi^0 \\Psi^0 . The difference is that Tube further specifies the concentration of each strand in \\Psi^0 \\Psi^0 in order to specify a test tube ensemble . Run a complex analysis job \u00b6 The complex_analysis command calculates one or more physical quantities (see Job Options ) for each complex in a ComplexSet : # specify strands a = Strand ( 'CUGAUCGAU' , name = 'a' ) b = Strand ( 'GAUCGUAGUC' , name = 'b' ) # specify complex set set1 = ComplexSet ( strands = [ a , b ], complexes = SetSpec ( max_size = 3 )) # calculate the partition function for each complex in the complex set model1 = Model () complex_results1 = complex_analysis ( complexes = set1 , model = model1 , compute = [ 'pfunc' ]) complex_analysis returns an AnalysisResult object that can be viewed as a table in a Jupyter notebook, for example: complex_results1 Output: If desired, a Tube can be specified in place of a ComplexSet , in which case the strand concentrations are ignored since complex_analysis does not calculate equilibrium complex concentrations, and hence does not require concentration information for the strand species. For example: # specify strands a = Strand ( 'CUGAUCGAU' , name = 'a' ) b = Strand ( 'GAUCGUAGUC' , name = 'b' ) # specify tube tube1 = Tube ( strands = { a : 1e-8 , b : 1e-10 }, complexes = SetSpec ( max_size = 3 ), name = 'tube1' ) # calculate the partition function for each complex in the tube model1 = Model () complex_results2 = complex_analysis ( complexes = tube1 , model = model1 , compute = [ 'pfunc' ]) Run a complex concentrations job \u00b6 Use the complex_concentrations command to calculate the equilibrium concentration of each complex in a test tube ensemble (keyword tube ) using the AnalysisResult data (keyword data ) from a previous call to complex_analysis (which at minimum must contain the partition function for each complex). The tube ensemble can be specified either using Tube (which specifies strand concentrations) or as a ComplexSet , in which case the strand concentrations must additionally be specified (keyword concentrations ): # specify strand concentrations for ComplexSet set1 concentration_results1 = complex_concentrations ( tube = set1 , data = complex_results1 , concentrations = { a : 1e-8 , b : 1e-8 }) # use strand concentrations previously specified for tube1 concentration_results2 = complex_concentrations ( tube = tube1 , data = complex_results2 ) Note Note that complex_concentrations operates on a single tube ensemble at a time since each tube represents a separate coupled equilibrium problem and no savings can be achieved by considering multiple concentration solves at the same time. complex_concentrations returns an AnalysisResult object that can be viewed as a table in a Jupyter notebook, for example: concentration_results2 Output: Job options \u00b6 The compute keyword is optional for tube_analysis (default: 'pfunc' ) and required for complex_analysis (no default), specifying a list of strings denoting calculations to be performed for each complex [ Fornace20 ]: 'pfunc' : calculate the partition function . 'pairs' : calculate the matrix of equilibrium base-pairing probabilities . If 'pairs' is specified, tube_analysis or complex_concentrations will further calculate the matrix of test tube ensemble pair fractions . See the sparsity_fraction and sparsity_threshold options below. 'sample' : calculate a set of Boltzmann-sampled structures from the complex ensemble. See option num_sample below. 'mfe' : calculate the MFE proxy structure , the free energy of the MFE proxy secondary structure and the free energy of the MFE stacking state. If there is more than one MFE stacking state, the algorithm returns a list of the corresponding MFE proxy secondary structures, each with the free energy of the MFE proxy secondary structure and with the (same) free energy of the MFE stacking state. 'subopt' : calculate the set of suboptimal proxy structures with a stacking state within a specified free energy gap of the MFE stacking state. The algorithm returns a list of suboptimal proxy secondary strutures, each with the free energy of the MFE proxy secondary structure, and with the free energy of its lowest-energy stacking state that falls within the energy gap. See option subopt_gap below. 'ensemble_size' : calculate the complex ensemble size in terms of either the number of secondary structures (if using a physical model with nostacking ) or the number of stacking states (if using a physical model with stacking ). The optional options keyword specifies options that modify the calculations performed for each complex: 'sparsity_fraction': f can be used in conjuction with 'pairs' to return a sparse matrix containing the fraction f of the largest pair probabilities for each base (default 'sparsity': 1 returns the full pair probability matrix). 'sparsity_threshold': t can be used in conjuction with 'pairs' to return a sparse matrix containing the only pair probabilities greater than or equal to t (default 'sparsity_threshold': 0 returns the full pair probability matrix). 'num_sample': n can be used in conjunction with 'sample' to specify the number of structures to be sampled (default 'num_sample': 1 ). 'subopt_gap': g can be used in conjunction with 'subopt' to specify the (non-negative) free energy gap in kcal/mol (default 'subopt_gap': 0 ). By default, NUPACK analysis jobs run in parallel . Job results \u00b6 Scalar results of NUPACK analysis jobs can be conveniently displayed as a table, printed as text, or introspected programmatically. Consider the following test tube analysis job: a = Strand ( 'CCG' , name = 'a' ) b = Strand ( 'CGG' , name = 'b' ) c = Complex ([ a , b ], name = 'c' ) t1 = Tube ({ a : 1e-6 , b : 1e-9 }, complexes = SetSpec ( max_size = 2 , include = [ c ]), name = 't1' ) t2 = Tube ({ a : 1e-8 , b : 1e-9 }, complexes = SetSpec ( include = [ c ]), name = 't2' ) my_model = Model () my_result = tube_analysis ([ t1 , t2 ], model = my_model , compute = [ 'pfunc' , 'pairs' , 'mfe' , 'sample' , 'subopt' ], options = { 'num_sample' : 2 , 'energy_gap' : 0.5 }) Tabular display \u00b6 You can display a summary table of results in a Jupyter notebook, for example: my_result Output: Textual display \u00b6 You can view an ASCII representation of the same data by using the print function: print ( my_result ) Output: Complex results: Complex Pfunc dG (kcal/mol) MFE (kcal/mol) 0 (a) 1.0000e+0 0.000 0.000 1 (b) 1.0000e+0 0.000 0.000 2 c 1.3519e+3 -4.443 -4.081 3 (a+a) 1.8846e+1 -1.810 -1.972 4 (b+b) 1.7435e+2 -3.181 -3.523 Concentration results: Complex t1 (M) Complex t2 (M) (a) 1.000e-06 (a) 1.000e-08 (b) 1.000e-09 (b) 1.000e-09 (a+a) 3.418e-13 c 2.452e-16 c 2.452e-14 (b+b) 3.162e-18 For convenience, you can print the identical ASCII result to a text file using the save_text function: my_result . save_text ( 'my_result.txt' ) Programmatic access \u00b6 More detailed results can also be displayed by programmatic access into an AnalysisResult object. This class contains two fields: .complexes : a Python dict mapping each Complex to a ComplexResult .tubes : a Python dict mapping each Tube to a TubeResult The information contained in these two fields depends on which type of analysis calculation was performed: For tube_analysis , the .tubes and .complexes fields are both non-empty. For complex_analysis , only the .complexes field is non-empty. For complex_concentrations , only the .tubes field is non-empty. For convenience, you can index into an AnalysisResult via a Complex or Tube identifier (or via the assigned or auto-generated name of a Complex or Tube ) as described in the following two sections. Results for individual complexes \u00b6 You can index into AnalysisResult object via a Complex identifier (or via the name of a Complex ) to get a ComplexResult object containing all the complex ensemble quantities that were calculated in a tube_analysis or complex_analysis calculation. A ComplexResult contains the following fields (if a quantity was not computed, the field is set to None ): pfunc : the complex partition function (held as a decimal.Decimal ; convert to a float via float(pf) or calculate the logarithm via float(pf.log()) ). free_energy : the complex free energy in kcal/mol (held as a float ). pairs : the matrix of equilibrium base-pairing probabilities (held as a PairsMatrix object containing a .to_array() method for conversion to numpy as illustrated below). sample : a list of Boltzmann-sampled structures , each an instance of a Structure object. mfe : a list of MFE proxy structures . Each entry contains fields .structure , .energy , and .stack_energy . .energy is the free energy of the MFE proxy secondary structure, while .stack_energy is the free energy of the MFE stacking state. subopt : a list of suboptimal proxy structures . Each entry contains fields .structure , .energy , and .stack_energy . .energy is the free energy of the MFE proxy secondary structure, while .stack_energy is the free energy of its lowest-energy stacking state that falls within the energy gap. ensemble_size : the complex ensemble size (held as int ) representing either the number of secondary structures (if using a physical model with nostacking ) or the number of stacking states (if using a physical model with stacking ). model : the Model that was used for the analysis calculation. For example, we can index the AnalysisResult object my_result with complex c (or by its name 'c' ) to obtain a ComplexResult object c_result that enables printing of specific physical quantities for that complex: c_result = my_result [ c ] # equivalent to my_result['c'] print ( 'Physical quantities for complex c' ) print ( 'Complex free energy: %.2f kcal/mol' % c_result . free_energy ) print ( 'Partition function: %.2e ' % c_result . pfunc ) print ( 'MFE proxy structure: %s ' % c_result . mfe [ 0 ] . structure ) print ( 'Free energy of MFE proxy structure: %.2f kcal/mol' % c_result . mfe [ 0 ] . energy ) print ( 'Equilibrium pair probabilities: \\n %s ' % c_result . pairs ) Output: Physical quantities for complex c Complex free energy: -4.44 kcal/mol Partition function: 1.35e+03 MFE proxy structure: (((+))) Free energy of MFE proxy structure: -4.08 kcal/mol Equilibrium pair probabilities: [[0.1000 0.0000 0.0000 0.0000 0.0061 0.8938] [0.0000 0.0083 0.0000 0.0000 0.9873 0.0044] [0.0000 0.0000 0.3839 0.6161 0.0000 0.0000] [0.0000 0.0000 0.6161 0.3839 0.0000 0.0000] [0.0061 0.9873 0.0000 0.0000 0.0066 0.0000] [0.8938 0.0044 0.0000 0.0000 0.0000 0.1018]] Note Note that a complex such as (a+a) that was auto-generated as part of the test tube ensemble (using max_size=2 ) does not have an identifier, but does have an auto-generated name that can be used to index an AnalysisResult : aa_result = my_result [ '(a+a)' ] If desired, the MFE proxy structure can be represented as a structure matrix of zeros and ones: c_result = my_result [ c ] print ( 'MFE proxy structure: \\n %s ' % c_result . mfe [ 0 ] . structure . matrix ()) Output: MFE proxy structure: [[0 0 0 0 0 1] [0 0 0 0 1 0] [0 0 0 1 0 0] [0 0 1 0 0 0] [0 1 0 0 0 0] [1 0 0 0 0 0]] The equilibrium pair probability matrix is returned as a PairsMatrix object, which can be converted to a numpy array via the to_array() method for display in a Jupyter notebook: import matplotlib.pyplot as plt plt . imshow ( my_result [ c ] . pairs . to_array ()) plt . xlabel ( 'Base index' ) plt . ylabel ( 'Base index' ) plt . title ( 'Pair probabilities for complex c' ) plt . colorbar () plt . clim ( 0 , 1 ) plt . savefig ( 'my-figure.pdf' ) # optionally, save a PDF of your figure Output: Note If your installation of matplotlib is not up-to-date, you may need to include %matplotlib inline at the top of the Jupyter notebook for the pairs plot to appear in your notebook instead of in a separate window. For some use cases, you may wish to convert a PairsMatrix to a scipy matrix via the to_sparse() method. It is straightforward to collect information across complexes in an AnalysisResult object. Since my_result.complexes is an ordinary python dict , iterating through its .items() enables collection of each complex result. For example, to operate on the equilibrium pair probability matrix for each complex in my_result : import numpy as np for my_complex , complex_result in my_result . complexes . items (): P = complex_result . pairs . to_array () s = 'Expected number of unpaired nucleotides at equilibrium in complex %s = %.2f ' print ( s % ( my_complex . name , np . diagonal ( P ) . sum ())) Output: Expected number of unpaired nucleotides at equilibrium in complex c = 0.98 Expected number of unpaired nucleotides at equilibrium in complex (b) = 3.00 Expected number of unpaired nucleotides at equilibrium in complex (a+a) = 2.70 Expected number of unpaired nucleotides at equilibrium in complex (b+b) = 2.25 Expected number of unpaired nucleotides at equilibrium in complex (a) = 3.00 To collect a dict of MFEs for each complex: my_mfes = { my_complex . name : complex_result . mfe [ 0 ] . energy for my_complex , complex_result in my_result . complexes . items ()} print ( my_mfes ) Output: {'c': -4.081351280212402, '(b)': 0.0, '(a+a)': -1.9719057083129883, '(b+b)': -3.5225014686584473, '(a)': 0.0} To print out the complex concentrations for a given tube: for my_complex , conc in my_result . tubes [ t1 ] . complex_concentrations . items (): print ( 'The equilibrium concentration of %s is %.2e M' % ( my_complex . name , conc )) Output: The equilibrium concentration of c is 2.45e-14 M The equilibrium concentration of (b) is 1.00e-09 M The equilibrium concentration of (a+a) is 3.42e-13 M The equilibrium concentration of (b+b) is 3.16e-18 M The equilibrium concentration of (a) is 1.00e-06 M Results for individual test tubes \u00b6 You can index into an AnalysisResult object via a Tube identifier (or via the name of a Tube ) to get a TubeResult object containing all the tube ensemble quantities that were calculated in a tube_analysis or complex_concentrations calculation. This class contains the following fields: complex_concentrations : a dict from Complex to its equilibrium concentration in molar (held as a float ). fraction_bases_unpaired : a float in [0,1] [0,1] denoting the equilibrium fraction of nucleotides that are unpaired in the test tube ensemble. ensemble_pair_fractions : a square matrix of test tube ensemble pair fractions . Row and column indices refer to the concatenated base index formed by concatenating the strands of the input Tube (in order). This field is None if pair probabilities were not calculated (i.e., if option pairs was not specified for the tube_analysis or complex_analysis job). Concentrations may be printed as follows: t1_result = my_result [ t1 ] # equivalent to my_result['t1'] for my_complex , conc in t1_result . complex_concentrations . items (): print ( 'The equilibrium concentration of %s is %.3e M' % ( my_complex . name , conc )) Output: The equilibrium concentration of c is 2.452e-14 M The equilibrium concentration of (b) is 1.000e-09 M The equilibrium concentration of (a+a) is 3.418e-13 M The equilibrium concentration of (b+b) is 3.162e-18 M The equilibrium concentration of (a) is 1.000e-06 M Test tube ensemble pair fractions may be printed as follows: print ( t1_result . ensemble_pair_fractions ) Output: [[1.0000 0.0000 0.0000 0.0000 0.0000 0.0000] [0.0000 1.0000 0.0000 0.0000 0.0000 0.0000] [0.0000 0.0000 1.0000 0.0000 0.0000 0.0000] [0.0000 0.0000 0.0000 1.0000 0.0000 0.0000] [0.0000 0.0000 0.0000 0.0000 1.0000 0.0000] [0.0000 0.0000 0.0000 0.0000 0.0000 1.0000]] Saving a job summary \u00b6 To save a textual job summary using the save_text method: my_result . save_text ( 'my-result.txt' ) Saving and reloading job results \u00b6 Save an AnalysisResult as a binary file using the save method: my_result . save ( 'my-result.o' ) to enable reloading during a future session using the load method: my_result = AnalysisResult . load ( 'my-result.o' ) This functionality uses Python\u2019s built-in pickle module. Dirks07 Dirks R.M., Bois J.S., Schaeffer J.M., Winfree E., Pierce N.A.: Thermodynamic Analysis of Interacting Nucleic Acid Strands . SIAM Rev.. 49 , (2007) Fornace20 Fornace M.E., Porubsky N.J., Pierce N.A.: A Unified Dynamic Programming Framework for the Analysis of Interacting Nucleic Acid Strands: Enhanced Models, Scalability, and Speed . ACS Synth. Biol.. (2020)","title":"Analysis Jobs"},{"location":"analysis/#analysis-jobs","text":"NUPACK provides the capability to analyze equilibrium properties over one of two ensembles: Complex Analysis: analyze the equilibrium base-pairing properties of a complex of interacting nucleic acid strands [ Dirks07 , Fornace20 ]. Test Tube Analysis: analyze the equilibrium concentrations and base-pairing properties for a test tube of interacting nucleic acid strands [ Dirks07 , Fornace20 ]. Note that a complex ensemble is subsidiary to a test tube ensemble, so complex analysis is inherent in test tube analysis (but not vice versa). As it is typically infeasible to experimentally study a single complex in isolation, we recommend analyzing nucleic acid strands in a test tube ensemble that contains the complex of interest as well as other competing complexes that might form in solution. For example, if one is experimentally studying strands A and B that are intended to predominantly form a secondary structure within the ensemble of complex A \\cdot \\cdot B, one should not presuppose that the strands do indeed form A \\cdot \\cdot B and simply analyze the base-pairing properties of that complex. Instead, it is more physically relevant to analyze a test tube ensemble containing strands A and B interacting to form multiple complex species (e.g., A, B, A \\cdot \\cdot A, A \\cdot \\cdot B, B \\cdot \\cdot B) so as to capture both concentration information (how much A \\cdot \\cdot B forms?) and structural information (what are the base-pairing properties of A \\cdot \\cdot B when it does form?). NUPACK analysis algorithms enable simultaneous analysis of one or more test tube ensembles, providing significant cost savings if the same strands are present in more than one test tube. If for some reason, the test tube ensemble is not of interest for your application, NUPACK analysis algorithms also enable simultaneous analysis of one or more complex ensembles, providing significant cost savings if the same strands are present in more than one complex.","title":"Analysis Jobs"},{"location":"analysis/#specify-a-strand","text":"A Strand is a single RNA or DNA molecule specified as a sequence and a strand name (keyword name ): A = Strand ( 'AGUCUAGGAUUCGGCGUGGGUUAA' , name = 'A' ) # name is required for strands B = Strand ( 'UUAACCCACGCCGAAUCCUAGACUCAAAGUAGUCUAGGAUUCGGCGUG' , name = 'B' ) C = Strand ( 'AGUCUAGGAUUCGGCGUGGGUUAACACGCCGAAUCCUAGACUACUUUG' , name = 'C' ) A Strand sequence must contain only 'ACGTU' . Two strands are treated as indistinguishable only if they have the same name and the same sequence. A Strand object supports a nt() method for calculating the number of nucleotides, for example: A . nt () # --> 24","title":"Specify a strand"},{"location":"analysis/#specify-a-complex-ensemble","text":"A Complex of one or more interacting strands is specified as an ordered list of strands (i.e., an ordering of strands around a circle in a polymer graph ) and an optional complex name (keyword name ): c1 = Complex ([ A ]) # name is optional for complexes c2 = Complex ([ A , B , B , C ], name = 'ABBC' ) c3 = Complex ([ A , A ], name = 'AA' ) Note Commands that expect a Complex as an argument (e.g., c2 ) will alternatively accept a strand ordering (e.g., [A, B, B, C] ). Two complexes are considered to be the same if they represent the same strand ordering around a circle independent of rotations (e.g., Complex([A,B,C]) == Complex([B,C,A]) == Complex([C,A,B]) ). In certain cases, it may be desirable to adjust the free energy of a complex (for example, if a protein is known to stabilize the complex). For such cases, the optional keyword bonus can be used to specify an additional free energy in kcal/mol (default: 0; negative value is stabilizing, postive value is destabilizing): # destabilize c4 by 1 kcal/mol c4 = Complex ([ A , B , C ], name = 'ABC' , bonus =+ 1.0 ) # stabilize c5 by 10 kcal/mol c5 = Complex ([ A , B ], name = 'AB' , bonus =- 10.0 ) Additional fields and methods are available for a Complex object: .strands : a tuple of strands .nstrands() : the number of strands in the complex .nt() : the number of nucleotides in the complex For example: c2 . strands # --> (<Strand A>, <Strand B>, <Strand B>, <Strand C>) c2 . nstrands () # --> 4 c2 . nt () # --> 168","title":"Specify a complex ensemble"},{"location":"analysis/#specify-a-test-tube-ensemble","text":"A Tube is specified as a tube name (keyword name ) and a set of strands (keyword strands ), each introduced at a user-specified concentration (units of M ), that interact to form a set of complexes (keyword complexes : defaults to the strand set). The set of complexes is optionally specified using SetSpec() in any of three ways: Combinatorially using keyword max_size to automatically generate the set of all complexes up to a specified number of strands (default: max_size=1 ). Using keyword include to include an explicitly specified set of complexes (default: None ). Using keyword exclude to exclude an explicitly specified set of complexes (default: None ). For example: t1 = Tube ( strands = { A : 1e-6 , B : 1e-8 }, name = 't1' ) # complexes defaults to [A, B] t2 = Tube ( strands = { A : 1e-6 , B : 1e-8 , C : 1e-12 }, complexes = SetSpec ( max_size = 3 , include = [ c2 ,[ B , B , B , B ]], exclude = [ c1 ]), name = 't2' ) If desired, the complexes in a specified Tube can be queried as follows: print ( t1 . complexes ) # --> {<Complex A>, <Complex B>} print ( t2 . complexes ) # --> {<Complex (C+C+B)>, <Complex (B)>, # <Complex (A+C+B)>, <Complex (C+C+C)>, <Complex (C)>, <Complex (A+A+B)>, # <Complex (A+C)>, <Complex (B+B+B+B)>, <Complex (A+A)>, <Complex (A+B+B)>, # <Complex (B+B)>, <Complex (A+B)>, <Complex (B+B+B)>, <Complex (A+B+C)>, # <Complex (A+C+C)>, <Complex (A+A+A)>, <Complex (C+C)>, <Complex (A+A+C)>, # <Complex ABBC>, <Complex (C+B+B)>, <Complex (C+B)>} Note Note that include and exclude accept both complex identifiers (e.g., c2 ) and strand orderings (e.g., [B, B, B, B] ).","title":"Specify a test tube ensemble"},{"location":"analysis/#run-a-test-tube-analysis-job","text":"The tube_analysis command calculates the partition function , and equilibrium concentration , for each complex species j j in one or more test tube ensembles. The test tube ensembles to be analyzed are specified using the tubes keyword. If desired, a physical model is specified using the model keyword (otherwise the default physical model is used): # specify strands a = Strand ( 'CUGAUCGAU' , name = 'a' ) b = Strand ( 'GAUCGUAGUC' , name = 'b' ) # specify tubes t1 = Tube ( strands = { a : 1e-8 , b : 1e-9 }, complexes = SetSpec ( max_size = 3 ), name = 't1' ) t2 = Tube ( strands = { a : 1e-10 , b : 1e-9 }, complexes = SetSpec ( max_size = 2 ), name = 't2' ) # analyze tubes model1 = Model () tube_results = tube_analysis ( tubes = [ t1 , t2 ], model = model1 ) tube_analysis returns an AnalysisResult object that can be viewed as a table in a Jupyter notebook, for example: tube_results Output: For each complex in the ensemble, the partition function and complex free energy (units of kcal/mol) are displayed. For each tube, the equilibrium complex concentration of each complex in the tube is displayed (units of M). Optionally, additional quantities are calculated for each complex in the specified tubes (see Job Options ). For example, additionally calculate equilibrium base-pairing probabilities , the MFE proxy structure(s) , 100 Boltzmann-sampled structures , and the ensemble size for each complex in the tube: model1 = Model () tube_results2 = tube_analysis ( tubes = [ t1 , t2 ], model = model1 , compute = [ 'pairs' , 'mfe' , 'sample' , 'ensemble_size' ], options = { 'num_sample' : 100 }) # max_size=1 default To display a summary table of results in a Jupyter notebook: tube_results2 Output: Note that pairs and sample results are too large to be included in the summary table. See below for programmatic access to these results. Note If desired, the results of a tube_analysis job can alternatively be calculated in two steps: Step 1: run a complex_analysis job (to calculate the partition function for each complex); Step 2: run a complex_concentrations job (to calculate the equilibrium concentration for each complex in the context of a test tube given user-specified strand concentrations). Most of the computational cost is in Step 1. The user-specified strand concentrations are used only in Step 2. Hence, if you intend to analyze N test tubes containing the same strand species but N different sets of strand concentrations, it is cheaper to call complex_analysis once and complex_concentrations N times, rather than to call tube_analysis N times.","title":"Run a test tube analysis job"},{"location":"analysis/#specify-a-set-of-complexes","text":"A ComplexSet is specified as a set of strands (keyword strands ) that interact to form a set of complexes (keyword complexes : defaults to the strand set). The set of complexes is optionally specified using SetSpec() in any of three ways: Combinatorially using keyword max_size to automatically generate the set of all complexes up to a specified number of strands (default: max_size=1 ). Using keyword include to include an explicitly specified set of complexes (default: None ). Using keyword exclude to exclude an explicitly specified set of complexes (default: None ). For example: set1 = ComplexSet ( strands = [ A , B , C ]) # complexes defaults to [[A], [B], [C]] set2 = ComplexSet ( strands = [ A , B , C ], complexes = SetSpec ( max_size = 3 , include = [ c2 , [ B , B , B , B ]], exclude = [ c1 ])) Note Note that a ComplexSet and a Tube both specify a set of complexes \\Psi \\Psi that form from a set of strands \\Psi^0 \\Psi^0 . The difference is that Tube further specifies the concentration of each strand in \\Psi^0 \\Psi^0 in order to specify a test tube ensemble .","title":"Specify a set of complexes"},{"location":"analysis/#run-a-complex-analysis-job","text":"The complex_analysis command calculates one or more physical quantities (see Job Options ) for each complex in a ComplexSet : # specify strands a = Strand ( 'CUGAUCGAU' , name = 'a' ) b = Strand ( 'GAUCGUAGUC' , name = 'b' ) # specify complex set set1 = ComplexSet ( strands = [ a , b ], complexes = SetSpec ( max_size = 3 )) # calculate the partition function for each complex in the complex set model1 = Model () complex_results1 = complex_analysis ( complexes = set1 , model = model1 , compute = [ 'pfunc' ]) complex_analysis returns an AnalysisResult object that can be viewed as a table in a Jupyter notebook, for example: complex_results1 Output: If desired, a Tube can be specified in place of a ComplexSet , in which case the strand concentrations are ignored since complex_analysis does not calculate equilibrium complex concentrations, and hence does not require concentration information for the strand species. For example: # specify strands a = Strand ( 'CUGAUCGAU' , name = 'a' ) b = Strand ( 'GAUCGUAGUC' , name = 'b' ) # specify tube tube1 = Tube ( strands = { a : 1e-8 , b : 1e-10 }, complexes = SetSpec ( max_size = 3 ), name = 'tube1' ) # calculate the partition function for each complex in the tube model1 = Model () complex_results2 = complex_analysis ( complexes = tube1 , model = model1 , compute = [ 'pfunc' ])","title":"Run a complex analysis job"},{"location":"analysis/#run-a-complex-concentrations-job","text":"Use the complex_concentrations command to calculate the equilibrium concentration of each complex in a test tube ensemble (keyword tube ) using the AnalysisResult data (keyword data ) from a previous call to complex_analysis (which at minimum must contain the partition function for each complex). The tube ensemble can be specified either using Tube (which specifies strand concentrations) or as a ComplexSet , in which case the strand concentrations must additionally be specified (keyword concentrations ): # specify strand concentrations for ComplexSet set1 concentration_results1 = complex_concentrations ( tube = set1 , data = complex_results1 , concentrations = { a : 1e-8 , b : 1e-8 }) # use strand concentrations previously specified for tube1 concentration_results2 = complex_concentrations ( tube = tube1 , data = complex_results2 ) Note Note that complex_concentrations operates on a single tube ensemble at a time since each tube represents a separate coupled equilibrium problem and no savings can be achieved by considering multiple concentration solves at the same time. complex_concentrations returns an AnalysisResult object that can be viewed as a table in a Jupyter notebook, for example: concentration_results2 Output:","title":"Run a complex concentrations job"},{"location":"analysis/#job-options","text":"The compute keyword is optional for tube_analysis (default: 'pfunc' ) and required for complex_analysis (no default), specifying a list of strings denoting calculations to be performed for each complex [ Fornace20 ]: 'pfunc' : calculate the partition function . 'pairs' : calculate the matrix of equilibrium base-pairing probabilities . If 'pairs' is specified, tube_analysis or complex_concentrations will further calculate the matrix of test tube ensemble pair fractions . See the sparsity_fraction and sparsity_threshold options below. 'sample' : calculate a set of Boltzmann-sampled structures from the complex ensemble. See option num_sample below. 'mfe' : calculate the MFE proxy structure , the free energy of the MFE proxy secondary structure and the free energy of the MFE stacking state. If there is more than one MFE stacking state, the algorithm returns a list of the corresponding MFE proxy secondary structures, each with the free energy of the MFE proxy secondary structure and with the (same) free energy of the MFE stacking state. 'subopt' : calculate the set of suboptimal proxy structures with a stacking state within a specified free energy gap of the MFE stacking state. The algorithm returns a list of suboptimal proxy secondary strutures, each with the free energy of the MFE proxy secondary structure, and with the free energy of its lowest-energy stacking state that falls within the energy gap. See option subopt_gap below. 'ensemble_size' : calculate the complex ensemble size in terms of either the number of secondary structures (if using a physical model with nostacking ) or the number of stacking states (if using a physical model with stacking ). The optional options keyword specifies options that modify the calculations performed for each complex: 'sparsity_fraction': f can be used in conjuction with 'pairs' to return a sparse matrix containing the fraction f of the largest pair probabilities for each base (default 'sparsity': 1 returns the full pair probability matrix). 'sparsity_threshold': t can be used in conjuction with 'pairs' to return a sparse matrix containing the only pair probabilities greater than or equal to t (default 'sparsity_threshold': 0 returns the full pair probability matrix). 'num_sample': n can be used in conjunction with 'sample' to specify the number of structures to be sampled (default 'num_sample': 1 ). 'subopt_gap': g can be used in conjunction with 'subopt' to specify the (non-negative) free energy gap in kcal/mol (default 'subopt_gap': 0 ). By default, NUPACK analysis jobs run in parallel .","title":"Job options"},{"location":"analysis/#job-results","text":"Scalar results of NUPACK analysis jobs can be conveniently displayed as a table, printed as text, or introspected programmatically. Consider the following test tube analysis job: a = Strand ( 'CCG' , name = 'a' ) b = Strand ( 'CGG' , name = 'b' ) c = Complex ([ a , b ], name = 'c' ) t1 = Tube ({ a : 1e-6 , b : 1e-9 }, complexes = SetSpec ( max_size = 2 , include = [ c ]), name = 't1' ) t2 = Tube ({ a : 1e-8 , b : 1e-9 }, complexes = SetSpec ( include = [ c ]), name = 't2' ) my_model = Model () my_result = tube_analysis ([ t1 , t2 ], model = my_model , compute = [ 'pfunc' , 'pairs' , 'mfe' , 'sample' , 'subopt' ], options = { 'num_sample' : 2 , 'energy_gap' : 0.5 })","title":"Job results"},{"location":"analysis/#tabular-display","text":"You can display a summary table of results in a Jupyter notebook, for example: my_result Output:","title":"Tabular display"},{"location":"analysis/#textual-display","text":"You can view an ASCII representation of the same data by using the print function: print ( my_result ) Output: Complex results: Complex Pfunc dG (kcal/mol) MFE (kcal/mol) 0 (a) 1.0000e+0 0.000 0.000 1 (b) 1.0000e+0 0.000 0.000 2 c 1.3519e+3 -4.443 -4.081 3 (a+a) 1.8846e+1 -1.810 -1.972 4 (b+b) 1.7435e+2 -3.181 -3.523 Concentration results: Complex t1 (M) Complex t2 (M) (a) 1.000e-06 (a) 1.000e-08 (b) 1.000e-09 (b) 1.000e-09 (a+a) 3.418e-13 c 2.452e-16 c 2.452e-14 (b+b) 3.162e-18 For convenience, you can print the identical ASCII result to a text file using the save_text function: my_result . save_text ( 'my_result.txt' )","title":"Textual display"},{"location":"analysis/#programmatic-access","text":"More detailed results can also be displayed by programmatic access into an AnalysisResult object. This class contains two fields: .complexes : a Python dict mapping each Complex to a ComplexResult .tubes : a Python dict mapping each Tube to a TubeResult The information contained in these two fields depends on which type of analysis calculation was performed: For tube_analysis , the .tubes and .complexes fields are both non-empty. For complex_analysis , only the .complexes field is non-empty. For complex_concentrations , only the .tubes field is non-empty. For convenience, you can index into an AnalysisResult via a Complex or Tube identifier (or via the assigned or auto-generated name of a Complex or Tube ) as described in the following two sections.","title":"Programmatic access"},{"location":"analysis/#results-for-individual-complexes","text":"You can index into AnalysisResult object via a Complex identifier (or via the name of a Complex ) to get a ComplexResult object containing all the complex ensemble quantities that were calculated in a tube_analysis or complex_analysis calculation. A ComplexResult contains the following fields (if a quantity was not computed, the field is set to None ): pfunc : the complex partition function (held as a decimal.Decimal ; convert to a float via float(pf) or calculate the logarithm via float(pf.log()) ). free_energy : the complex free energy in kcal/mol (held as a float ). pairs : the matrix of equilibrium base-pairing probabilities (held as a PairsMatrix object containing a .to_array() method for conversion to numpy as illustrated below). sample : a list of Boltzmann-sampled structures , each an instance of a Structure object. mfe : a list of MFE proxy structures . Each entry contains fields .structure , .energy , and .stack_energy . .energy is the free energy of the MFE proxy secondary structure, while .stack_energy is the free energy of the MFE stacking state. subopt : a list of suboptimal proxy structures . Each entry contains fields .structure , .energy , and .stack_energy . .energy is the free energy of the MFE proxy secondary structure, while .stack_energy is the free energy of its lowest-energy stacking state that falls within the energy gap. ensemble_size : the complex ensemble size (held as int ) representing either the number of secondary structures (if using a physical model with nostacking ) or the number of stacking states (if using a physical model with stacking ). model : the Model that was used for the analysis calculation. For example, we can index the AnalysisResult object my_result with complex c (or by its name 'c' ) to obtain a ComplexResult object c_result that enables printing of specific physical quantities for that complex: c_result = my_result [ c ] # equivalent to my_result['c'] print ( 'Physical quantities for complex c' ) print ( 'Complex free energy: %.2f kcal/mol' % c_result . free_energy ) print ( 'Partition function: %.2e ' % c_result . pfunc ) print ( 'MFE proxy structure: %s ' % c_result . mfe [ 0 ] . structure ) print ( 'Free energy of MFE proxy structure: %.2f kcal/mol' % c_result . mfe [ 0 ] . energy ) print ( 'Equilibrium pair probabilities: \\n %s ' % c_result . pairs ) Output: Physical quantities for complex c Complex free energy: -4.44 kcal/mol Partition function: 1.35e+03 MFE proxy structure: (((+))) Free energy of MFE proxy structure: -4.08 kcal/mol Equilibrium pair probabilities: [[0.1000 0.0000 0.0000 0.0000 0.0061 0.8938] [0.0000 0.0083 0.0000 0.0000 0.9873 0.0044] [0.0000 0.0000 0.3839 0.6161 0.0000 0.0000] [0.0000 0.0000 0.6161 0.3839 0.0000 0.0000] [0.0061 0.9873 0.0000 0.0000 0.0066 0.0000] [0.8938 0.0044 0.0000 0.0000 0.0000 0.1018]] Note Note that a complex such as (a+a) that was auto-generated as part of the test tube ensemble (using max_size=2 ) does not have an identifier, but does have an auto-generated name that can be used to index an AnalysisResult : aa_result = my_result [ '(a+a)' ] If desired, the MFE proxy structure can be represented as a structure matrix of zeros and ones: c_result = my_result [ c ] print ( 'MFE proxy structure: \\n %s ' % c_result . mfe [ 0 ] . structure . matrix ()) Output: MFE proxy structure: [[0 0 0 0 0 1] [0 0 0 0 1 0] [0 0 0 1 0 0] [0 0 1 0 0 0] [0 1 0 0 0 0] [1 0 0 0 0 0]] The equilibrium pair probability matrix is returned as a PairsMatrix object, which can be converted to a numpy array via the to_array() method for display in a Jupyter notebook: import matplotlib.pyplot as plt plt . imshow ( my_result [ c ] . pairs . to_array ()) plt . xlabel ( 'Base index' ) plt . ylabel ( 'Base index' ) plt . title ( 'Pair probabilities for complex c' ) plt . colorbar () plt . clim ( 0 , 1 ) plt . savefig ( 'my-figure.pdf' ) # optionally, save a PDF of your figure Output: Note If your installation of matplotlib is not up-to-date, you may need to include %matplotlib inline at the top of the Jupyter notebook for the pairs plot to appear in your notebook instead of in a separate window. For some use cases, you may wish to convert a PairsMatrix to a scipy matrix via the to_sparse() method. It is straightforward to collect information across complexes in an AnalysisResult object. Since my_result.complexes is an ordinary python dict , iterating through its .items() enables collection of each complex result. For example, to operate on the equilibrium pair probability matrix for each complex in my_result : import numpy as np for my_complex , complex_result in my_result . complexes . items (): P = complex_result . pairs . to_array () s = 'Expected number of unpaired nucleotides at equilibrium in complex %s = %.2f ' print ( s % ( my_complex . name , np . diagonal ( P ) . sum ())) Output: Expected number of unpaired nucleotides at equilibrium in complex c = 0.98 Expected number of unpaired nucleotides at equilibrium in complex (b) = 3.00 Expected number of unpaired nucleotides at equilibrium in complex (a+a) = 2.70 Expected number of unpaired nucleotides at equilibrium in complex (b+b) = 2.25 Expected number of unpaired nucleotides at equilibrium in complex (a) = 3.00 To collect a dict of MFEs for each complex: my_mfes = { my_complex . name : complex_result . mfe [ 0 ] . energy for my_complex , complex_result in my_result . complexes . items ()} print ( my_mfes ) Output: {'c': -4.081351280212402, '(b)': 0.0, '(a+a)': -1.9719057083129883, '(b+b)': -3.5225014686584473, '(a)': 0.0} To print out the complex concentrations for a given tube: for my_complex , conc in my_result . tubes [ t1 ] . complex_concentrations . items (): print ( 'The equilibrium concentration of %s is %.2e M' % ( my_complex . name , conc )) Output: The equilibrium concentration of c is 2.45e-14 M The equilibrium concentration of (b) is 1.00e-09 M The equilibrium concentration of (a+a) is 3.42e-13 M The equilibrium concentration of (b+b) is 3.16e-18 M The equilibrium concentration of (a) is 1.00e-06 M","title":"Results for individual complexes"},{"location":"analysis/#results-for-individual-test-tubes","text":"You can index into an AnalysisResult object via a Tube identifier (or via the name of a Tube ) to get a TubeResult object containing all the tube ensemble quantities that were calculated in a tube_analysis or complex_concentrations calculation. This class contains the following fields: complex_concentrations : a dict from Complex to its equilibrium concentration in molar (held as a float ). fraction_bases_unpaired : a float in [0,1] [0,1] denoting the equilibrium fraction of nucleotides that are unpaired in the test tube ensemble. ensemble_pair_fractions : a square matrix of test tube ensemble pair fractions . Row and column indices refer to the concatenated base index formed by concatenating the strands of the input Tube (in order). This field is None if pair probabilities were not calculated (i.e., if option pairs was not specified for the tube_analysis or complex_analysis job). Concentrations may be printed as follows: t1_result = my_result [ t1 ] # equivalent to my_result['t1'] for my_complex , conc in t1_result . complex_concentrations . items (): print ( 'The equilibrium concentration of %s is %.3e M' % ( my_complex . name , conc )) Output: The equilibrium concentration of c is 2.452e-14 M The equilibrium concentration of (b) is 1.000e-09 M The equilibrium concentration of (a+a) is 3.418e-13 M The equilibrium concentration of (b+b) is 3.162e-18 M The equilibrium concentration of (a) is 1.000e-06 M Test tube ensemble pair fractions may be printed as follows: print ( t1_result . ensemble_pair_fractions ) Output: [[1.0000 0.0000 0.0000 0.0000 0.0000 0.0000] [0.0000 1.0000 0.0000 0.0000 0.0000 0.0000] [0.0000 0.0000 1.0000 0.0000 0.0000 0.0000] [0.0000 0.0000 0.0000 1.0000 0.0000 0.0000] [0.0000 0.0000 0.0000 0.0000 1.0000 0.0000] [0.0000 0.0000 0.0000 0.0000 0.0000 1.0000]]","title":"Results for individual test tubes"},{"location":"analysis/#saving-a-job-summary","text":"To save a textual job summary using the save_text method: my_result . save_text ( 'my-result.txt' )","title":"Saving a job summary"},{"location":"analysis/#saving-and-reloading-job-results","text":"Save an AnalysisResult as a binary file using the save method: my_result . save ( 'my-result.o' ) to enable reloading during a future session using the load method: my_result = AnalysisResult . load ( 'my-result.o' ) This functionality uses Python\u2019s built-in pickle module. Dirks07 Dirks R.M., Bois J.S., Schaeffer J.M., Winfree E., Pierce N.A.: Thermodynamic Analysis of Interacting Nucleic Acid Strands . SIAM Rev.. 49 , (2007) Fornace20 Fornace M.E., Porubsky N.J., Pierce N.A.: A Unified Dynamic Programming Framework for the Analysis of Interacting Nucleic Acid Strands: Enhanced Models, Scalability, and Speed . ACS Synth. Biol.. (2020)","title":"Saving and reloading job results"},{"location":"definitions/","text":"Definitions \u00b6 Sequence \u00b6 The sequence , \\phi \\phi , of one or more interacting RNA strands is specified as a list of bases \\phi^a\\in\\{\\texttt{A},\\texttt{C},\\texttt{G},\\texttt{U}\\} \\phi^a\\in\\{\\texttt{A},\\texttt{C},\\texttt{G},\\texttt{U}\\} for a=1,\\dots,|\\phi| a=1,\\dots,|\\phi| . For DNA, \\phi^a\\in\\{\\texttt{A},\\texttt{C},\\texttt{G},\\texttt{T}\\} \\phi^a\\in\\{\\texttt{A},\\texttt{C},\\texttt{G},\\texttt{T}\\} . Nucleic acid sequences are listed 5' 5' to 3' 3' . Unlike NUPACK 3, bases in NUPACK 4 are indexed starting with 0 at the 5' 5' -most base of the first strand and ending at the 3' 3' -most base of the last strand. For example, if a complex has three strands of length 15, 20, and 13, respectively, the fifth base of the third strand has index 39. Valid bases are A , C , G , T , and U . For RNA calculations, T is automatically converted to U , and vice versa for DNA calculations. Degenerate nucleotide codes \u00b6 Sequence constraints can be specified using IUPAC degenerate nucleotide codes , which for RNA are as follows: Code Nucleotides M A or C R A or G W A or U S C or G Y C or U K G or U V A, C, or G H A, C, or U D A, G, or U B C, G, or U N A, C, G, or U For DNA, T replaces U. Sequence distance \u00b6 The sequence distance between two sequences \\phi_1 \\phi_1 and \\phi_2 \\phi_2 of equal length ( |\\phi_1|=|\\phi_2|=N |\\phi_1|=|\\phi_2|=N ) is the number of (possibly degenerate) nucleotide codes that are non-intersecting in the two sequences: \\begin{align} d_\\textrm{seq}(\\phi_1,\\phi_2) = \\sum_{1\\le a \\le N} \\left\\{\\begin{array}[ll] 0 0: &\\phi_1^a \\cap \\phi_2^a \\neq \\emptyset\\\\ 1: &\\phi_1^a \\cap \\phi_2^a = \\emptyset\\end{array} \\right. \\end{align} \\begin{align} d_\\textrm{seq}(\\phi_1,\\phi_2) = \\sum_{1\\le a \\le N} \\left\\{\\begin{array}[ll] 0 0: &\\phi_1^a \\cap \\phi_2^a \\neq \\emptyset\\\\ 1: &\\phi_1^a \\cap \\phi_2^a = \\emptyset\\end{array} \\right. \\end{align} For example, d_\\textrm{seq} d_\\textrm{seq} (ACGU, SSWW) = 2. If \\phi_1 \\phi_1 and \\phi_2 \\phi_2 contain no degenerate nucleotide codes, this definition simplifies to the number of nucleotides that are different in the two sequences: \\begin{align} d_\\textrm{seq}(\\phi_1,\\phi_2) = \\sum_{1\\le a \\le N} \\left\\{\\begin{array}[ll] 0 0: &\\phi_1^a = \\phi_2^a\\\\ 1: &\\phi_1^a \\neq \\phi_2^a \\end{array} \\right. \\end{align} \\begin{align} d_\\textrm{seq}(\\phi_1,\\phi_2) = \\sum_{1\\le a \\le N} \\left\\{\\begin{array}[ll] 0 0: &\\phi_1^a = \\phi_2^a\\\\ 1: &\\phi_1^a \\neq \\phi_2^a \\end{array} \\right. \\end{align} For example, d_\\textrm{seq} d_\\textrm{seq} (ACGU, ACUU) = 1. Secondary structure \u00b6 A secondary structure , s s , of one or more interacting RNA strands is defined by a set of base pairs, each a Watson\u2013Crick pair [A \\cdot \\cdot U or C \\cdot \\cdot G] or a wobble pair [G \\cdot \\cdot U]). For DNA, the corresponding Watson\u2013Crick pairs are A \\cdot \\cdot T or C \\cdot \\cdot G and there are no wobble pairs. A polymer graph representation of a secondary structure is constructed by ordering the strands around a circle, drawing the backbones in succession from 5 ' ' to 3 ' ' around the circumference with a nick between each strand, and drawing straight lines connecting paired bases. A secondary structure is unpseudoknotted if there exists a strand ordering for which the polymer graph has no crossing lines, or pseudoknotted if all strand orderings contain crossing lines. In NUPACK 4, pseudoknots are excluded from the structural ensemble. A secondary structure is connected if no subset of the strands is free of the others. Secondary structures may be specified one of three ways for NUPACK calculations as described in the following three sections. Dot-parens-plus notation \u00b6 Each unpaired base is represented by a dot, each base pair by matching parentheses, and each nick between strands by a plus [ Zadeh11a ]. For example, ((...)) specifies that bases 0 and 1 are paired to bases 6 and 5, respectively, while bases 2, 3, and 4 are unpaired. ((+...)) specifies that bases 0 and 1 of strand 0 are paired to bases 4 and 3 of strand 1. Run-length encoded dot-parens-plus notation \u00b6 As a shorthand for dot-parens-plus, any sequence of consecutive characters in dot-parens-plus may be replaced by the character followed by a number. For instance, (((((+...........))))) may be written as (5+.11)5 . DU+ notation \u00b6 Using DU+ notation, a duplex is represented by D and an unpaired region of length nucleotides is represented by U [ Zadeh10c ]. Each duplex is followed immediately by the substructure (specified in DU+ notation) that is \u2018enclosed\u2019 by the duplex. If this substructure includes more than one element, parentheses are used to denote scope. A nick between strands is specified by a \u2018+\u2019. See the table below for examples. Example Dot-parens-plus RLE dot-parens-plus DU+ notation ((((((((((((..........)))))))))))) (12.10)12 D12 U10 ((((((((((((+)))))))))))).......... (12+)12.10 D12 + U10 ((((((((((((+..........)))))))))))) (12+.10)12 D12 (+ U10) Table : Examples of dot-parens-plus, run-length-encoded (RLE) dot-parens-plus, and DU+ notation. Example Figure : Comparison of dot-parens-plus, run-length-encoded dot-parens-plus, and DU+ notation. Structure matrix \u00b6 In mathematical expressions, it is convenient to represent secondary structure s s using a structure matrix S(s) S(s) with entries S^{a,b}(s) = 1 S^{a,b}(s) = 1 if structure s s contains base pair a\\cdot b a\\cdot b and S^{a,b}(s) = 0 S^{a,b}(s) = 0 otherwise. Abusing notation, the entry S^{a,a}(s) = 1 S^{a,a}(s) = 1 if base a a is unpaired in structure s s and 0 0 otherwise. Hence, S(s) S(s) is a symmetric matrix with row and column sums of 1. Structure distance \u00b6 The structure distance between two secondary structures s_1 s_1 and s_2 s_2 of equal size ( |s_1|=|s_2|=N |s_1|=|s_2|=N ) is the number of nucleotides in a different base-pairing state in the two structures: \\begin{align} d_\\textrm{struc}(s_1,s_2)=N-\\sum_{1\\le a\\le N,~1\\le b \\le N} S_{a,b}(s_1)S_{a,b}(s_2) \\end{align} Complex ensemble \u00b6 Consider a complex of L L distinct strands (e.g., each with a unique identifier in \\{1,\\dots,L\\} \\{1,\\dots,L\\} ) corresponding to strand ordering \\pi \\pi . The complex ensemble \\overline\\Gamma(\\phi) \\overline\\Gamma(\\phi) contains all connected polymer graphs with no crossing lines for sequence \\phi \\phi and strand ordering \\pi \\pi (i.e., all unpseudoknotted secondary structures) [ Dirks07 ]. (We dispense with our prior convention [ Dirks07 , Zadeh11a , Zadeh11b ] of calling this entity an \u2018\u2019ordered complex\u2019\u2018.) As a matter of algorithmic necessity, all of the dynamic programs in NUPACK operate on complex ensemble \\overline\\Gamma(\\phi) \\overline\\Gamma(\\phi) treating all strands as distinct. However, in the laboratory, strands with the same sequence are typically indistinguishable with respect to experimental observables. For comparison to experimental data, physical quantities calculated over ensemble \\overline\\Gamma(\\phi) \\overline\\Gamma(\\phi) are post-processed to obtain the corresponding quantities calculated over complex ensemble \\Gamma(\\phi) \\Gamma(\\phi) in which strands with the same sequence are treated as indistinguishable [ Fornace20 ]. The ensemble \\Gamma(\\phi)\\subseteq\\overline\\Gamma(\\phi) \\Gamma(\\phi)\\subseteq\\overline\\Gamma(\\phi) is a maximal subset of distinct secondary structures for strand ordering \\pi \\pi . Two secondary structures are indistinguishable if their polymer graphs can be rotated so that all strands are mapped onto indistinguishable strands, all base pairs are mapped onto base pairs, and all unpaired bases are mapped onto unpaired bases; otherwise the structures are distinct [ Dirks07 ]. Figure: A complex of 3 strands with strand ordering \\pi \\pi = ABC. Test tube ensemble \u00b6 A test tube ensemble is a dilute solution containing a set of strand species, \\Psi^0 \\Psi^0 , introduced at user-specified concentrations, that interact to form a set of complex species, \\Psi \\Psi , each corresponding to a different strand ordering treating strands with the same sequence as indistinguishable [ Dirks07 , Fornace20 ]. For L L strands, there are (L-1)! (L-1)! strand orderings if all strands are different species (e.g., complexes \\pi \\pi = ABC and \\pi \\pi = ACB for L=3 L=3 and strands A, B, C), but fewer than (L-1)! (L-1)! strand orderings if some strands are of the same species (e.g., complex \\pi \\pi = AAA for L=3 L=3 with three A strands). By the Representation Theorem [ Dirks07 ], a secondary structure in the complex ensemble for one strand ordering does not appear in the complex ensemble for any other strand ordering, averting redundancy. It is often convenient to define \\Psi \\Psi to contain all complex species of up to L_\\mathrm{max} L_\\mathrm{max} strands, although \\Psi \\Psi can be defined to contain arbitrary complex species formed from the strand species in \\Psi^0 \\Psi^0 . Figure: A test tube ensemble containing strain species \\Psi^0 = \\{ \\Psi^0 = \\{ A,B,C \\} \\} interacting to form all complex species \\Psi \\Psi of up to L_{\\rm max} = 3 L_{\\rm max} = 3 strands. Free energy model \u00b6 For each (unpseudoknotted connected) secondary structure s\\in\\overline{\\Gamma}(\\phi) s\\in\\overline{\\Gamma}(\\phi) , the free energy, \\overline{\\Delta G}(\\phi,s) \\overline{\\Delta G}(\\phi,s) , is estimated as the sum of the empirically determined free energies of the constituent loops [ Santalucia98 , Xia98 , Mathews99 , Zuker03 , Lu06 , Turner10 ] plus a strand association penalty [ Bloomfield00 ], \\Delta G^\\textrm{assoc} \\Delta G^\\textrm{assoc} , applied L-1 L-1 times for a complex of L L strands: \\begin{align} \\overline{\\Delta G}(\\phi,s) = (L-1)\\,\\Delta G^\\textrm{assoc}\\, + \\sum_{\\mathrm{loop} \\in s} \\Delta G(\\mathrm{loop}). \\label{eq:dGbar} \\end{align} Loop free energies \u00b6 The loop free energy, \\Delta G(\\mathrm{loop}) \\Delta G(\\mathrm{loop}) , is modeled for the different loop types as follows: A hairpin loop is closed by a single base-pair a\\cdot b a\\cdot b . The loop free energy, \\Delta G^\\mathrm{hairpin}_{a,b} \\Delta G^\\mathrm{hairpin}_{a,b} , depends on sequence and loop size. An interior loop is closed by two base pairs ( a\\cdot b a\\cdot b and d\\cdot e d\\cdot e with a<d<e<b a<d<e<b ). The loop free energy, \\Delta G^\\mathrm{interior}_{a,d,e,b} \\Delta G^\\mathrm{interior}_{a,d,e,b} depends on sequence, loop size, and loop asymmetry. Bulge loops (where either d=a+1 d=a+1 or e=b-1 e=b-1 ) and stacked pairs (where both d=a+1 d=a+1 and e=b-1 e=b-1 ) are treated as special cases of interior loops. A multiloop is closed by three or more base pairs. The loop free energy is modeled as the sum of three sequence-independent penalties: \\Delta G^\\mathrm{multi}_\\mathrm{init} \\Delta G^\\mathrm{multi}_\\mathrm{init} for formation of a multiloop, \\Delta G^\\mathrm{multi}_\\mathrm{bp} \\Delta G^\\mathrm{multi}_\\mathrm{bp} for each closing base pair, \\Delta G^\\mathrm{multi}_\\mathrm{nt} \\Delta G^\\mathrm{multi}_\\mathrm{nt} for each unpaired nucleotide inside the multiloop, plus a sequence-dependent penalty: \\Delta G^\\mathrm{terminalbp}_{a, b} \\Delta G^\\mathrm{terminalbp}_{a, b} for each closing pair a\\cdot b a\\cdot b . An exterior loop contains a nick between strands and any number of closing base pairs. The exterior loop free energy is the sum of \\Delta G^\\mathrm{terminalbp}_{a, b} \\Delta G^\\mathrm{terminalbp}_{a, b} over all closing base pairs a\\cdot b a\\cdot b . Hence, an unpaired strand has a free energy of zero, corresponding to the reference state [ Dirks07 ]. Figure: Canonical loop types for a complex with strand ordering \\pi \\pi = ABC. Coaxial and dangle stacking \u00b6 Within a multiloop or an exterior loop, there is a subensemble of coaxial stacking states between adjacent closing base pairs and dangle stacking states between closing base pairs and adjacent unpaired bases. Within a multiloop or exterior loop, a base pair can form one coaxial stack with an adjacent base pair, or can form a dangle stack with at most two adjacent unpaired bases; unpaired bases can either form no stack, or can form a dangle stack with at most one adjacent base pair. Figure: Coaxial and dangle stacking states for a multiloop. Figure: Coaxial and dangle stacking states for two exterior loops. For a given multiloop or exterior loop, the energetic contributions of all possible coaxial and dangle stacking states are enumerated so as to calculate the free energy: \\begin{align} \\Delta G^\\mathrm{stacking} = - k T \\log \\sum_{\\omega\\in\\mathrm{loop}} \\prod_\\mathrm{x\\in\\omega} e^{-\\Delta G_x/k T}\\label{eq:stack} \\end{align} where \\omega \\omega indexes the possible stacking states within the loop and x x indexes the individual stacks (coaxial or dangle) within a stacking state. The free energy of a multiloop or exterior loop is augmented by the corresponding \\Delta G^\\mathrm{stacking} \\Delta G^\\mathrm{stacking} bonus. Hence, a secondary structure s s continues to be defined as a set of base pairs, and the stacking states within a given multiloop or exterior loop are treated as a structural subensemble that contributes in a Boltzmann-weighted fashion to the free energy model for the loop. Let s^\\shortparallel\\in s s^\\shortparallel\\in s denote a stacking state of the paired and unpaired bases in s s . We may equivalently define the free energy of secondary structure s s in terms of the stacking state free energies \\begin{align} \\overline{\\Delta G}(\\phi,s^\\shortparallel) \\end{align} for all stacking states s^\\shortparallel\\in s s^\\shortparallel\\in s : \\begin{align} \\overline{\\Delta G}(\\phi,s) = -kT \\log \\sum_{s^\\shortparallel\\in s}e^{-\\overline{\\Delta G}(\\phi,s^\\shortparallel)/kT} \\label{eq:stacksum} \\end{align} Let \\overline\\Gamma^\\shortparallel(\\phi) \\overline\\Gamma^\\shortparallel(\\phi) denote the ensemble of stacking states corresponding to the complex ensemble of secondary structures \\overline\\Gamma(\\phi) \\overline\\Gamma(\\phi) . Symmetry correction \u00b6 For a secondary structure s\\in\\Gamma(\\phi) s\\in\\Gamma(\\phi) with an R R -fold rotational symmetry there is in R R -fold reduction in distinguishable conformational space, so the free energy \\overline{\\Delta G}(\\phi,s) \\overline{\\Delta G}(\\phi,s) must be adjusted [ Dirks07 ] by a symmetry correction: \\begin{align} \\Delta G(\\phi,s) &= \\overline{\\Delta G}(\\phi,s) + \\Delta G^\\mathrm{sym}(\\phi,s). \\label{eq:dGcorrected} \\end{align} where \\begin{align} \\Delta G^\\mathrm{sym}(\\phi,s) = kT\\log R(\\phi,s). \\label{eq:dGsym} \\end{align} Because the symmetry factor R(\\phi,s) R(\\phi,s) is a global property of each secondary structure s\\in\\Gamma(\\phi) s\\in\\Gamma(\\phi) , it is not suitable for use with dynamic programs that treat multiple subproblems simultaneously without access to global structural information. As a result, dynamic programs operate on ensemble \\overline\\Gamma(\\phi) \\overline\\Gamma(\\phi) using physical model \\overline{\\Delta G}(\\phi,s) \\overline{\\Delta G}(\\phi,s) and then the Distinguishability Correction Theorem [ Dirks07 ] enables exact conversion of physical quantities to ensemble \\Gamma(\\phi) \\Gamma(\\phi) using physical model \\Delta G(\\phi,s) \\Delta G(\\phi,s) . Interestingly, ensembles \\overline\\Gamma(\\phi) \\overline\\Gamma(\\phi) and \\Gamma(\\phi) \\Gamma(\\phi) both have utility when examining the physical properties of a complex as they provide related but different perspectives, akin to complementary thought experiments [ Fornace20 ]. Physical quantities \u00b6 Consider a test tube ensemble containing an arbitrary set of strand species \\Psi^0 \\Psi^0 interacting to form an arbitrary set of complex species \\Psi \\Psi . Let j\\in\\Psi j\\in\\Psi denote a complex with sequence \\phi_j \\phi_j and complex ensembles \\overline\\Gamma(\\phi_j) \\overline\\Gamma(\\phi_j) (treating all strands as distinct) and \\Gamma(\\phi_j) \\Gamma(\\phi_j) (treating strands with the same seqeuence as indistinguishable). NUPACK calculates [ Dirks07 , Fornace20 ] a number of physical quantities over these ensembles. Partition function \u00b6 For complex j j , the partition function evaluated over ensemble \\Gamma(\\phi_j) \\Gamma(\\phi_j) treating strands with the same sequence as indistinguishable is denoted \\begin{align} Q(\\phi_j) = \\sum_{s\\in\\Gamma(\\phi_j)}e^{-\\Delta G(\\phi_j,s)/kT}. \\end{align} \\begin{align} Q(\\phi_j) = \\sum_{s\\in\\Gamma(\\phi_j)}e^{-\\Delta G(\\phi_j,s)/kT}. \\end{align} Complex free energy \u00b6 For complex j j , the corresponding complex free energy is \\begin{align} \\Delta G(\\phi_j) \\equiv -kT \\log(Q(\\phi_j)). \\end{align} Structure free energy \u00b6 For complex j j , the secondary structure free energy treating strands with the same sequence as indistinguishable is denoted \\begin{align} \\Delta G(\\phi_j,s). \\end{align} If the physical model includes coaxial and dangle stacking , the structure free energy will include stacking contributions \\Delta G^\\textrm{stacking} \\Delta G^\\textrm{stacking} . If the secondary structure s s has a rotational symmetry, the structure free energy will include the symmetry correction \\Delta G^\\textrm{sym}(\\phi_j,s) \\Delta G^\\textrm{sym}(\\phi_j,s) . Equilibrium structure probability \u00b6 For complex j j , the equilibrium structure probability of any secondary structure s\\in\\Gamma(\\phi_j) s\\in\\Gamma(\\phi_j) treating strands with the same sequence as indistinguishable is denoted \\begin{align} p(\\phi_j,s)= e^{-\\Delta G(\\phi_j,s)/kT}/Q(\\phi_j). \\end{align} Boltzmann-sampled structures \u00b6 For complex j j , a set of J J secondary structures Boltzmann-sampled from ensemble \\Gamma(\\phi_j) \\Gamma(\\phi_j) treating strands with the same sequence as indistinguishable is denoted \\begin{align} \\Gamma_\\mathrm{sample}(\\phi,J) \\in \\Gamma(\\phi) \\end{align} \\begin{align} \\Gamma_\\mathrm{sample}(\\phi,J) \\in \\Gamma(\\phi) \\end{align} Equilibrium base-pairing probabilities \u00b6 For complex j j , the base-pairing probability matrix \\overline P(\\phi_j) \\overline P(\\phi_j) has entries \\overline P^{a,b}(\\phi_j)\\in[0,1] \\overline P^{a,b}(\\phi_j)\\in[0,1] corresponding to the probability \\begin{align} \\overline P^{a,b}(\\phi_j) = \\sum_{s\\in\\overline\\Gamma(\\phi_j)}\\overline p(\\phi,s)S^{a,b}(s) \\end{align} \\begin{align} \\overline P^{a,b}(\\phi_j) = \\sum_{s\\in\\overline\\Gamma(\\phi_j)}\\overline p(\\phi,s)S^{a,b}(s) \\end{align} that base pair a\\cdot b a\\cdot b forms at equilibrium within ensemble \\overline\\Gamma(\\phi_j) \\overline\\Gamma(\\phi_j) , treating all strands as distinct. Here, S(s) S(s) is the structure matrix and \\overline p(s) \\overline p(s) the equilibrium probability of structure s\\in\\overline\\Gamma(\\phi_j) s\\in\\overline\\Gamma(\\phi_j) , treating all strands as distinct. Abusing notation, the entry \\overline P^{i,i}(\\phi) \\in [0,1] \\overline P^{i,i}(\\phi) \\in [0,1] denotes the equilibrium probability that base i i is unpaired over ensemble \\overline\\Gamma(\\phi) \\overline\\Gamma(\\phi) . Hence \\overline P(\\phi) \\overline P(\\phi) is symmetric matrix with row and column sums of 1. MFE proxy structure \u00b6 For complex j j , the free energy of the minimum free energy (MFE) stacking state s_\\mathrm{MFE}^\\shortparallel(\\phi) \\in\\overline\\Gamma^\\shortparallel(\\phi) s_\\mathrm{MFE}^\\shortparallel(\\phi) \\in\\overline\\Gamma^\\shortparallel(\\phi) treating all strands as distinct is denoted \\begin{align} \\overline{\\Delta G}(\\phi_j,s^\\shortparallel_{\\rm MFE}) \\equiv \\min_{s^\\shortparallel\\in\\overline\\Gamma^\\shortparallel(\\phi_j)} \\overline{\\Delta G}(\\phi_j,s^\\shortparallel). \\end{align} \\begin{align} \\overline{\\Delta G}(\\phi_j,s^\\shortparallel_{\\rm MFE}) \\equiv \\min_{s^\\shortparallel\\in\\overline\\Gamma^\\shortparallel(\\phi_j)} \\overline{\\Delta G}(\\phi_j,s^\\shortparallel). \\end{align} The corresponding MFE proxy structure is \\begin{align} s_\\mathrm{MFE'} \\equiv \\{s\\in\\overline\\Gamma(\\phi_j) | s^\\shortparallel_\\mathrm{MFE}\\!\\in\\! s, s^\\shortparallel_\\mathrm{MFE}(\\phi_j) = \\arg \\min_{s^\\shortparallel\\in\\overline\\Gamma^\\shortparallel(\\phi_j)} \\overline{\\Delta G}(\\phi_j,s^\\shortparallel)\\}, \\end{align} \\begin{align} s_\\mathrm{MFE'} \\equiv \\{s\\in\\overline\\Gamma(\\phi_j) | s^\\shortparallel_\\mathrm{MFE}\\!\\in\\! s, s^\\shortparallel_\\mathrm{MFE}(\\phi_j) = \\arg \\min_{s^\\shortparallel\\in\\overline\\Gamma^\\shortparallel(\\phi_j)} \\overline{\\Delta G}(\\phi_j,s^\\shortparallel)\\}, \\end{align} defined as the secondary structure containing the MFE stacking state within its subensemble. The free energy of the MFE proxy structure is \\begin{align} \\overline{\\Delta G}(\\phi,s_\\mathrm{MFE\u2019}). \\end{align} There may be more than one MFE stacking state, each corresponding to the same or different MFE proxy structures. Suboptimal proxy structures \u00b6 For complex j j , the set of suboptimal proxy secondary structures with stacking states within a specified \\Delta G_\\mathrm{gap}\\ge 0 \\Delta G_\\mathrm{gap}\\ge 0 of the MFE stacking state is denoted \\begin{align} \\overline\\Gamma_{\\rm subopt}(\\phi_j,\\Delta G_{\\rm gap}) = \\{s\\in\\overline\\Gamma(\\phi_j) | s^\\shortparallel\\!\\in\\! s, \\overline{\\Delta G}(\\phi_j,s^\\shortparallel) \\le \\overline{\\Delta G}(\\phi_j,s^\\shortparallel_{\\rm MFE}) + \\Delta G_{\\rm gap}\\}. \\end{align} \\begin{align} \\overline\\Gamma_{\\rm subopt}(\\phi_j,\\Delta G_{\\rm gap}) = \\{s\\in\\overline\\Gamma(\\phi_j) | s^\\shortparallel\\!\\in\\! s, \\overline{\\Delta G}(\\phi_j,s^\\shortparallel) \\le \\overline{\\Delta G}(\\phi_j,s^\\shortparallel_{\\rm MFE}) + \\Delta G_{\\rm gap}\\}. \\end{align} Complex ensemble defect \u00b6 For complex j j with target structure s_j s_j , the dimensional complex ensemble defect \\begin{align} n(\\phi_j,s_j) & = |\\phi_j| - \\sum_{\\begin{array}{c} 1 \\leq a \\leq |\\phi_j|,\\ 1 \\leq b \\leq |\\phi_j| \\end{array}} \\overline P^{a, b}(\\phi_j) S^{a,b}(s_j), \\end{align} quantifies the equilibrium number of incorrectly paired nucleotides over the ensemble \\overline\\Gamma(\\phi_j) \\overline\\Gamma(\\phi_j) relative to s_j s_j [ Dirks04 , Zadeh11b ]. Here, \\overline P(\\phi_j) \\overline P(\\phi_j) is the equilibrium base-pairing probability matrix and S(s_j) S(s_j) is the target structure matrix for s_j s_j . The normalized complex ensemble defect is then denoted \\begin{align} {\\mathcal N}_j \\equiv n(\\phi_j,s_j)/|\\phi_j| ~~~\\in (0,1) \\end{align} \\begin{align} {\\mathcal N}_j \\equiv n(\\phi_j,s_j)/|\\phi_j| ~~~\\in (0,1) \\end{align} representing the equilibrium fraction of incorrectly paired nucleotides evaluated over the ensemble of complex j j relative to target structure s_j s_j . For a set of complexes \\Psi \\Psi , the normalized complex ensemble defect can be generalized to a multi-complex ensemble defect \\begin{align} {{\\mathcal N}} ~\\equiv ~\\frac{1}{|\\Psi|}\\sum_{j\\in\\Psi} {\\mathcal N_j} ~~~\\in(0,1) \\end{align} quantifying the average equilibrium fraction of incorrectly paired nucleotides over the complexes j\\in\\Psi j\\in\\Psi . As {\\mathcal N}_j {\\mathcal N}_j approaches zero, the complex j j is dominated by its target structure, s_{j} s_{j} . Complex ensemble size \u00b6 For complex j j , the number of secondary structures in the complex ensemble, treating all strands as distinct, is denoted: \\begin{align} |\\overline\\Gamma(\\phi_j)|. \\end{align} The corresponding number of stacking states is denoted \\begin{align} |\\overline\\Gamma^\\shortparallel(\\phi_j)|. \\end{align} Equilibrium complex concentrations \u00b6 For the set of complexes \\Psi \\Psi in the test tube ensemble, the set of equilibrium complex concentrations is denoted \\begin{align} x_\\Psi \\equiv x_j~~~~~~ \\forall j\\in\\Psi, \\end{align} These concentrations are the unique solution to the strictly convex optimization problem [ Dirks07 ]: \\begin{align} & \\min_{x_{\\Psi}} \\sum_{j\\in\\Psi} x_j(\\log x_j - \\log Q_j - 1) \\\\[6pt] & \\mathrm{subject~to~~~~} \\sum_{j \\in \\Psi}A_{i,c} \\,x_j = x_i^0 ~~~~~~ \\forall i\\in\\Psi^0, \\end{align} \\begin{align} & \\min_{x_{\\Psi}} \\sum_{j\\in\\Psi} x_j(\\log x_j - \\log Q_j - 1) \\\\[6pt] & \\mathrm{subject~to~~~~} \\sum_{j \\in \\Psi}A_{i,c} \\,x_j = x_i^0 ~~~~~~ \\forall i\\in\\Psi^0, \\end{align} expressed in terms of the previously calculated set of partition functions Q_\\Psi Q_\\Psi . Here, the constraints impose conservation of mass: A A is the stoichiometry matrix such that A_{i,j} A_{i,j} is the number of strands of type i i in complex j j , and x^0_i x^0_i is the total concentration of strand i i present in the test tube. Based on dimensional analysis [ Dirks07 ], the convex optimization problem is formulated in terms of mole fractions, but for convenience, NUPACK accepts molar strand concentrations [i]^0 = x_i^0 \\rho_\\mathrm{H_2O} [i]^0 = x_i^0 \\rho_\\mathrm{H_2O} as inputs and returns molar complex concentrations [j] = x_j\\rho_\\mathrm{H_2O} [j] = x_j\\rho_\\mathrm{H_2O} as outputs, where \\rho_\\mathrm{H_2O} \\rho_\\mathrm{H_2O} is the molarity of water. Hence, the user specifies the set of molar strand concentrations [i]^0~~\\forall i\\in\\Psi^0 [i]^0~~\\forall i\\in\\Psi^0 and NUPACK calculates the set of molar complex concentrations [j]~~ \\forall j\\in\\Psi [j]~~ \\forall j\\in\\Psi . Test tube fraction of bases unpaired \u00b6 The equilibrium fraction of bases that are unpaired in the test tube, taking into account the equilibrium concentration and pair probatility matrix for each complex in the test tube ensemble. Test tube ensemble pair fractions \u00b6 For the test tube ensemble, the ensemble pair fraction \\begin{align} f_A(a_A\\cdot b_B) \\end{align} \\begin{align} f_A(a_A\\cdot b_B) \\end{align} denotes the fraction of A strands that form base pair a_A\\cdot b_B a_A\\cdot b_B . Correspondingly, \\begin{align} f_B(a_A\\cdot b_B) \\end{align} \\begin{align} f_B(a_A\\cdot b_B) \\end{align} denotes the fraction of B strands that form base pair a_A\\cdot b_B a_A\\cdot b_B . These base-pairing observables depend on the set of equilibrium concentrations x_\\Psi x_\\Psi and the set of base-pairing probability matrices \\overline P_\\Psi \\overline P_\\Psi . The number of distinct bases in the test tube is: \\begin{align} N_{\\rm distinct}\\equiv \\sum_{i=1}^{|\\Psi^0|} N_i \\end{align} \\begin{align} N_{\\rm distinct}\\equiv \\sum_{i=1}^{|\\Psi^0|} N_i \\end{align} representing the total number of bases in all |\\Psi^0| |\\Psi^0| strand species. Numbering the distinct bases from 1 to N_{\\rm distinct} N_{\\rm distinct} , the ensemble pair fractions, f_A(a_A\\cdot b_B) f_A(a_A\\cdot b_B) , are then stored as an (asymmetric) N_{\\rm distinct}\\times N_{\\rm distinct} N_{\\rm distinct}\\times N_{\\rm distinct} matrix. Abusing notation, the entry f_A^{a_A,a_A} \\in [0,1] f_A^{a_A,a_A} \\in [0,1] denotes the equilibrium fraction of base a a on strand A A that is unpaired in the test tube ensemble. Hence, the matrix of test tube ensemble pair fractions is asymmetric with row and column sums of 1. Test tube ensemble defect \u00b6 Consider test tube h h containing a set of desired on-target complexes , \\Psi_h^{\\rm on} \\Psi_h^{\\rm on} , and a set of undesired off-target complexes , \\Psi_h^{\\rm off} \\Psi_h^{\\rm off} . The set of complexes in the test tube is then: \\begin{align} \\Psi_h = \\Psi_h^{\\rm on} \\cup \\Psi_h^{\\rm off}. \\end{align} \\begin{align} \\Psi_h = \\Psi_h^{\\rm on} \\cup \\Psi_h^{\\rm off}. \\end{align} Let each on-target complex, j\\in\\Psi_h^{\\rm on} j\\in\\Psi_h^{\\rm on} , have a target secondary structure, s_j s_j , and a target concentration, y_{h,j} y_{h,j} . Let each off-target complex, j\\in\\Psi_h^{\\rm off} j\\in\\Psi_h^{\\rm off} , have a vanishing target concentration ( y_{h,j} = 0 y_{h,j} = 0 ) and no target structure ( s_j = \\emptyset s_j = \\emptyset ). The dimensional test tube ensemble defect, \\begin{align} C(\\phi_{\\Psi_h}, s_{\\Psi_h}, y_{h,\\Psi_h}) = \\sum_{j\\in\\Psi^{\\rm on}_h} \\Bigl[ n(\\phi_{j},s_{j})\\min (x_{h,j},y_{h,j}) + |\\phi_{j}|\\max(y_{h,j}-x_{h,j},0)\\Bigr] \\end{align} \\begin{align} C(\\phi_{\\Psi_h}, s_{\\Psi_h}, y_{h,\\Psi_h}) = \\sum_{j\\in\\Psi^{\\rm on}_h} \\Bigl[ n(\\phi_{j},s_{j})\\min (x_{h,j},y_{h,j}) + |\\phi_{j}|\\max(y_{h,j}-x_{h,j},0)\\Bigr] \\end{align} quantifies the equilibrium concentration of incorrectly paired nucleotides over the ensemble of test tube h h [ Wolfe15 ]. Here, x_{h,j} x_{h,j} is the equilibrium concentration of complex j j in tube h h . For each on-target complex, j\\in\\Psi^{\\rm on}_h j\\in\\Psi^{\\rm on}_h , the first term in the sum represents the structural defect , quantifying the concentration of nucleotides that are in an incorrect base-pairing state within the ensemble of complex j j , and the second term in the sum represents the concentration defect , quantifying the concentration of nucleotides that are in an incorrect base-pairing state because there is a deficiency in the concentration of complex j j . For each off-target complex, j\\in\\Psi^{\\rm off}_h j\\in\\Psi^{\\rm off}_h , the structural and concentration defects are identically zero, since y_{h,j}=0 y_{h,j}=0 . This does not mean that the defects associated with off-targets are ignored. By conservation of mass, non-zero off-target concentrations imply deficiencies in on-target concentrations, and these concentration defects are quantified by the equation above [ Wolfe15 ]. The normalized test tube ensemble defect is then denoted \\begin{align} {\\mathcal M}_h\\equiv C_h/y^{\\rm nt}_h \\in (0,1) \\end{align} representing the equilibrium fraction of incorrectly paired nucleotides in tube h h . Here, \\begin{align} y^{\\rm nt}_h \\equiv \\sum_{j\\in\\Psi^{\\rm on}_h} |\\phi_j|y_{h,j} \\end{align} \\begin{align} y^{\\rm nt}_h \\equiv \\sum_{j\\in\\Psi^{\\rm on}_h} |\\phi_j|y_{h,j} \\end{align} is the total concentration of nucleotides in tube h h . As {\\mathcal M}_h {\\mathcal M}_h approaches zero, each on-target complex, j\\in \\Psi^{\\rm on}_h j\\in \\Psi^{\\rm on}_h , approaches its target concentration, y_{h,j} y_{h,j} , and is dominated by its target structure, s_{j} s_{j} , and each off-target complex, j\\in\\Psi^{\\rm off}_h j\\in\\Psi^{\\rm off}_h , forms with vanishing target concentration. For a set of test tubes \\Omega \\Omega , the test tube ensemble defect can be generalized to a multi-tube ensemble defect \\begin{align} {\\mathcal M} \\equiv \\frac{1}{\\lvert \\Omega \\rvert} \\sum_{h \\in \\Omega} {\\mathcal M}_h ~~~\\in (0,1) \\end{align} \\begin{align} {\\mathcal M} \\equiv \\frac{1}{\\lvert \\Omega \\rvert} \\sum_{h \\in \\Omega} {\\mathcal M}_h ~~~\\in (0,1) \\end{align} quantifying the average equilibrium fraction of incorrectly paired nucleotides over the test tubes h\\in\\Omega h\\in\\Omega . Design formulation \u00b6 NUPACK provides a framework for designing the sequences of multiple nucleic acid strands intended to hybridize in solution via a prescribed reaction pathway. Sequence design is formulated as a multistate optimization problem using a set of target test tubes to represent reactant, intermediate, and product states of the system, as well as to model crosstalk between components. Each target test tube contains a set of desired on-target complexes, each with a target secondary structure and target concentration, and a set of undesired off-target complexes, each with vanishing target concentration. Design quality is quantified by the multi-tube ensemble defect , \\mathcal{M} \\mathcal{M} , representing the average equilibrium fraction of incorrectly paired nucleotides evaluated over the design ensemble [ Wolfe17 ]. Optimization of the sequences so as to reduce \\mathcal{M} \\mathcal{M} below a user-specified stop condition implements both a positive design paradigm, explicitly designing for on-pathway elementary steps, and a negative design paradigm, explicitly designing against off-pathway crosstalk. Sequence design is performed subject to both hard constraints (including composition constraints and biological constraints) and soft constraints (including sequence symmetry minimization and toehold free energy equalization). Complex design vs test tube design \u00b6 We recommend using the multi-tube design ensemble instead of the multi-complex ensemble because test tube design provides significant advantages over complex design [ Wolfe15 , Wolfe17 ]. Example Figure: The advantages of test tube design over complex design. Top: Complex design. Sequence design formulated in the context of a complex (left) ensures that at equilibrium the target structure dominates the structural ensemble of the complex (center). Unfortunately, subsequent test tube analysis reveals that the desired on-target complex occurs at negligible concentration relative to other undesired off-target complexes (right). With complex design, neither the concentration of the desired on-target complex, nor the concentrations of undesired off-target complexes are considered. As a result, sequences that are successfully optimized to predominantly adopt a target secondary structure in the context of an on-target complex, may nonetheless fail to ensure that this complex forms at appreciable concentration when the strands are introduced into a test tube. Bottom: Test tube design. Sequence design formulated in the context of a test tube (left) ensures that at equilibrium the desired on-target complex is dominated by its target structure and forms at approximately its target concentration, and that undesired off-target complexes form at negligible concentrations (center). Subsequent test tube analysis (right) provides no new information and no unpleasant surprises since the design and analysis ensembles are identical. Note that the multi-tube ensemble encompases the complex ensemble, test tube ensemble, and multi-complex ensemble as subsidiary special cases [ Wolfe17 ]. Reaction pathways \u00b6 Consider a set of nucleic acid molecules intended to execute a prescribed hybridization cascade [ Wolfe17 ]. For example, the reaction pathway below describes scRNAs that upon binding to input X, perform shape and sequence transduction to form a Dicer substrate targeting an independent output Y for silencing [ Hochrein13 ]. A reaction pathway specifies the elementary steps (each a self-assembly or disassembly operation in which complexes form or break) by which the molecules are intended to interact, the desired secondary structure for each on-pathway complex, and the complementarity relationships between sequence domains in the molecules. In the reaction pathway below there are two elementary steps (Step 1: X + A \\cdot \\cdot B \\rightarrow \\rightarrow X \\cdot \\cdot A + B, Step 2: B + C \\rightarrow \\rightarrow B \\cdot \\cdot C) involving six on-pathway complexes (X, A \\cdot \\cdot B, X \\cdot \\cdot A, B, C, B \\cdot \\cdot C) and numerous sequence domains ( a* complementary to a , b* complementary to b , and so on). Figure: Reaction pathway schematic. Conditional Dicer substrate formation via shape and sequence transduction with small conditional RNAs (scRNAs) [ Hochrein13 ]. scRNA A \\cdot \\cdot B detects input X (comprising sequence a-b-c ), leading to production of Dicer substrate B \\cdot \\cdot C (targeting independent sequence w-x-y-z ). Step 1: X displaces A from B via toehold-mediated 3-way branch migration and spontaneous dissociation. Step 2: B assembles with C via loop/toehold nucleation and 3-way branch migration to form Dicer substrate B \\cdot \\cdot C. See [ Wolfe17 ] for additional reaction pathway case studies. In addition to specifying a set of desired on-pathway elementary steps, each reaction pathway also implicitly specifies a much larger set of off-pathway interactions, corresponding to undesired crosstalk between components within the pathway or with components from other unrelated reaction pathways. To perform sequence design for reaction pathway engineering, we formulate a multistate optimization problem to explicitly design for on-pathway elementary steps (a positive design paradigm) and against off-pathway crosstalk (a negative design paradigm) [ Wolfe17 ]. Multi-tube design ensemble \u00b6 A multi-tube design problem is specified as a set of target test tubes , \\Omega \\Omega [ Wolfe17 ]. Each tube, h \\in \\Omega h \\in \\Omega , contains a set of desired on-target complexes , \\Psi_h^{\\rm on} \\Psi_h^{\\rm on} , and a set of undesired off-target complexes , \\Psi_h^{\\rm off} \\Psi_h^{\\rm off} . For each on-target complex, j\\in\\Psi_h^{\\rm on} j\\in\\Psi_h^{\\rm on} , the user specifies a target secondary structure, s_{j} s_{j} , and a target concentration, y_{h, j} y_{h, j} . For each off-target complex, j\\in\\Psi_h^{\\rm off} j\\in\\Psi_h^{\\rm off} , the target concentration is vanishing ( y_{h,j}=0 y_{h,j}=0 ) and there is no target structure (s_{j}=\\emptyset) (s_{j}=\\emptyset) . The set of complexes in tube h h is then \\Psi_h \\equiv \\Psi^{\\rm on}_h \\cup \\Psi^{\\rm off}_h \\Psi_h \\equiv \\Psi^{\\rm on}_h \\cup \\Psi^{\\rm off}_h and the set of all complexes in multistate test tube ensemble \\Omega \\Omega is \\Psi \\equiv \\cup_{h\\in\\Omega} \\Psi_h \\Psi \\equiv \\cup_{h\\in\\Omega} \\Psi_h . Let \\begin{align} \\phi_{\\Psi} \\equiv \\phi_j ~~~\\forall j\\in \\Psi \\end{align} denote the set of sequences for the complexes in \\Psi \\Psi . Warning Note that each on-target complex has exactly one target secondary structure. Consider specification of the multistate test tube ensemble, \\Omega \\Omega , for the design of N N orthogonal systems for a reaction pathway of M M elementary steps. One elementary step tube is specified for each step m=0,\\dots,M m=0,\\dots,M for each system n=1,\\dots,N n=1,\\dots,N (treating formation of the initial reactants as a precursor ``Step 0\u2019\u2018). Additionally, a single global crosstalk tube is specified to minimize off-pathway interactions between the reactive species generated during all elementary steps of all systems. The total number of target test tubes is then |\\Omega| = N*(M+1) + 1 |\\Omega| = N*(M+1) + 1 . Target test tubes \u00b6 The figure below depicts target test tubes for the reaction pathway depicted above. There are three elementary step tubes, each containing on-target complexes corresponding to the products of the corresponding step: the Reactants tube (Step 0) contains on-targets X, A \\cdot \\cdot B, and C; the Step 1 tube contains on-targets X \\cdot \\cdot A and B; the Step 2 tube contains on-target B \\cdot \\cdot C. Each elementary step tube contains a set of on-target complexes (each with a target secondary structure and target concentration), corresponding to the on-pathway hybridization products for a given step, and a set of undesired off-target complexes (each with vanishing target concentration), corresponding to on-pathway reactants and off-pathway hybridization crosstalk for a given step. Hence, these elementary step tubes design for full conversion of cognate reactants into cognate products and against local crosstalk between these same reactants. Figure: Target test tubes. Left: Elementary step tubes. Reactants tube (Step 0): target X and scRNAs A \\cdot \\cdot B and C. Step 1 tube: X \\cdot \\cdot A and B. Step 2 tube: Dicer substrate B \\cdot \\cdot C. Each target test tube contains the depicted on-target complexes corresponding to the on-pathway products for a given step (each with the depicted target secondary structure and a target concentration of 10 nM) as well as off-target complexes (not depicted) corresponding to on-pathway reactants and off-pathway crosstalk for a given step. To design N N orthogonal systems, there are three elementary step tubes for each system n=1,\\dots,N n=1,\\dots,N . Right: Global crosstalk tube. Contains the depicted on-target complexes corresponding to reactive species generated during Steps 0, 1, 2 as well as off-target complexes (not depicted) corresponding to off-pathway interactions between these reactive species. To design N N orthogonal systems, the global crosstalk tube contains a set of on-targets and off-targets for each system n=1,\\dots,N n=1,\\dots,N . To simultaneously design N N orthogonal systems, three elementary step tubes of the type shown above (left) are specified for each system. Furthermore, to design against off-pathway interactions within and between systems, a single global crosstalk tube is specified (right). In the global crosstalk tube, the on-target complexes correspond to all reactive species generated during all elementary steps ( m=0,1,2 m=0,1,2 ) for all systems ( n=1,\\dots,N n=1,\\dots,N ); the off-target complexes correspond to non-cognate interactions between these reactive species (see Supplementary Section S2.2 of [ Wolfe17 ] for details on defining reactive species for a given reaction pathway). Crucially, the global crosstalk tube ensemble omits the cognate products that the reactive species are intended to form (they appear as neither on-targets nor off-targets). Hence, all reactive species in the global crosstalk tube are forced to either perform no reaction (remaining as desired on-targets) or undergo a crosstalk reaction (forming undesired off-targets), providing the basis for minimization of global crosstalk during sequence optimization. To design 8 orthogonal systems for this reaction pathway, the total number of target test tubes is then |\\Omega| = 8*3 + 1 = 25 |\\Omega| = 8*3 + 1 = 25 . See [ Wolfe17 ] Supplementary Information Section S2.2 for a general description of how to specify target test tubes for a given reaction pathway, as well as a number of illustrative case studies. Note Note that each target test tube isolates a different subset of the system components in local equilibrium, enabling optimization of kinetically significant states that would appear insignificant if all components were allowed to interact in a single ensemble. For example, the Step 1 tube simultaneously optimizes for high-yield production of unstructured intermediate B and against appreciable formation of off-target dimer B \\cdot \\cdot B, promoting rapid nucleation of the unstructured toehold in B with the loop of hairpin C during the next step of the reaction pathway. Note Note that for a tube containing a given set of system components, the cognate products of their interactions can be excluded from the ensemble (appearing as neither on-targets nor off-targets), enabling optimization for high-yield well-structured reactants and against crosstalk. For example, the Reactants tube excludes the cognate product of Step 1 from the ensemble in order to optimize formation of initial reactants X, A \\cdot \\cdot B, and C and discourage competing crosstalk interactions (e.g., X \\cdot \\cdot X, A \\cdot \\cdot A, X \\cdot \\cdot C). Design objective function \u00b6 The design objective function is the multi-tube ensemble defect [ Wolfe17 ], \\begin{align} \\mathcal{M}\\in[0,1], \\end{align} \\begin{align} \\mathcal{M}\\in[0,1], \\end{align} representing the average equilibrium fraction of incorrectly paired nucleotides over the multitube ensemble, \\Omega \\Omega . Defect weights \u00b6 To prioritize or de-prioritize design quality for a portion of the design ensemble, the defect-weighted objective function, \\mathcal{M}_\\mathcal{W} \\mathcal{M}_\\mathcal{W} , incorporates user-specified defect weights for any tube, complex, strand, or domain. With the default value of unity for all weights, \\mathcal{M}_\\mathcal{W} \\mathcal{M}_\\mathcal{W} is simply the multi-tube ensemble defect , \\mathcal{M} \\mathcal{M} . With custom defect weights in the range [0,\\infty) [0,\\infty) , the physical meaning of the objective function is distorted in the service of adjusting design priorities. Increasing the weight for a tube, complex, strand or domain will lead to a corresponding increase in the allocation of effort to designing this entity, typically leading to a corresponding reduction in the defect contribution of the entity. Likewise, decreasing the weight for a tube, complex, strand or domain will lead to a corresponding decrease in the allocation of effort to designing this entity, typically leading to a corresponding increase in the defect contribution of the entity. Hard constraints \u00b6 Sequence design can be performed subject to hard constraints that prohibit sequences violating the constraints. The following types of hard sequence constraints can be imposed [ Wolfe17 ]: Assignment Constraint: Nucleotide a a is constrained to have a specified sequence (e.g., A , C , G , U or any of the degenerate nucleotide codes . To specify an assignment constraint, specify a domain . Match Constraint: Two nucleotides a a and b b are constrained to be identical (e.g., if a strand species appears in more than one on-target complex, corresponding nucleotides are constrained to have the same sequence in all complexes). Complementarity Constraint: Two nucleotides a a and b b are constrained to be Watson\u2013Crick complements, or optionally for RNA, to be Watson-Crick or wobble complements. Similarity Constraint: Consecutive nucleotides a,\\dots,b a,\\dots,b are constrained to be similar to a specified sequence of length n=b-a+1 n=b-a+1 to a specified degree (e.g., a desired GC content can be achieved by constraining the fraction of \u2018S\u2019 nucleotides to fall in the range [f^{\\rm min}, f^{\\rm max}] [f^{\\rm min}, f^{\\rm max}] ). Library Constraint: Consecutive nucleotides a,\\dots,b a,\\dots,b are constrained to be selected from a specified library of m m sequences of length n=b-a+1 n=b-a+1 (e.g., a library of toehold sequences or a library of codons). Window Constraint: Consecutive nucleotides a,\\dots,b a,\\dots,b are constrained to be a subsequence of a specified source sequence of length n\\ge b-a+1 n\\ge b-a+1 (e.g., the source sequence is an mRNA), or more generally, a subsequence of one of multiple specified source sequences. Pattern Prevention Constraint: Consecutive nucleotides a,\\dots,b a,\\dots,b are constrained not to contain a specified subsequence of length n\\le b-a+1 n\\le b-a+1 (e.g., prevention of GGGG , which is prone to forming G -quadruplexes that are not accounted for in nearest-neighbor free energy models). Diversity Constraint: Consecutive nucleotides a,\\dots,b a,\\dots,b are constrained to have a specified degree of sequence diversity (e.g., every subsequence of length 4 should have at least 2 nucleotide types). Let \\mathcal R \\mathcal R denote the user-specified set of hard constraints for a design problem. Soft constraints \u00b6 As an alternative to hard constraints that prohibit constraint violations, soft constraints define auxiliary objective functions that penalize suboptimal sequences during the design process [ Porubsky20 ]: \\begin{align} w_k f_k(\\phi_\\Psi) \\end{align} Here, f_k(\\phi_\\Psi)\\in[0,1] f_k(\\phi_\\Psi)\\in[0,1] is the penalty function for soft constraint k k and w_k\\in [0,\\infty) w_k\\in [0,\\infty) (default: 1) is the corresponding user-specified weight. Soft constraints can reduce design cost relative to the corresponding hard constraint by making it easier for the optimization process to identify candidate sequence mutations. Soft constraints can also increase flexibility by enabling specification of new design goals (e.g., designing a set of toeholds to have comparable binding strength) for which there is no hard constraint analog. The following types of soft constraints can be imposed: Similarity: Penalize consecutive nucleotides a,\\dots,b a,\\dots,b if they fail to be similar to a specified sequence of length n=b-a+1 n=b-a+1 to a specified degree (e.g., to drive the fraction of nucleotides matching an mRNA sequence to fall in the range [f^{\\rm min}, f^{\\rm max}] [f^{\\rm min}, f^{\\rm max}] ). Pattern prevention: Penalize consecutive nucleotides a,\\dots,b a,\\dots,b if they contain a specified subsequence of length n\\le b-a+1 n\\le b-a+1 (e.g., to discourage use of GGGG , which is prone to forming G -quadruplexes that are not accounted for in nearest-neighbor free energy models). Sequence symmetry minimization: Penalize consecutive nucleotides a,\\dots,b a,\\dots,b of a specified word length , L_w L_w , if [ Seeman82 ]: 1) a word appears in more than one location in the design (unless sequence domains are explicitly constrained to be identical), 2) a word and its reverse complement both appear in the design but they are specified in a target structure not to form a duplex, 3) a word that appears in the design is self-complementary. Sequence symmetry minimization is a negative design heuristic [ Dirks04 ] that destabilizes formation of off-target structures by ensuring they cannot form without mismatches in any subsequence of the word length. Energy match: Consider a set of duplexes (e.g., toeholds and toehold complements) that are intended to have structure free energies that match each other or a specified reference free energy. This soft constraint will penalize duplexes to the extent they deviate from the desired structure free energy. Let \\mathcal S \\mathcal S denote the user-specified set of soft constraints for a design problem. Constrained multi-tube design problem \u00b6 To design a set of sequences, \\Phi_\\Psi \\Phi_\\Psi , for a multi-tube ensemble , \\Omega \\Omega , subject to user-specified hard constraints \\mathcal{R} \\mathcal{R} and soft constraints \\mathcal{S} \\mathcal{S} , the constrained multi-tube design problem is: \\begin{align} \\min_{\\phi_\\Psi}\\left[\\mathcal{M}_{\\mathcal{W}} ~~~+~~~\\sum_{k\\in\\mathcal{S}} w_kf_k(\\phi_\\Psi)\\right] ~~~~\\mathrm{subject~to} ~~~~\\mathcal{R}, \\end{align} \\begin{align} \\min_{\\phi_\\Psi}\\left[\\mathcal{M}_{\\mathcal{W}} ~~~+~~~\\sum_{k\\in\\mathcal{S}} w_kf_k(\\phi_\\Psi)\\right] ~~~~\\mathrm{subject~to} ~~~~\\mathcal{R}, \\end{align} where \\mathcal{M}_\\mathcal{W} \\mathcal{M}_\\mathcal{W} is the multi-tube ensemble defect including user-specified defect weights \\mathcal{W} \\mathcal{W} . The sequence design algorithm seeks to iteratively reduce the augmented objective function (weighted ensemble defect plus weighted soft constraints) below the stop condition \\begin{align} \\left[\\mathcal{M}_{\\mathcal{W}} ~~~+~~~\\sum_{k\\in\\mathcal{S}} w_kf_k(\\phi_\\Psi)\\right] \\le f_\\textrm{stop} \\end{align} \\begin{align} \\left[\\mathcal{M}_{\\mathcal{W}} ~~~+~~~\\sum_{k\\in\\mathcal{S}} w_kf_k(\\phi_\\Psi)\\right] \\le f_\\textrm{stop} \\end{align} for user-specified f_\\textrm{stop} \\in (0,1) f_\\textrm{stop} \\in (0,1) while satisfying the hard constraints in \\mathcal{R} \\mathcal{R} . Zadeh11a Zadeh J.N., Steenberg C.D., Bois J.S., Wolfe B.R., Pierce M.B., Khan A.R., Dirks R.M., Pierce N.A.: NUPACK: Analysis and Design of Nucleic Acid Systems . J. Comput. Chem.. 32 , (2011) Zadeh10c Zadeh J.N.: Algorithms for Nucleic Acid Sequence Design . (2010) Dirks07 Dirks R.M., Bois J.S., Schaeffer J.M., Winfree E., Pierce N.A.: Thermodynamic Analysis of Interacting Nucleic Acid Strands . SIAM Rev.. 49 , (2007) Zadeh11b Zadeh J.N., Wolfe B.R., Pierce N.A.: Nucleic Acid Sequence Design via Efficient Ensemble Defect Optimization . J. Comput. Chem.. 32 , (2011) Fornace20 Fornace M.E., Porubsky N.J., Pierce N.A.: A Unified Dynamic Programming Framework for the Analysis of Interacting Nucleic Acid Strands: Enhanced Models, Scalability, and Speed . ACS Synth. Biol.. (2020) Santalucia98 SantaLucia J.: A Unified View of Polymer, Dumbbell, and Oligonucleotide DNA Nearest-Neighbor Thermodynamics . Proc. Natl. Acad. Sci. USA. 95 , (1998) Xia98 Xia T., SantaLucia J., Burkard M., Kierzek R., Schroeder S., Jiao X., Cox C., Turner D.: Thermodynamic Parameters for an Expanded Nearest-Neighbor Model for Formation of RNA Duplexes with Watson-Crick Base Pairs . Biochemistry. 37 , (1998) Mathews99 Mathews D.H., Sabina J., Zuker M., Turner D.H.: Expanded Sequence Dependence of Thermodynamic Parameters Improves Prediction of RNA Secondary Structure . J. Mol. Biol.. 288 , (1999) Zuker03 Zuker M.: Mfold Web Server for Nucleic Acid Folding and Hybridization Prediction . Nucleic Acids Res.. 31 , (2003) Lu06 Lu Z.J., Turner D.H., Mathews D.H.: A Set of Nearest Neighbor Parameters for Predicting the Enthalpy Change of RNA Secondary Structure Formation . Nucleic acids research. 34 , (2006) Turner10 Turner D.H., Mathews D.H.: NNDB: The Nearest Neighbor Parameter Database for Predicting Stability of Nucleic Acid Secondary Structure . Nucleic Acids Res.. 38 , (2010) Bloomfield00 Bloomfield V., Crothers D., Tinoco I.: Nucleic Acids: Structures, Properties, and Functions . (2000) Serra95 Serra M.J., Turner D.H.: Predicting Thermodynamic Properties of RNA . Methods Enzymol.. 259 , (1995) Santalucia04 SantaLucia J., Hicks D.: The thermodynamics of DNA structural motifs . Annu. Rev. Biophys. Biomol. Struct.. 33 , (2004) Peyret00 Peyret N.: Prediction of Nucleic Acid Hybridization: Parameters and Algorithms . (2000) Bommarito00 Bommarito S., Peyret N., SantaLucia J.: Thermodynamic Parameters for DNA Sequences with Dangling Ends . Nucleic Acids Res.. 28 , (2000) Dirks04 Dirks R.M., Lin M., Winfree E., Pierce N.A.: Paradigms for Computational Nucleic Acid Design . Nucleic Acids Res.. 32 , (2004) Wolfe15 Wolfe B.R., Pierce N.A.: Nucleic Acid Sequence Design for a Test Tube of Interacting Nucleic Acid Strands . ACS Synth. Biol.. 4 , (2015) Wolfe17 Wolfe B.R., Porubsky N.J., Zadeh J.N., Dirks R.M., Pierce N.A.: Constrained Multistate Sequence Design for Nucleic Acid Reaction Pathway Engineering . J Am. Chem. Soc.. 139 , (2017) Hochrein13 Hochrein L.M., Schwarzkopf M., Shahgholi M., Yin P., Pierce N.A.: Conditional Dicer Substrate Formation via Shape and Sequence Transduction with Small Conditional RNAs . J. Am. Chem. Soc.. 135 , (2013) Porubsky20 Porubsky N.J.: Enhanced Algorithms for Analysis and Design of Nucleic Acid Reaction Pathways. PhD Thesis. California Institute of Technology . (2020) Seeman82 Seeman N.C.: Nucleic Acid Junctions and Lattices . J Theor Biol. 99 , (1982)","title":"Definitions"},{"location":"definitions/#definitions","text":"","title":"Definitions"},{"location":"definitions/#sequence","text":"The sequence , \\phi \\phi , of one or more interacting RNA strands is specified as a list of bases \\phi^a\\in\\{\\texttt{A},\\texttt{C},\\texttt{G},\\texttt{U}\\} \\phi^a\\in\\{\\texttt{A},\\texttt{C},\\texttt{G},\\texttt{U}\\} for a=1,\\dots,|\\phi| a=1,\\dots,|\\phi| . For DNA, \\phi^a\\in\\{\\texttt{A},\\texttt{C},\\texttt{G},\\texttt{T}\\} \\phi^a\\in\\{\\texttt{A},\\texttt{C},\\texttt{G},\\texttt{T}\\} . Nucleic acid sequences are listed 5' 5' to 3' 3' . Unlike NUPACK 3, bases in NUPACK 4 are indexed starting with 0 at the 5' 5' -most base of the first strand and ending at the 3' 3' -most base of the last strand. For example, if a complex has three strands of length 15, 20, and 13, respectively, the fifth base of the third strand has index 39. Valid bases are A , C , G , T , and U . For RNA calculations, T is automatically converted to U , and vice versa for DNA calculations.","title":"Sequence"},{"location":"definitions/#degenerate-nucleotide-codes","text":"Sequence constraints can be specified using IUPAC degenerate nucleotide codes , which for RNA are as follows: Code Nucleotides M A or C R A or G W A or U S C or G Y C or U K G or U V A, C, or G H A, C, or U D A, G, or U B C, G, or U N A, C, G, or U For DNA, T replaces U.","title":"Degenerate nucleotide codes"},{"location":"definitions/#sequence-distance","text":"The sequence distance between two sequences \\phi_1 \\phi_1 and \\phi_2 \\phi_2 of equal length ( |\\phi_1|=|\\phi_2|=N |\\phi_1|=|\\phi_2|=N ) is the number of (possibly degenerate) nucleotide codes that are non-intersecting in the two sequences: \\begin{align} d_\\textrm{seq}(\\phi_1,\\phi_2) = \\sum_{1\\le a \\le N} \\left\\{\\begin{array}[ll] 0 0: &\\phi_1^a \\cap \\phi_2^a \\neq \\emptyset\\\\ 1: &\\phi_1^a \\cap \\phi_2^a = \\emptyset\\end{array} \\right. \\end{align} \\begin{align} d_\\textrm{seq}(\\phi_1,\\phi_2) = \\sum_{1\\le a \\le N} \\left\\{\\begin{array}[ll] 0 0: &\\phi_1^a \\cap \\phi_2^a \\neq \\emptyset\\\\ 1: &\\phi_1^a \\cap \\phi_2^a = \\emptyset\\end{array} \\right. \\end{align} For example, d_\\textrm{seq} d_\\textrm{seq} (ACGU, SSWW) = 2. If \\phi_1 \\phi_1 and \\phi_2 \\phi_2 contain no degenerate nucleotide codes, this definition simplifies to the number of nucleotides that are different in the two sequences: \\begin{align} d_\\textrm{seq}(\\phi_1,\\phi_2) = \\sum_{1\\le a \\le N} \\left\\{\\begin{array}[ll] 0 0: &\\phi_1^a = \\phi_2^a\\\\ 1: &\\phi_1^a \\neq \\phi_2^a \\end{array} \\right. \\end{align} \\begin{align} d_\\textrm{seq}(\\phi_1,\\phi_2) = \\sum_{1\\le a \\le N} \\left\\{\\begin{array}[ll] 0 0: &\\phi_1^a = \\phi_2^a\\\\ 1: &\\phi_1^a \\neq \\phi_2^a \\end{array} \\right. \\end{align} For example, d_\\textrm{seq} d_\\textrm{seq} (ACGU, ACUU) = 1.","title":"Sequence distance"},{"location":"definitions/#secondary-structure","text":"A secondary structure , s s , of one or more interacting RNA strands is defined by a set of base pairs, each a Watson\u2013Crick pair [A \\cdot \\cdot U or C \\cdot \\cdot G] or a wobble pair [G \\cdot \\cdot U]). For DNA, the corresponding Watson\u2013Crick pairs are A \\cdot \\cdot T or C \\cdot \\cdot G and there are no wobble pairs. A polymer graph representation of a secondary structure is constructed by ordering the strands around a circle, drawing the backbones in succession from 5 ' ' to 3 ' ' around the circumference with a nick between each strand, and drawing straight lines connecting paired bases. A secondary structure is unpseudoknotted if there exists a strand ordering for which the polymer graph has no crossing lines, or pseudoknotted if all strand orderings contain crossing lines. In NUPACK 4, pseudoknots are excluded from the structural ensemble. A secondary structure is connected if no subset of the strands is free of the others. Secondary structures may be specified one of three ways for NUPACK calculations as described in the following three sections.","title":"Secondary structure"},{"location":"definitions/#dot-parens-plus-notation","text":"Each unpaired base is represented by a dot, each base pair by matching parentheses, and each nick between strands by a plus [ Zadeh11a ]. For example, ((...)) specifies that bases 0 and 1 are paired to bases 6 and 5, respectively, while bases 2, 3, and 4 are unpaired. ((+...)) specifies that bases 0 and 1 of strand 0 are paired to bases 4 and 3 of strand 1.","title":"Dot-parens-plus notation"},{"location":"definitions/#run-length-encoded-dot-parens-plus-notation","text":"As a shorthand for dot-parens-plus, any sequence of consecutive characters in dot-parens-plus may be replaced by the character followed by a number. For instance, (((((+...........))))) may be written as (5+.11)5 .","title":"Run-length encoded dot-parens-plus notation"},{"location":"definitions/#du-notation","text":"Using DU+ notation, a duplex is represented by D and an unpaired region of length nucleotides is represented by U [ Zadeh10c ]. Each duplex is followed immediately by the substructure (specified in DU+ notation) that is \u2018enclosed\u2019 by the duplex. If this substructure includes more than one element, parentheses are used to denote scope. A nick between strands is specified by a \u2018+\u2019. See the table below for examples. Example Dot-parens-plus RLE dot-parens-plus DU+ notation ((((((((((((..........)))))))))))) (12.10)12 D12 U10 ((((((((((((+)))))))))))).......... (12+)12.10 D12 + U10 ((((((((((((+..........)))))))))))) (12+.10)12 D12 (+ U10) Table : Examples of dot-parens-plus, run-length-encoded (RLE) dot-parens-plus, and DU+ notation. Example Figure : Comparison of dot-parens-plus, run-length-encoded dot-parens-plus, and DU+ notation.","title":"DU+ notation"},{"location":"definitions/#structure-matrix","text":"In mathematical expressions, it is convenient to represent secondary structure s s using a structure matrix S(s) S(s) with entries S^{a,b}(s) = 1 S^{a,b}(s) = 1 if structure s s contains base pair a\\cdot b a\\cdot b and S^{a,b}(s) = 0 S^{a,b}(s) = 0 otherwise. Abusing notation, the entry S^{a,a}(s) = 1 S^{a,a}(s) = 1 if base a a is unpaired in structure s s and 0 0 otherwise. Hence, S(s) S(s) is a symmetric matrix with row and column sums of 1.","title":"Structure matrix"},{"location":"definitions/#structure-distance","text":"The structure distance between two secondary structures s_1 s_1 and s_2 s_2 of equal size ( |s_1|=|s_2|=N |s_1|=|s_2|=N ) is the number of nucleotides in a different base-pairing state in the two structures: \\begin{align} d_\\textrm{struc}(s_1,s_2)=N-\\sum_{1\\le a\\le N,~1\\le b \\le N} S_{a,b}(s_1)S_{a,b}(s_2) \\end{align}","title":"Structure distance"},{"location":"definitions/#complex-ensemble","text":"Consider a complex of L L distinct strands (e.g., each with a unique identifier in \\{1,\\dots,L\\} \\{1,\\dots,L\\} ) corresponding to strand ordering \\pi \\pi . The complex ensemble \\overline\\Gamma(\\phi) \\overline\\Gamma(\\phi) contains all connected polymer graphs with no crossing lines for sequence \\phi \\phi and strand ordering \\pi \\pi (i.e., all unpseudoknotted secondary structures) [ Dirks07 ]. (We dispense with our prior convention [ Dirks07 , Zadeh11a , Zadeh11b ] of calling this entity an \u2018\u2019ordered complex\u2019\u2018.) As a matter of algorithmic necessity, all of the dynamic programs in NUPACK operate on complex ensemble \\overline\\Gamma(\\phi) \\overline\\Gamma(\\phi) treating all strands as distinct. However, in the laboratory, strands with the same sequence are typically indistinguishable with respect to experimental observables. For comparison to experimental data, physical quantities calculated over ensemble \\overline\\Gamma(\\phi) \\overline\\Gamma(\\phi) are post-processed to obtain the corresponding quantities calculated over complex ensemble \\Gamma(\\phi) \\Gamma(\\phi) in which strands with the same sequence are treated as indistinguishable [ Fornace20 ]. The ensemble \\Gamma(\\phi)\\subseteq\\overline\\Gamma(\\phi) \\Gamma(\\phi)\\subseteq\\overline\\Gamma(\\phi) is a maximal subset of distinct secondary structures for strand ordering \\pi \\pi . Two secondary structures are indistinguishable if their polymer graphs can be rotated so that all strands are mapped onto indistinguishable strands, all base pairs are mapped onto base pairs, and all unpaired bases are mapped onto unpaired bases; otherwise the structures are distinct [ Dirks07 ]. Figure: A complex of 3 strands with strand ordering \\pi \\pi = ABC.","title":"Complex ensemble"},{"location":"definitions/#test-tube-ensemble","text":"A test tube ensemble is a dilute solution containing a set of strand species, \\Psi^0 \\Psi^0 , introduced at user-specified concentrations, that interact to form a set of complex species, \\Psi \\Psi , each corresponding to a different strand ordering treating strands with the same sequence as indistinguishable [ Dirks07 , Fornace20 ]. For L L strands, there are (L-1)! (L-1)! strand orderings if all strands are different species (e.g., complexes \\pi \\pi = ABC and \\pi \\pi = ACB for L=3 L=3 and strands A, B, C), but fewer than (L-1)! (L-1)! strand orderings if some strands are of the same species (e.g., complex \\pi \\pi = AAA for L=3 L=3 with three A strands). By the Representation Theorem [ Dirks07 ], a secondary structure in the complex ensemble for one strand ordering does not appear in the complex ensemble for any other strand ordering, averting redundancy. It is often convenient to define \\Psi \\Psi to contain all complex species of up to L_\\mathrm{max} L_\\mathrm{max} strands, although \\Psi \\Psi can be defined to contain arbitrary complex species formed from the strand species in \\Psi^0 \\Psi^0 . Figure: A test tube ensemble containing strain species \\Psi^0 = \\{ \\Psi^0 = \\{ A,B,C \\} \\} interacting to form all complex species \\Psi \\Psi of up to L_{\\rm max} = 3 L_{\\rm max} = 3 strands.","title":"Test tube ensemble"},{"location":"definitions/#free-energy-model","text":"For each (unpseudoknotted connected) secondary structure s\\in\\overline{\\Gamma}(\\phi) s\\in\\overline{\\Gamma}(\\phi) , the free energy, \\overline{\\Delta G}(\\phi,s) \\overline{\\Delta G}(\\phi,s) , is estimated as the sum of the empirically determined free energies of the constituent loops [ Santalucia98 , Xia98 , Mathews99 , Zuker03 , Lu06 , Turner10 ] plus a strand association penalty [ Bloomfield00 ], \\Delta G^\\textrm{assoc} \\Delta G^\\textrm{assoc} , applied L-1 L-1 times for a complex of L L strands: \\begin{align} \\overline{\\Delta G}(\\phi,s) = (L-1)\\,\\Delta G^\\textrm{assoc}\\, + \\sum_{\\mathrm{loop} \\in s} \\Delta G(\\mathrm{loop}). \\label{eq:dGbar} \\end{align}","title":"Free energy model"},{"location":"definitions/#loop-free-energies","text":"The loop free energy, \\Delta G(\\mathrm{loop}) \\Delta G(\\mathrm{loop}) , is modeled for the different loop types as follows: A hairpin loop is closed by a single base-pair a\\cdot b a\\cdot b . The loop free energy, \\Delta G^\\mathrm{hairpin}_{a,b} \\Delta G^\\mathrm{hairpin}_{a,b} , depends on sequence and loop size. An interior loop is closed by two base pairs ( a\\cdot b a\\cdot b and d\\cdot e d\\cdot e with a<d<e<b a<d<e<b ). The loop free energy, \\Delta G^\\mathrm{interior}_{a,d,e,b} \\Delta G^\\mathrm{interior}_{a,d,e,b} depends on sequence, loop size, and loop asymmetry. Bulge loops (where either d=a+1 d=a+1 or e=b-1 e=b-1 ) and stacked pairs (where both d=a+1 d=a+1 and e=b-1 e=b-1 ) are treated as special cases of interior loops. A multiloop is closed by three or more base pairs. The loop free energy is modeled as the sum of three sequence-independent penalties: \\Delta G^\\mathrm{multi}_\\mathrm{init} \\Delta G^\\mathrm{multi}_\\mathrm{init} for formation of a multiloop, \\Delta G^\\mathrm{multi}_\\mathrm{bp} \\Delta G^\\mathrm{multi}_\\mathrm{bp} for each closing base pair, \\Delta G^\\mathrm{multi}_\\mathrm{nt} \\Delta G^\\mathrm{multi}_\\mathrm{nt} for each unpaired nucleotide inside the multiloop, plus a sequence-dependent penalty: \\Delta G^\\mathrm{terminalbp}_{a, b} \\Delta G^\\mathrm{terminalbp}_{a, b} for each closing pair a\\cdot b a\\cdot b . An exterior loop contains a nick between strands and any number of closing base pairs. The exterior loop free energy is the sum of \\Delta G^\\mathrm{terminalbp}_{a, b} \\Delta G^\\mathrm{terminalbp}_{a, b} over all closing base pairs a\\cdot b a\\cdot b . Hence, an unpaired strand has a free energy of zero, corresponding to the reference state [ Dirks07 ]. Figure: Canonical loop types for a complex with strand ordering \\pi \\pi = ABC.","title":"Loop free energies"},{"location":"definitions/#coaxial-and-dangle-stacking","text":"Within a multiloop or an exterior loop, there is a subensemble of coaxial stacking states between adjacent closing base pairs and dangle stacking states between closing base pairs and adjacent unpaired bases. Within a multiloop or exterior loop, a base pair can form one coaxial stack with an adjacent base pair, or can form a dangle stack with at most two adjacent unpaired bases; unpaired bases can either form no stack, or can form a dangle stack with at most one adjacent base pair. Figure: Coaxial and dangle stacking states for a multiloop. Figure: Coaxial and dangle stacking states for two exterior loops. For a given multiloop or exterior loop, the energetic contributions of all possible coaxial and dangle stacking states are enumerated so as to calculate the free energy: \\begin{align} \\Delta G^\\mathrm{stacking} = - k T \\log \\sum_{\\omega\\in\\mathrm{loop}} \\prod_\\mathrm{x\\in\\omega} e^{-\\Delta G_x/k T}\\label{eq:stack} \\end{align} where \\omega \\omega indexes the possible stacking states within the loop and x x indexes the individual stacks (coaxial or dangle) within a stacking state. The free energy of a multiloop or exterior loop is augmented by the corresponding \\Delta G^\\mathrm{stacking} \\Delta G^\\mathrm{stacking} bonus. Hence, a secondary structure s s continues to be defined as a set of base pairs, and the stacking states within a given multiloop or exterior loop are treated as a structural subensemble that contributes in a Boltzmann-weighted fashion to the free energy model for the loop. Let s^\\shortparallel\\in s s^\\shortparallel\\in s denote a stacking state of the paired and unpaired bases in s s . We may equivalently define the free energy of secondary structure s s in terms of the stacking state free energies \\begin{align} \\overline{\\Delta G}(\\phi,s^\\shortparallel) \\end{align} for all stacking states s^\\shortparallel\\in s s^\\shortparallel\\in s : \\begin{align} \\overline{\\Delta G}(\\phi,s) = -kT \\log \\sum_{s^\\shortparallel\\in s}e^{-\\overline{\\Delta G}(\\phi,s^\\shortparallel)/kT} \\label{eq:stacksum} \\end{align} Let \\overline\\Gamma^\\shortparallel(\\phi) \\overline\\Gamma^\\shortparallel(\\phi) denote the ensemble of stacking states corresponding to the complex ensemble of secondary structures \\overline\\Gamma(\\phi) \\overline\\Gamma(\\phi) .","title":"Coaxial and dangle stacking"},{"location":"definitions/#symmetry-correction","text":"For a secondary structure s\\in\\Gamma(\\phi) s\\in\\Gamma(\\phi) with an R R -fold rotational symmetry there is in R R -fold reduction in distinguishable conformational space, so the free energy \\overline{\\Delta G}(\\phi,s) \\overline{\\Delta G}(\\phi,s) must be adjusted [ Dirks07 ] by a symmetry correction: \\begin{align} \\Delta G(\\phi,s) &= \\overline{\\Delta G}(\\phi,s) + \\Delta G^\\mathrm{sym}(\\phi,s). \\label{eq:dGcorrected} \\end{align} where \\begin{align} \\Delta G^\\mathrm{sym}(\\phi,s) = kT\\log R(\\phi,s). \\label{eq:dGsym} \\end{align} Because the symmetry factor R(\\phi,s) R(\\phi,s) is a global property of each secondary structure s\\in\\Gamma(\\phi) s\\in\\Gamma(\\phi) , it is not suitable for use with dynamic programs that treat multiple subproblems simultaneously without access to global structural information. As a result, dynamic programs operate on ensemble \\overline\\Gamma(\\phi) \\overline\\Gamma(\\phi) using physical model \\overline{\\Delta G}(\\phi,s) \\overline{\\Delta G}(\\phi,s) and then the Distinguishability Correction Theorem [ Dirks07 ] enables exact conversion of physical quantities to ensemble \\Gamma(\\phi) \\Gamma(\\phi) using physical model \\Delta G(\\phi,s) \\Delta G(\\phi,s) . Interestingly, ensembles \\overline\\Gamma(\\phi) \\overline\\Gamma(\\phi) and \\Gamma(\\phi) \\Gamma(\\phi) both have utility when examining the physical properties of a complex as they provide related but different perspectives, akin to complementary thought experiments [ Fornace20 ].","title":"Symmetry correction"},{"location":"definitions/#physical-quantities","text":"Consider a test tube ensemble containing an arbitrary set of strand species \\Psi^0 \\Psi^0 interacting to form an arbitrary set of complex species \\Psi \\Psi . Let j\\in\\Psi j\\in\\Psi denote a complex with sequence \\phi_j \\phi_j and complex ensembles \\overline\\Gamma(\\phi_j) \\overline\\Gamma(\\phi_j) (treating all strands as distinct) and \\Gamma(\\phi_j) \\Gamma(\\phi_j) (treating strands with the same seqeuence as indistinguishable). NUPACK calculates [ Dirks07 , Fornace20 ] a number of physical quantities over these ensembles.","title":"Physical quantities"},{"location":"definitions/#partition-function","text":"For complex j j , the partition function evaluated over ensemble \\Gamma(\\phi_j) \\Gamma(\\phi_j) treating strands with the same sequence as indistinguishable is denoted \\begin{align} Q(\\phi_j) = \\sum_{s\\in\\Gamma(\\phi_j)}e^{-\\Delta G(\\phi_j,s)/kT}. \\end{align} \\begin{align} Q(\\phi_j) = \\sum_{s\\in\\Gamma(\\phi_j)}e^{-\\Delta G(\\phi_j,s)/kT}. \\end{align}","title":"Partition function"},{"location":"definitions/#complex-free-energy","text":"For complex j j , the corresponding complex free energy is \\begin{align} \\Delta G(\\phi_j) \\equiv -kT \\log(Q(\\phi_j)). \\end{align}","title":"Complex free energy"},{"location":"definitions/#structure-free-energy","text":"For complex j j , the secondary structure free energy treating strands with the same sequence as indistinguishable is denoted \\begin{align} \\Delta G(\\phi_j,s). \\end{align} If the physical model includes coaxial and dangle stacking , the structure free energy will include stacking contributions \\Delta G^\\textrm{stacking} \\Delta G^\\textrm{stacking} . If the secondary structure s s has a rotational symmetry, the structure free energy will include the symmetry correction \\Delta G^\\textrm{sym}(\\phi_j,s) \\Delta G^\\textrm{sym}(\\phi_j,s) .","title":"Structure free energy"},{"location":"definitions/#equilibrium-structure-probability","text":"For complex j j , the equilibrium structure probability of any secondary structure s\\in\\Gamma(\\phi_j) s\\in\\Gamma(\\phi_j) treating strands with the same sequence as indistinguishable is denoted \\begin{align} p(\\phi_j,s)= e^{-\\Delta G(\\phi_j,s)/kT}/Q(\\phi_j). \\end{align}","title":"Equilibrium structure probability"},{"location":"definitions/#boltzmann-sampled-structures","text":"For complex j j , a set of J J secondary structures Boltzmann-sampled from ensemble \\Gamma(\\phi_j) \\Gamma(\\phi_j) treating strands with the same sequence as indistinguishable is denoted \\begin{align} \\Gamma_\\mathrm{sample}(\\phi,J) \\in \\Gamma(\\phi) \\end{align} \\begin{align} \\Gamma_\\mathrm{sample}(\\phi,J) \\in \\Gamma(\\phi) \\end{align}","title":"Boltzmann-sampled structures"},{"location":"definitions/#equilibrium-base-pairing-probabilities","text":"For complex j j , the base-pairing probability matrix \\overline P(\\phi_j) \\overline P(\\phi_j) has entries \\overline P^{a,b}(\\phi_j)\\in[0,1] \\overline P^{a,b}(\\phi_j)\\in[0,1] corresponding to the probability \\begin{align} \\overline P^{a,b}(\\phi_j) = \\sum_{s\\in\\overline\\Gamma(\\phi_j)}\\overline p(\\phi,s)S^{a,b}(s) \\end{align} \\begin{align} \\overline P^{a,b}(\\phi_j) = \\sum_{s\\in\\overline\\Gamma(\\phi_j)}\\overline p(\\phi,s)S^{a,b}(s) \\end{align} that base pair a\\cdot b a\\cdot b forms at equilibrium within ensemble \\overline\\Gamma(\\phi_j) \\overline\\Gamma(\\phi_j) , treating all strands as distinct. Here, S(s) S(s) is the structure matrix and \\overline p(s) \\overline p(s) the equilibrium probability of structure s\\in\\overline\\Gamma(\\phi_j) s\\in\\overline\\Gamma(\\phi_j) , treating all strands as distinct. Abusing notation, the entry \\overline P^{i,i}(\\phi) \\in [0,1] \\overline P^{i,i}(\\phi) \\in [0,1] denotes the equilibrium probability that base i i is unpaired over ensemble \\overline\\Gamma(\\phi) \\overline\\Gamma(\\phi) . Hence \\overline P(\\phi) \\overline P(\\phi) is symmetric matrix with row and column sums of 1.","title":"Equilibrium base-pairing probabilities"},{"location":"definitions/#mfe-proxy-structure","text":"For complex j j , the free energy of the minimum free energy (MFE) stacking state s_\\mathrm{MFE}^\\shortparallel(\\phi) \\in\\overline\\Gamma^\\shortparallel(\\phi) s_\\mathrm{MFE}^\\shortparallel(\\phi) \\in\\overline\\Gamma^\\shortparallel(\\phi) treating all strands as distinct is denoted \\begin{align} \\overline{\\Delta G}(\\phi_j,s^\\shortparallel_{\\rm MFE}) \\equiv \\min_{s^\\shortparallel\\in\\overline\\Gamma^\\shortparallel(\\phi_j)} \\overline{\\Delta G}(\\phi_j,s^\\shortparallel). \\end{align} \\begin{align} \\overline{\\Delta G}(\\phi_j,s^\\shortparallel_{\\rm MFE}) \\equiv \\min_{s^\\shortparallel\\in\\overline\\Gamma^\\shortparallel(\\phi_j)} \\overline{\\Delta G}(\\phi_j,s^\\shortparallel). \\end{align} The corresponding MFE proxy structure is \\begin{align} s_\\mathrm{MFE'} \\equiv \\{s\\in\\overline\\Gamma(\\phi_j) | s^\\shortparallel_\\mathrm{MFE}\\!\\in\\! s, s^\\shortparallel_\\mathrm{MFE}(\\phi_j) = \\arg \\min_{s^\\shortparallel\\in\\overline\\Gamma^\\shortparallel(\\phi_j)} \\overline{\\Delta G}(\\phi_j,s^\\shortparallel)\\}, \\end{align} \\begin{align} s_\\mathrm{MFE'} \\equiv \\{s\\in\\overline\\Gamma(\\phi_j) | s^\\shortparallel_\\mathrm{MFE}\\!\\in\\! s, s^\\shortparallel_\\mathrm{MFE}(\\phi_j) = \\arg \\min_{s^\\shortparallel\\in\\overline\\Gamma^\\shortparallel(\\phi_j)} \\overline{\\Delta G}(\\phi_j,s^\\shortparallel)\\}, \\end{align} defined as the secondary structure containing the MFE stacking state within its subensemble. The free energy of the MFE proxy structure is \\begin{align} \\overline{\\Delta G}(\\phi,s_\\mathrm{MFE\u2019}). \\end{align} There may be more than one MFE stacking state, each corresponding to the same or different MFE proxy structures.","title":"MFE proxy structure"},{"location":"definitions/#suboptimal-proxy-structures","text":"For complex j j , the set of suboptimal proxy secondary structures with stacking states within a specified \\Delta G_\\mathrm{gap}\\ge 0 \\Delta G_\\mathrm{gap}\\ge 0 of the MFE stacking state is denoted \\begin{align} \\overline\\Gamma_{\\rm subopt}(\\phi_j,\\Delta G_{\\rm gap}) = \\{s\\in\\overline\\Gamma(\\phi_j) | s^\\shortparallel\\!\\in\\! s, \\overline{\\Delta G}(\\phi_j,s^\\shortparallel) \\le \\overline{\\Delta G}(\\phi_j,s^\\shortparallel_{\\rm MFE}) + \\Delta G_{\\rm gap}\\}. \\end{align} \\begin{align} \\overline\\Gamma_{\\rm subopt}(\\phi_j,\\Delta G_{\\rm gap}) = \\{s\\in\\overline\\Gamma(\\phi_j) | s^\\shortparallel\\!\\in\\! s, \\overline{\\Delta G}(\\phi_j,s^\\shortparallel) \\le \\overline{\\Delta G}(\\phi_j,s^\\shortparallel_{\\rm MFE}) + \\Delta G_{\\rm gap}\\}. \\end{align}","title":"Suboptimal proxy structures"},{"location":"definitions/#complex-ensemble-defect","text":"For complex j j with target structure s_j s_j , the dimensional complex ensemble defect \\begin{align} n(\\phi_j,s_j) & = |\\phi_j| - \\sum_{\\begin{array}{c} 1 \\leq a \\leq |\\phi_j|,\\ 1 \\leq b \\leq |\\phi_j| \\end{array}} \\overline P^{a, b}(\\phi_j) S^{a,b}(s_j), \\end{align} quantifies the equilibrium number of incorrectly paired nucleotides over the ensemble \\overline\\Gamma(\\phi_j) \\overline\\Gamma(\\phi_j) relative to s_j s_j [ Dirks04 , Zadeh11b ]. Here, \\overline P(\\phi_j) \\overline P(\\phi_j) is the equilibrium base-pairing probability matrix and S(s_j) S(s_j) is the target structure matrix for s_j s_j . The normalized complex ensemble defect is then denoted \\begin{align} {\\mathcal N}_j \\equiv n(\\phi_j,s_j)/|\\phi_j| ~~~\\in (0,1) \\end{align} \\begin{align} {\\mathcal N}_j \\equiv n(\\phi_j,s_j)/|\\phi_j| ~~~\\in (0,1) \\end{align} representing the equilibrium fraction of incorrectly paired nucleotides evaluated over the ensemble of complex j j relative to target structure s_j s_j . For a set of complexes \\Psi \\Psi , the normalized complex ensemble defect can be generalized to a multi-complex ensemble defect \\begin{align} {{\\mathcal N}} ~\\equiv ~\\frac{1}{|\\Psi|}\\sum_{j\\in\\Psi} {\\mathcal N_j} ~~~\\in(0,1) \\end{align} quantifying the average equilibrium fraction of incorrectly paired nucleotides over the complexes j\\in\\Psi j\\in\\Psi . As {\\mathcal N}_j {\\mathcal N}_j approaches zero, the complex j j is dominated by its target structure, s_{j} s_{j} .","title":"Complex ensemble defect"},{"location":"definitions/#complex-ensemble-size","text":"For complex j j , the number of secondary structures in the complex ensemble, treating all strands as distinct, is denoted: \\begin{align} |\\overline\\Gamma(\\phi_j)|. \\end{align} The corresponding number of stacking states is denoted \\begin{align} |\\overline\\Gamma^\\shortparallel(\\phi_j)|. \\end{align}","title":"Complex ensemble size"},{"location":"definitions/#equilibrium-complex-concentrations","text":"For the set of complexes \\Psi \\Psi in the test tube ensemble, the set of equilibrium complex concentrations is denoted \\begin{align} x_\\Psi \\equiv x_j~~~~~~ \\forall j\\in\\Psi, \\end{align} These concentrations are the unique solution to the strictly convex optimization problem [ Dirks07 ]: \\begin{align} & \\min_{x_{\\Psi}} \\sum_{j\\in\\Psi} x_j(\\log x_j - \\log Q_j - 1) \\\\[6pt] & \\mathrm{subject~to~~~~} \\sum_{j \\in \\Psi}A_{i,c} \\,x_j = x_i^0 ~~~~~~ \\forall i\\in\\Psi^0, \\end{align} \\begin{align} & \\min_{x_{\\Psi}} \\sum_{j\\in\\Psi} x_j(\\log x_j - \\log Q_j - 1) \\\\[6pt] & \\mathrm{subject~to~~~~} \\sum_{j \\in \\Psi}A_{i,c} \\,x_j = x_i^0 ~~~~~~ \\forall i\\in\\Psi^0, \\end{align} expressed in terms of the previously calculated set of partition functions Q_\\Psi Q_\\Psi . Here, the constraints impose conservation of mass: A A is the stoichiometry matrix such that A_{i,j} A_{i,j} is the number of strands of type i i in complex j j , and x^0_i x^0_i is the total concentration of strand i i present in the test tube. Based on dimensional analysis [ Dirks07 ], the convex optimization problem is formulated in terms of mole fractions, but for convenience, NUPACK accepts molar strand concentrations [i]^0 = x_i^0 \\rho_\\mathrm{H_2O} [i]^0 = x_i^0 \\rho_\\mathrm{H_2O} as inputs and returns molar complex concentrations [j] = x_j\\rho_\\mathrm{H_2O} [j] = x_j\\rho_\\mathrm{H_2O} as outputs, where \\rho_\\mathrm{H_2O} \\rho_\\mathrm{H_2O} is the molarity of water. Hence, the user specifies the set of molar strand concentrations [i]^0~~\\forall i\\in\\Psi^0 [i]^0~~\\forall i\\in\\Psi^0 and NUPACK calculates the set of molar complex concentrations [j]~~ \\forall j\\in\\Psi [j]~~ \\forall j\\in\\Psi .","title":"Equilibrium complex concentrations"},{"location":"definitions/#test-tube-fraction-of-bases-unpaired","text":"The equilibrium fraction of bases that are unpaired in the test tube, taking into account the equilibrium concentration and pair probatility matrix for each complex in the test tube ensemble.","title":"Test tube fraction of bases unpaired"},{"location":"definitions/#test-tube-ensemble-pair-fractions","text":"For the test tube ensemble, the ensemble pair fraction \\begin{align} f_A(a_A\\cdot b_B) \\end{align} \\begin{align} f_A(a_A\\cdot b_B) \\end{align} denotes the fraction of A strands that form base pair a_A\\cdot b_B a_A\\cdot b_B . Correspondingly, \\begin{align} f_B(a_A\\cdot b_B) \\end{align} \\begin{align} f_B(a_A\\cdot b_B) \\end{align} denotes the fraction of B strands that form base pair a_A\\cdot b_B a_A\\cdot b_B . These base-pairing observables depend on the set of equilibrium concentrations x_\\Psi x_\\Psi and the set of base-pairing probability matrices \\overline P_\\Psi \\overline P_\\Psi . The number of distinct bases in the test tube is: \\begin{align} N_{\\rm distinct}\\equiv \\sum_{i=1}^{|\\Psi^0|} N_i \\end{align} \\begin{align} N_{\\rm distinct}\\equiv \\sum_{i=1}^{|\\Psi^0|} N_i \\end{align} representing the total number of bases in all |\\Psi^0| |\\Psi^0| strand species. Numbering the distinct bases from 1 to N_{\\rm distinct} N_{\\rm distinct} , the ensemble pair fractions, f_A(a_A\\cdot b_B) f_A(a_A\\cdot b_B) , are then stored as an (asymmetric) N_{\\rm distinct}\\times N_{\\rm distinct} N_{\\rm distinct}\\times N_{\\rm distinct} matrix. Abusing notation, the entry f_A^{a_A,a_A} \\in [0,1] f_A^{a_A,a_A} \\in [0,1] denotes the equilibrium fraction of base a a on strand A A that is unpaired in the test tube ensemble. Hence, the matrix of test tube ensemble pair fractions is asymmetric with row and column sums of 1.","title":"Test tube ensemble pair fractions"},{"location":"definitions/#test-tube-ensemble-defect","text":"Consider test tube h h containing a set of desired on-target complexes , \\Psi_h^{\\rm on} \\Psi_h^{\\rm on} , and a set of undesired off-target complexes , \\Psi_h^{\\rm off} \\Psi_h^{\\rm off} . The set of complexes in the test tube is then: \\begin{align} \\Psi_h = \\Psi_h^{\\rm on} \\cup \\Psi_h^{\\rm off}. \\end{align} \\begin{align} \\Psi_h = \\Psi_h^{\\rm on} \\cup \\Psi_h^{\\rm off}. \\end{align} Let each on-target complex, j\\in\\Psi_h^{\\rm on} j\\in\\Psi_h^{\\rm on} , have a target secondary structure, s_j s_j , and a target concentration, y_{h,j} y_{h,j} . Let each off-target complex, j\\in\\Psi_h^{\\rm off} j\\in\\Psi_h^{\\rm off} , have a vanishing target concentration ( y_{h,j} = 0 y_{h,j} = 0 ) and no target structure ( s_j = \\emptyset s_j = \\emptyset ). The dimensional test tube ensemble defect, \\begin{align} C(\\phi_{\\Psi_h}, s_{\\Psi_h}, y_{h,\\Psi_h}) = \\sum_{j\\in\\Psi^{\\rm on}_h} \\Bigl[ n(\\phi_{j},s_{j})\\min (x_{h,j},y_{h,j}) + |\\phi_{j}|\\max(y_{h,j}-x_{h,j},0)\\Bigr] \\end{align} \\begin{align} C(\\phi_{\\Psi_h}, s_{\\Psi_h}, y_{h,\\Psi_h}) = \\sum_{j\\in\\Psi^{\\rm on}_h} \\Bigl[ n(\\phi_{j},s_{j})\\min (x_{h,j},y_{h,j}) + |\\phi_{j}|\\max(y_{h,j}-x_{h,j},0)\\Bigr] \\end{align} quantifies the equilibrium concentration of incorrectly paired nucleotides over the ensemble of test tube h h [ Wolfe15 ]. Here, x_{h,j} x_{h,j} is the equilibrium concentration of complex j j in tube h h . For each on-target complex, j\\in\\Psi^{\\rm on}_h j\\in\\Psi^{\\rm on}_h , the first term in the sum represents the structural defect , quantifying the concentration of nucleotides that are in an incorrect base-pairing state within the ensemble of complex j j , and the second term in the sum represents the concentration defect , quantifying the concentration of nucleotides that are in an incorrect base-pairing state because there is a deficiency in the concentration of complex j j . For each off-target complex, j\\in\\Psi^{\\rm off}_h j\\in\\Psi^{\\rm off}_h , the structural and concentration defects are identically zero, since y_{h,j}=0 y_{h,j}=0 . This does not mean that the defects associated with off-targets are ignored. By conservation of mass, non-zero off-target concentrations imply deficiencies in on-target concentrations, and these concentration defects are quantified by the equation above [ Wolfe15 ]. The normalized test tube ensemble defect is then denoted \\begin{align} {\\mathcal M}_h\\equiv C_h/y^{\\rm nt}_h \\in (0,1) \\end{align} representing the equilibrium fraction of incorrectly paired nucleotides in tube h h . Here, \\begin{align} y^{\\rm nt}_h \\equiv \\sum_{j\\in\\Psi^{\\rm on}_h} |\\phi_j|y_{h,j} \\end{align} \\begin{align} y^{\\rm nt}_h \\equiv \\sum_{j\\in\\Psi^{\\rm on}_h} |\\phi_j|y_{h,j} \\end{align} is the total concentration of nucleotides in tube h h . As {\\mathcal M}_h {\\mathcal M}_h approaches zero, each on-target complex, j\\in \\Psi^{\\rm on}_h j\\in \\Psi^{\\rm on}_h , approaches its target concentration, y_{h,j} y_{h,j} , and is dominated by its target structure, s_{j} s_{j} , and each off-target complex, j\\in\\Psi^{\\rm off}_h j\\in\\Psi^{\\rm off}_h , forms with vanishing target concentration. For a set of test tubes \\Omega \\Omega , the test tube ensemble defect can be generalized to a multi-tube ensemble defect \\begin{align} {\\mathcal M} \\equiv \\frac{1}{\\lvert \\Omega \\rvert} \\sum_{h \\in \\Omega} {\\mathcal M}_h ~~~\\in (0,1) \\end{align} \\begin{align} {\\mathcal M} \\equiv \\frac{1}{\\lvert \\Omega \\rvert} \\sum_{h \\in \\Omega} {\\mathcal M}_h ~~~\\in (0,1) \\end{align} quantifying the average equilibrium fraction of incorrectly paired nucleotides over the test tubes h\\in\\Omega h\\in\\Omega .","title":"Test tube ensemble defect"},{"location":"definitions/#design-formulation","text":"NUPACK provides a framework for designing the sequences of multiple nucleic acid strands intended to hybridize in solution via a prescribed reaction pathway. Sequence design is formulated as a multistate optimization problem using a set of target test tubes to represent reactant, intermediate, and product states of the system, as well as to model crosstalk between components. Each target test tube contains a set of desired on-target complexes, each with a target secondary structure and target concentration, and a set of undesired off-target complexes, each with vanishing target concentration. Design quality is quantified by the multi-tube ensemble defect , \\mathcal{M} \\mathcal{M} , representing the average equilibrium fraction of incorrectly paired nucleotides evaluated over the design ensemble [ Wolfe17 ]. Optimization of the sequences so as to reduce \\mathcal{M} \\mathcal{M} below a user-specified stop condition implements both a positive design paradigm, explicitly designing for on-pathway elementary steps, and a negative design paradigm, explicitly designing against off-pathway crosstalk. Sequence design is performed subject to both hard constraints (including composition constraints and biological constraints) and soft constraints (including sequence symmetry minimization and toehold free energy equalization).","title":"Design formulation"},{"location":"definitions/#complex-design-vs-test-tube-design","text":"We recommend using the multi-tube design ensemble instead of the multi-complex ensemble because test tube design provides significant advantages over complex design [ Wolfe15 , Wolfe17 ]. Example Figure: The advantages of test tube design over complex design. Top: Complex design. Sequence design formulated in the context of a complex (left) ensures that at equilibrium the target structure dominates the structural ensemble of the complex (center). Unfortunately, subsequent test tube analysis reveals that the desired on-target complex occurs at negligible concentration relative to other undesired off-target complexes (right). With complex design, neither the concentration of the desired on-target complex, nor the concentrations of undesired off-target complexes are considered. As a result, sequences that are successfully optimized to predominantly adopt a target secondary structure in the context of an on-target complex, may nonetheless fail to ensure that this complex forms at appreciable concentration when the strands are introduced into a test tube. Bottom: Test tube design. Sequence design formulated in the context of a test tube (left) ensures that at equilibrium the desired on-target complex is dominated by its target structure and forms at approximately its target concentration, and that undesired off-target complexes form at negligible concentrations (center). Subsequent test tube analysis (right) provides no new information and no unpleasant surprises since the design and analysis ensembles are identical. Note that the multi-tube ensemble encompases the complex ensemble, test tube ensemble, and multi-complex ensemble as subsidiary special cases [ Wolfe17 ].","title":"Complex design vs test tube design"},{"location":"definitions/#reaction-pathways","text":"Consider a set of nucleic acid molecules intended to execute a prescribed hybridization cascade [ Wolfe17 ]. For example, the reaction pathway below describes scRNAs that upon binding to input X, perform shape and sequence transduction to form a Dicer substrate targeting an independent output Y for silencing [ Hochrein13 ]. A reaction pathway specifies the elementary steps (each a self-assembly or disassembly operation in which complexes form or break) by which the molecules are intended to interact, the desired secondary structure for each on-pathway complex, and the complementarity relationships between sequence domains in the molecules. In the reaction pathway below there are two elementary steps (Step 1: X + A \\cdot \\cdot B \\rightarrow \\rightarrow X \\cdot \\cdot A + B, Step 2: B + C \\rightarrow \\rightarrow B \\cdot \\cdot C) involving six on-pathway complexes (X, A \\cdot \\cdot B, X \\cdot \\cdot A, B, C, B \\cdot \\cdot C) and numerous sequence domains ( a* complementary to a , b* complementary to b , and so on). Figure: Reaction pathway schematic. Conditional Dicer substrate formation via shape and sequence transduction with small conditional RNAs (scRNAs) [ Hochrein13 ]. scRNA A \\cdot \\cdot B detects input X (comprising sequence a-b-c ), leading to production of Dicer substrate B \\cdot \\cdot C (targeting independent sequence w-x-y-z ). Step 1: X displaces A from B via toehold-mediated 3-way branch migration and spontaneous dissociation. Step 2: B assembles with C via loop/toehold nucleation and 3-way branch migration to form Dicer substrate B \\cdot \\cdot C. See [ Wolfe17 ] for additional reaction pathway case studies. In addition to specifying a set of desired on-pathway elementary steps, each reaction pathway also implicitly specifies a much larger set of off-pathway interactions, corresponding to undesired crosstalk between components within the pathway or with components from other unrelated reaction pathways. To perform sequence design for reaction pathway engineering, we formulate a multistate optimization problem to explicitly design for on-pathway elementary steps (a positive design paradigm) and against off-pathway crosstalk (a negative design paradigm) [ Wolfe17 ].","title":"Reaction pathways"},{"location":"definitions/#multi-tube-design-ensemble","text":"A multi-tube design problem is specified as a set of target test tubes , \\Omega \\Omega [ Wolfe17 ]. Each tube, h \\in \\Omega h \\in \\Omega , contains a set of desired on-target complexes , \\Psi_h^{\\rm on} \\Psi_h^{\\rm on} , and a set of undesired off-target complexes , \\Psi_h^{\\rm off} \\Psi_h^{\\rm off} . For each on-target complex, j\\in\\Psi_h^{\\rm on} j\\in\\Psi_h^{\\rm on} , the user specifies a target secondary structure, s_{j} s_{j} , and a target concentration, y_{h, j} y_{h, j} . For each off-target complex, j\\in\\Psi_h^{\\rm off} j\\in\\Psi_h^{\\rm off} , the target concentration is vanishing ( y_{h,j}=0 y_{h,j}=0 ) and there is no target structure (s_{j}=\\emptyset) (s_{j}=\\emptyset) . The set of complexes in tube h h is then \\Psi_h \\equiv \\Psi^{\\rm on}_h \\cup \\Psi^{\\rm off}_h \\Psi_h \\equiv \\Psi^{\\rm on}_h \\cup \\Psi^{\\rm off}_h and the set of all complexes in multistate test tube ensemble \\Omega \\Omega is \\Psi \\equiv \\cup_{h\\in\\Omega} \\Psi_h \\Psi \\equiv \\cup_{h\\in\\Omega} \\Psi_h . Let \\begin{align} \\phi_{\\Psi} \\equiv \\phi_j ~~~\\forall j\\in \\Psi \\end{align} denote the set of sequences for the complexes in \\Psi \\Psi . Warning Note that each on-target complex has exactly one target secondary structure. Consider specification of the multistate test tube ensemble, \\Omega \\Omega , for the design of N N orthogonal systems for a reaction pathway of M M elementary steps. One elementary step tube is specified for each step m=0,\\dots,M m=0,\\dots,M for each system n=1,\\dots,N n=1,\\dots,N (treating formation of the initial reactants as a precursor ``Step 0\u2019\u2018). Additionally, a single global crosstalk tube is specified to minimize off-pathway interactions between the reactive species generated during all elementary steps of all systems. The total number of target test tubes is then |\\Omega| = N*(M+1) + 1 |\\Omega| = N*(M+1) + 1 .","title":"Multi-tube design ensemble"},{"location":"definitions/#target-test-tubes","text":"The figure below depicts target test tubes for the reaction pathway depicted above. There are three elementary step tubes, each containing on-target complexes corresponding to the products of the corresponding step: the Reactants tube (Step 0) contains on-targets X, A \\cdot \\cdot B, and C; the Step 1 tube contains on-targets X \\cdot \\cdot A and B; the Step 2 tube contains on-target B \\cdot \\cdot C. Each elementary step tube contains a set of on-target complexes (each with a target secondary structure and target concentration), corresponding to the on-pathway hybridization products for a given step, and a set of undesired off-target complexes (each with vanishing target concentration), corresponding to on-pathway reactants and off-pathway hybridization crosstalk for a given step. Hence, these elementary step tubes design for full conversion of cognate reactants into cognate products and against local crosstalk between these same reactants. Figure: Target test tubes. Left: Elementary step tubes. Reactants tube (Step 0): target X and scRNAs A \\cdot \\cdot B and C. Step 1 tube: X \\cdot \\cdot A and B. Step 2 tube: Dicer substrate B \\cdot \\cdot C. Each target test tube contains the depicted on-target complexes corresponding to the on-pathway products for a given step (each with the depicted target secondary structure and a target concentration of 10 nM) as well as off-target complexes (not depicted) corresponding to on-pathway reactants and off-pathway crosstalk for a given step. To design N N orthogonal systems, there are three elementary step tubes for each system n=1,\\dots,N n=1,\\dots,N . Right: Global crosstalk tube. Contains the depicted on-target complexes corresponding to reactive species generated during Steps 0, 1, 2 as well as off-target complexes (not depicted) corresponding to off-pathway interactions between these reactive species. To design N N orthogonal systems, the global crosstalk tube contains a set of on-targets and off-targets for each system n=1,\\dots,N n=1,\\dots,N . To simultaneously design N N orthogonal systems, three elementary step tubes of the type shown above (left) are specified for each system. Furthermore, to design against off-pathway interactions within and between systems, a single global crosstalk tube is specified (right). In the global crosstalk tube, the on-target complexes correspond to all reactive species generated during all elementary steps ( m=0,1,2 m=0,1,2 ) for all systems ( n=1,\\dots,N n=1,\\dots,N ); the off-target complexes correspond to non-cognate interactions between these reactive species (see Supplementary Section S2.2 of [ Wolfe17 ] for details on defining reactive species for a given reaction pathway). Crucially, the global crosstalk tube ensemble omits the cognate products that the reactive species are intended to form (they appear as neither on-targets nor off-targets). Hence, all reactive species in the global crosstalk tube are forced to either perform no reaction (remaining as desired on-targets) or undergo a crosstalk reaction (forming undesired off-targets), providing the basis for minimization of global crosstalk during sequence optimization. To design 8 orthogonal systems for this reaction pathway, the total number of target test tubes is then |\\Omega| = 8*3 + 1 = 25 |\\Omega| = 8*3 + 1 = 25 . See [ Wolfe17 ] Supplementary Information Section S2.2 for a general description of how to specify target test tubes for a given reaction pathway, as well as a number of illustrative case studies. Note Note that each target test tube isolates a different subset of the system components in local equilibrium, enabling optimization of kinetically significant states that would appear insignificant if all components were allowed to interact in a single ensemble. For example, the Step 1 tube simultaneously optimizes for high-yield production of unstructured intermediate B and against appreciable formation of off-target dimer B \\cdot \\cdot B, promoting rapid nucleation of the unstructured toehold in B with the loop of hairpin C during the next step of the reaction pathway. Note Note that for a tube containing a given set of system components, the cognate products of their interactions can be excluded from the ensemble (appearing as neither on-targets nor off-targets), enabling optimization for high-yield well-structured reactants and against crosstalk. For example, the Reactants tube excludes the cognate product of Step 1 from the ensemble in order to optimize formation of initial reactants X, A \\cdot \\cdot B, and C and discourage competing crosstalk interactions (e.g., X \\cdot \\cdot X, A \\cdot \\cdot A, X \\cdot \\cdot C).","title":"Target test tubes"},{"location":"definitions/#design-objective-function","text":"The design objective function is the multi-tube ensemble defect [ Wolfe17 ], \\begin{align} \\mathcal{M}\\in[0,1], \\end{align} \\begin{align} \\mathcal{M}\\in[0,1], \\end{align} representing the average equilibrium fraction of incorrectly paired nucleotides over the multitube ensemble, \\Omega \\Omega .","title":"Design objective function"},{"location":"definitions/#defect-weights","text":"To prioritize or de-prioritize design quality for a portion of the design ensemble, the defect-weighted objective function, \\mathcal{M}_\\mathcal{W} \\mathcal{M}_\\mathcal{W} , incorporates user-specified defect weights for any tube, complex, strand, or domain. With the default value of unity for all weights, \\mathcal{M}_\\mathcal{W} \\mathcal{M}_\\mathcal{W} is simply the multi-tube ensemble defect , \\mathcal{M} \\mathcal{M} . With custom defect weights in the range [0,\\infty) [0,\\infty) , the physical meaning of the objective function is distorted in the service of adjusting design priorities. Increasing the weight for a tube, complex, strand or domain will lead to a corresponding increase in the allocation of effort to designing this entity, typically leading to a corresponding reduction in the defect contribution of the entity. Likewise, decreasing the weight for a tube, complex, strand or domain will lead to a corresponding decrease in the allocation of effort to designing this entity, typically leading to a corresponding increase in the defect contribution of the entity.","title":"Defect weights"},{"location":"definitions/#hard-constraints","text":"Sequence design can be performed subject to hard constraints that prohibit sequences violating the constraints. The following types of hard sequence constraints can be imposed [ Wolfe17 ]: Assignment Constraint: Nucleotide a a is constrained to have a specified sequence (e.g., A , C , G , U or any of the degenerate nucleotide codes . To specify an assignment constraint, specify a domain . Match Constraint: Two nucleotides a a and b b are constrained to be identical (e.g., if a strand species appears in more than one on-target complex, corresponding nucleotides are constrained to have the same sequence in all complexes). Complementarity Constraint: Two nucleotides a a and b b are constrained to be Watson\u2013Crick complements, or optionally for RNA, to be Watson-Crick or wobble complements. Similarity Constraint: Consecutive nucleotides a,\\dots,b a,\\dots,b are constrained to be similar to a specified sequence of length n=b-a+1 n=b-a+1 to a specified degree (e.g., a desired GC content can be achieved by constraining the fraction of \u2018S\u2019 nucleotides to fall in the range [f^{\\rm min}, f^{\\rm max}] [f^{\\rm min}, f^{\\rm max}] ). Library Constraint: Consecutive nucleotides a,\\dots,b a,\\dots,b are constrained to be selected from a specified library of m m sequences of length n=b-a+1 n=b-a+1 (e.g., a library of toehold sequences or a library of codons). Window Constraint: Consecutive nucleotides a,\\dots,b a,\\dots,b are constrained to be a subsequence of a specified source sequence of length n\\ge b-a+1 n\\ge b-a+1 (e.g., the source sequence is an mRNA), or more generally, a subsequence of one of multiple specified source sequences. Pattern Prevention Constraint: Consecutive nucleotides a,\\dots,b a,\\dots,b are constrained not to contain a specified subsequence of length n\\le b-a+1 n\\le b-a+1 (e.g., prevention of GGGG , which is prone to forming G -quadruplexes that are not accounted for in nearest-neighbor free energy models). Diversity Constraint: Consecutive nucleotides a,\\dots,b a,\\dots,b are constrained to have a specified degree of sequence diversity (e.g., every subsequence of length 4 should have at least 2 nucleotide types). Let \\mathcal R \\mathcal R denote the user-specified set of hard constraints for a design problem.","title":"Hard constraints"},{"location":"definitions/#soft-constraints","text":"As an alternative to hard constraints that prohibit constraint violations, soft constraints define auxiliary objective functions that penalize suboptimal sequences during the design process [ Porubsky20 ]: \\begin{align} w_k f_k(\\phi_\\Psi) \\end{align} Here, f_k(\\phi_\\Psi)\\in[0,1] f_k(\\phi_\\Psi)\\in[0,1] is the penalty function for soft constraint k k and w_k\\in [0,\\infty) w_k\\in [0,\\infty) (default: 1) is the corresponding user-specified weight. Soft constraints can reduce design cost relative to the corresponding hard constraint by making it easier for the optimization process to identify candidate sequence mutations. Soft constraints can also increase flexibility by enabling specification of new design goals (e.g., designing a set of toeholds to have comparable binding strength) for which there is no hard constraint analog. The following types of soft constraints can be imposed: Similarity: Penalize consecutive nucleotides a,\\dots,b a,\\dots,b if they fail to be similar to a specified sequence of length n=b-a+1 n=b-a+1 to a specified degree (e.g., to drive the fraction of nucleotides matching an mRNA sequence to fall in the range [f^{\\rm min}, f^{\\rm max}] [f^{\\rm min}, f^{\\rm max}] ). Pattern prevention: Penalize consecutive nucleotides a,\\dots,b a,\\dots,b if they contain a specified subsequence of length n\\le b-a+1 n\\le b-a+1 (e.g., to discourage use of GGGG , which is prone to forming G -quadruplexes that are not accounted for in nearest-neighbor free energy models). Sequence symmetry minimization: Penalize consecutive nucleotides a,\\dots,b a,\\dots,b of a specified word length , L_w L_w , if [ Seeman82 ]: 1) a word appears in more than one location in the design (unless sequence domains are explicitly constrained to be identical), 2) a word and its reverse complement both appear in the design but they are specified in a target structure not to form a duplex, 3) a word that appears in the design is self-complementary. Sequence symmetry minimization is a negative design heuristic [ Dirks04 ] that destabilizes formation of off-target structures by ensuring they cannot form without mismatches in any subsequence of the word length. Energy match: Consider a set of duplexes (e.g., toeholds and toehold complements) that are intended to have structure free energies that match each other or a specified reference free energy. This soft constraint will penalize duplexes to the extent they deviate from the desired structure free energy. Let \\mathcal S \\mathcal S denote the user-specified set of soft constraints for a design problem.","title":"Soft constraints"},{"location":"definitions/#constrained-multi-tube-design-problem","text":"To design a set of sequences, \\Phi_\\Psi \\Phi_\\Psi , for a multi-tube ensemble , \\Omega \\Omega , subject to user-specified hard constraints \\mathcal{R} \\mathcal{R} and soft constraints \\mathcal{S} \\mathcal{S} , the constrained multi-tube design problem is: \\begin{align} \\min_{\\phi_\\Psi}\\left[\\mathcal{M}_{\\mathcal{W}} ~~~+~~~\\sum_{k\\in\\mathcal{S}} w_kf_k(\\phi_\\Psi)\\right] ~~~~\\mathrm{subject~to} ~~~~\\mathcal{R}, \\end{align} \\begin{align} \\min_{\\phi_\\Psi}\\left[\\mathcal{M}_{\\mathcal{W}} ~~~+~~~\\sum_{k\\in\\mathcal{S}} w_kf_k(\\phi_\\Psi)\\right] ~~~~\\mathrm{subject~to} ~~~~\\mathcal{R}, \\end{align} where \\mathcal{M}_\\mathcal{W} \\mathcal{M}_\\mathcal{W} is the multi-tube ensemble defect including user-specified defect weights \\mathcal{W} \\mathcal{W} . The sequence design algorithm seeks to iteratively reduce the augmented objective function (weighted ensemble defect plus weighted soft constraints) below the stop condition \\begin{align} \\left[\\mathcal{M}_{\\mathcal{W}} ~~~+~~~\\sum_{k\\in\\mathcal{S}} w_kf_k(\\phi_\\Psi)\\right] \\le f_\\textrm{stop} \\end{align} \\begin{align} \\left[\\mathcal{M}_{\\mathcal{W}} ~~~+~~~\\sum_{k\\in\\mathcal{S}} w_kf_k(\\phi_\\Psi)\\right] \\le f_\\textrm{stop} \\end{align} for user-specified f_\\textrm{stop} \\in (0,1) f_\\textrm{stop} \\in (0,1) while satisfying the hard constraints in \\mathcal{R} \\mathcal{R} . Zadeh11a Zadeh J.N., Steenberg C.D., Bois J.S., Wolfe B.R., Pierce M.B., Khan A.R., Dirks R.M., Pierce N.A.: NUPACK: Analysis and Design of Nucleic Acid Systems . J. Comput. Chem.. 32 , (2011) Zadeh10c Zadeh J.N.: Algorithms for Nucleic Acid Sequence Design . (2010) Dirks07 Dirks R.M., Bois J.S., Schaeffer J.M., Winfree E., Pierce N.A.: Thermodynamic Analysis of Interacting Nucleic Acid Strands . SIAM Rev.. 49 , (2007) Zadeh11b Zadeh J.N., Wolfe B.R., Pierce N.A.: Nucleic Acid Sequence Design via Efficient Ensemble Defect Optimization . J. Comput. Chem.. 32 , (2011) Fornace20 Fornace M.E., Porubsky N.J., Pierce N.A.: A Unified Dynamic Programming Framework for the Analysis of Interacting Nucleic Acid Strands: Enhanced Models, Scalability, and Speed . ACS Synth. Biol.. (2020) Santalucia98 SantaLucia J.: A Unified View of Polymer, Dumbbell, and Oligonucleotide DNA Nearest-Neighbor Thermodynamics . Proc. Natl. Acad. Sci. USA. 95 , (1998) Xia98 Xia T., SantaLucia J., Burkard M., Kierzek R., Schroeder S., Jiao X., Cox C., Turner D.: Thermodynamic Parameters for an Expanded Nearest-Neighbor Model for Formation of RNA Duplexes with Watson-Crick Base Pairs . Biochemistry. 37 , (1998) Mathews99 Mathews D.H., Sabina J., Zuker M., Turner D.H.: Expanded Sequence Dependence of Thermodynamic Parameters Improves Prediction of RNA Secondary Structure . J. Mol. Biol.. 288 , (1999) Zuker03 Zuker M.: Mfold Web Server for Nucleic Acid Folding and Hybridization Prediction . Nucleic Acids Res.. 31 , (2003) Lu06 Lu Z.J., Turner D.H., Mathews D.H.: A Set of Nearest Neighbor Parameters for Predicting the Enthalpy Change of RNA Secondary Structure Formation . Nucleic acids research. 34 , (2006) Turner10 Turner D.H., Mathews D.H.: NNDB: The Nearest Neighbor Parameter Database for Predicting Stability of Nucleic Acid Secondary Structure . Nucleic Acids Res.. 38 , (2010) Bloomfield00 Bloomfield V., Crothers D., Tinoco I.: Nucleic Acids: Structures, Properties, and Functions . (2000) Serra95 Serra M.J., Turner D.H.: Predicting Thermodynamic Properties of RNA . Methods Enzymol.. 259 , (1995) Santalucia04 SantaLucia J., Hicks D.: The thermodynamics of DNA structural motifs . Annu. Rev. Biophys. Biomol. Struct.. 33 , (2004) Peyret00 Peyret N.: Prediction of Nucleic Acid Hybridization: Parameters and Algorithms . (2000) Bommarito00 Bommarito S., Peyret N., SantaLucia J.: Thermodynamic Parameters for DNA Sequences with Dangling Ends . Nucleic Acids Res.. 28 , (2000) Dirks04 Dirks R.M., Lin M., Winfree E., Pierce N.A.: Paradigms for Computational Nucleic Acid Design . Nucleic Acids Res.. 32 , (2004) Wolfe15 Wolfe B.R., Pierce N.A.: Nucleic Acid Sequence Design for a Test Tube of Interacting Nucleic Acid Strands . ACS Synth. Biol.. 4 , (2015) Wolfe17 Wolfe B.R., Porubsky N.J., Zadeh J.N., Dirks R.M., Pierce N.A.: Constrained Multistate Sequence Design for Nucleic Acid Reaction Pathway Engineering . J Am. Chem. Soc.. 139 , (2017) Hochrein13 Hochrein L.M., Schwarzkopf M., Shahgholi M., Yin P., Pierce N.A.: Conditional Dicer Substrate Formation via Shape and Sequence Transduction with Small Conditional RNAs . J. Am. Chem. Soc.. 135 , (2013) Porubsky20 Porubsky N.J.: Enhanced Algorithms for Analysis and Design of Nucleic Acid Reaction Pathways. PhD Thesis. California Institute of Technology . (2020) Seeman82 Seeman N.C.: Nucleic Acid Junctions and Lattices . J Theor Biol. 99 , (1982)","title":"Constrained multi-tube design problem"},{"location":"design/","text":"Design Jobs \u00b6 To enable reaction pathway engineering of dynamic hybridization cascades (e.g., shape and sequence transduction using small conditional RNAs [ Hochrein13 , HanewichHollatz19 ]) or large-scale structural engineering including pseudoknots (e.g., RNA origamis [ Geary14 ]), NUPACK sequence design operates on multistate ensembles: Multi-complex ensemble: the ensemble of an arbitrary number of strand species interacting to form an arbitrary number of complex species. Multi-tube ensemble: the ensemble of an arbitrary number of test tubes containing different subsets of an arbitrary number of strand species introduced at user-specified concentrations. We recommend using the multi-tube design ensemble as it captures concentration and crosstalk effects that are critical in most experimental settings. For reaction pathway engineering, sequence design is formulated as a multistate optimization problem using a set of target test tubes to represent reactant, intermediate, and product states of the system, as well as to model crosstalk between components. Note that we achieve kinetic design of a test tube ensemble by performing equilibrium optimization of a multi-tube ensemble: each target test tube isolates different subsets of components in local equilibrium, enabling optimization of kinetically significant states that would appear insignificant if all components were allowed to interact in a single ensemble. For large-scale structural engineering including the possibility of pseudoknots, each target test tube is unpseudoknotted, but by imposing sequence constraints between tubes, it is possible to collectively impose pseudoknotted design requirements. In a multi-tube design ensemble , each target test tube contains a set of desired \u201con-target\u201d complexes, each with a target secondary structure and target concentration, and a set of undesired \u201coff-target\u201d complexes, each with vanishing target concentration. Optimization of the multi-tube ensemble defect implements both a positive design paradigm, explicitly designing for on-pathway elementary steps, and a negative design paradigm, explicitly designing against off-pathway crosstalk. Defect weights can be specified to prioritize or de-priotize design quality for different portions of the design ensemble. Sequence design is performed subject to user-specified hard constraints (e.g., sequence constraints imposed by the reaction pathway or biological sequences) and soft constraints (e.g., design a set of toeholds to have comparable binding strength). Specify a domain \u00b6 A domain is a set of consecutive nucleotides that appear as a subsequence of one or more strands in a design. A domain is specified as a sequence (specified 5 ' ' to 3 ' ' using degenerate nucleotide codes ) and a domain name (keyword name ). Consecutive repeats of a single nucleotide code can be represented by the nucleotide code followed by the total number of repeats: a = Domain ( 'AAAA' , name = 'a' ) b = Domain ( 'A4' , name = 'b' ) # equivalent sequence specification c = Domain ( 'NNNNNNNNNN' , name = 'c' ) d = Domain ( 'N10' , name = 'd' ) # equivalent sequence specification e = Domain ( 'RRRRRNNNNN' , name = 'e' ) f = Domain ( 'R5N5' , name = 'f' ) # equivalent sequence specification g = Domain ( 'N10' , name = 'g' ) The reverse complement of domain a is denoted ~a . Complementarity refers to Watson-Crick complementarity if wobble mutations are prohibited (default) or includes the possibility of G \\cdot \\cdot U wobble pairs for RNA if wobble mutations are permitted (see Job Options ). Note Note that starting with NUPACK 4 and the all-new NUPACK Python module, scripts no longer denote the reverse complement of domain a as a* because that would not be valid Python syntax. Specify a target strand \u00b6 A TargetStrand is a single RNA or DNA molecule specified as a sequence (specified 5 ' ' to 3 ' ' in terms of previously defined domains) and a target strand name (keyword name ): A = TargetStrand ([ a , b , g ], name = 'Strand A' ) B = TargetStrand ([ d , ~ e ], name = 'Strand B' ) # ~e denotes the reverse complement of e C = TargetStrand ([ e , a , f ], name = 'Strand C' ) D = TargetStrand ([ d , d , d ], name = 'Strand D' ) Additional fields and methods are available for a TargetStrand object: .domains : a tuple of the domains comprising the strand .ndomains() : the number of domains in the strand .nt() : the number of nucleotides in the strand For example: A . domains # --> (<Domain a>, <Domain b>, <Domain g>) A . ndomains () # --> 3 A . nt () # --> 18 The reverse complement of a TargetStrand maybe analogous obtained, for example, as ~A . Specify a target complex \u00b6 A TargetComplex is an on- and/or off-target complex specified as an ordered list of strands (i.e., an ordering of strands around a circle in a polymer graph ) and a complex name (keyword name ). If the complex is to be used as an on-target complex in at least one target test tube, it is specified with an on-target secondary structure (specified in dot-parens-plus, run-length encoded dot-parens-plus, or DU+ notation): # dot-parens-plus notation C1 = TargetComplex ([ A , B , C ], '........((((((((((+))))))))))((((((((((+))))))))))..............' , name = 'C1' ) # run-length encoded dot-parens-plus notation C2 = TargetComplex ([ B , C ], '.10(10+)10.14' , name = 'C2' ) # DU+ notation C3 = TargetComplex ([ D , D ], 'D30 +' , name = 'C3' ) C4 = TargetComplex ([ B , B , B ], 'D10(D10 + D10 +)' , name = 'C4' ) C5 = TargetComplex ([ B , A , B ], 'D8(U12 +) D10(+) U10' , name = 'C5' ) Note The target structure will be used in all target test tubes in which a complex appears as an on-target complex and will be ignored in those target test tubes where a complex appears as an off-target complex. Additional fields and methods are available for a TargetComplex object: .strands : a tuple of the strands .nstrands() : the number of strands in the complex .nt() : the number of nucleotides in the complex For example: C1 . strands # --> (<TargetStrand Strand A>, <TargetStrand Strand B>, <TargetStrand Strand C>) C1 . nstrands () # --> 3 C1 . nt () # --> 62 In certain cases, it may be desirable to adjust the free energy of an on-target complex (for example, if a protein is known to stabilize the complex). For such cases, the optional keyword bonus can be used to specify an additional free energy in kcal/mol (default: 0; negative value is stabilizing, postive value is destabilizing): # destabilize C6 by 1 kcal/mol C6 = TargetComplex ([ B , C ], '.10(10+)10.14' , name = 'C6' , bonus =+ 1.0 ) # stabilize C7 by 10 kcal/mol C7 = TargetComplex ([ B , C ], '.10(10+)10.14' , name = 'C7' , bonus =- 10.0 ) Note Note that a bonus applied to the complex free energy is equivalent to applying the bonus to every structure free energy in the complex ensemble. As a result, the bonus alters the equilibrium complex concentration within the test tube ensemble , but does not alter the equilibrium base-pairing probabilities within the complex ensemble . Specify a target tube \u00b6 A TargetTube is specified as a tube name (keyword name ) and a set of on-target complexes each with a target concentration (keyword on_targets ; units of M ). Off-target complexes (keyword off_targets : defaults to none) can be specified using SetSpec() in any of three ways: Combinatorially using keyword max_size to automatically generate the set of all complexes up to a specified number of strands (default: max_size=1 ). Using keyword include to include an explicitly specified set of complexes (default: None ). Using keyword exclude to exclude an explicitly specified set of complexes (default: None ). For example: t1 = TargetTube ( on_targets = { C1 : 1e-8 , C2 : 1e-8 }, name = 't1' , off_targets = SetSpec ( max_size = 3 , include = [[ B , B , B , B ]], exclude = [ C4 ])) If desired, the on-target and off-target sets for a specified TargetTube can be queried as follows: print ( t1 . on_targets ) # --> {<TargetComplex C1>: 1e-08, <TargetComplex C2>: 1e-08} print ( t1 . off_targets ) # --> {<TargetComplex (Strand A+Strand A+Strand B)>, <TargetComplex (Strand B)>, # <TargetComplex (Strand A+Strand A)>, <TargetComplex (Strand C+Strand B+Strand B)>, # <TargetComplex (Strand A+Strand B+Strand B)>, <TargetComplex (Strand A+Strand C+Strand C)>, # <TargetComplex (Strand C)>, <TargetComplex (Strand C+Strand C+Strand C)>, # <TargetComplex (Strand A+Strand C+Strand B)>, <TargetComplex (Strand C+Strand C)>, # <TargetComplex (Strand A+Strand C)>, <TargetComplex (Strand A+Strand A+Strand C)>, # <TargetComplex (Strand A)>, <TargetComplex (Strand B+Strand B)>, # <TargetComplex (Strand A+Strand B)>, <TargetComplex (Strand A+Strand A+Strand A)>, # <TargetComplex (Strand C+Strand C+Strand B)>, <TargetComplex (Strand B+Strand B+Strand B+Strand B)>} Note Note that include and exclude accept both target complex identifiers (e.g., C4 ) and strand orderings (e.g., [B, B, B, B] ). Note that for an off-target specified using a target complex identifier (e.g., C4 ), the target structure is ignored since by definition, there is no target structure for an off-target complex. Note that any complex included as an on-target complex will not be included as an off-target complex when processing max_size and include . Note Note that used together, max_size and exclude provide a powerful combination for specifying target test tubes . With max_size it is possible to specify a large set of off-target complexes formed from a set of system components. With exclude it is further possible to remove from this large set all of the cognate products that should form between these system components (so they appear as neither on-targets nor off-targets in the tube ensemble). For example, with this approach, the reactive species in a global crosstalk tube can be forced to either perform no reaction (remaining as desired on-targets) or to undergo a crosstalk reaction (forming undesired off-targets), enabling minimization of global crosstalk during sequence optimization. An ensemble that excludes cognate reaction products can never be studied in the lab but provides a important framework for computational sequence optimization. Run a test tube design job \u00b6 The tube_design class performs constrained multi-tube design for a specified set of target test tubes (keyword tubes ) and a specified physical model (keyword model ). You may optionally: specify hard constraints (keyword hard_constraints ), specify soft constraints (keyword soft_constraints ), specify defect weights (keyword defect_weights ), and specify job options (keyword options ): my_model = Model () my_tubes = [ t1 ] my_design = tube_design ( tubes = my_tubes , hard_constraints = [], soft_constraints = [], defect_weights = None , options = None , model = my_model ) A tube_design object supports two methods for performing sequence design: run() : run multiple independent design trials in the foreground . launch() : launch multiple independent design trials in the background and save design progress to checkpoint files. Either method can be used to restart from a previous design result (keyword restart ). See below for examples using run() and launch() for the above tube_design job. Note run() is a blocking command that is convenient when you want to run a single quick design trial and wait for the results. launch() is a non-blocking command that offers the preferred mode of operation for large design jobs, enabling you to run long design trials in the background with built-in checkpointing. Run design trials in the foreground \u00b6 Once a test tube design has been specified using tube_design , use run() to run a specified number of independent design trials (keyword trials ) in parallel in the foreground and return a list of DesignResult objects: my_results = my_design . run ( trials = 2 ) # run 2 independent design trials A DesignResult object can be viewed as a table in a Jupyter notebook, for example: my_results [ 0 ] # display results table for first design trial Output: Output table displays: Designed sequences for each domain and strand. Objective function components (weighted ensemble defect and weighted soft constraints (if applicable)). Ensemble defect (unweighted). Complex defect for each on-target in the ensemble (unweighted). Tube defect for each tube in the ensemble (unweighted). Structural defect, concentration defect, and total defect for each on-target complex in each tube (unweighted). Concentration and target concentration for each on-target complex in each tube. Significant off-target complex concentrations in each tube (those off-targets with concentration \\ge \\ge 1% the maximum complex concentration in the tube). The keyword restart may be included to run a design by providing a list of DesignResult objects from a previous design job: new_results = my_design . run ( trials = 2 , restart = my_results ) An error will be thrown if trials and restart specify different numbers of design trials and DesignResult objects. Launch design trials in the background \u00b6 Once a test tube design has been specified using tube_design , use launch() to start a specified number of independent design trials (keyword trials ) in parallel in the background. Intermediate results will be saved to a directory specified with keyword checkpoint at a regular interval specified with keyword interval (in seconds, default 600): # start 2 independent design trials my_jobs = my_design . launch ( trials = 2 , checkpoint = 'my_checkpoints' , interval = 600 ) Whereas run() returns a list of DesignResult objects representing completed design trials, launch() returns a list of trial monitors. The design trials will continue in the background. To examine current results based on the latest checkpoint file for each trial, use the current_results() method: my_current_results = my_jobs . current_results () which returns a list with an entry for each trial that is either a DesignResult object (if a checkpoint file or final result is available) or None (otherwise). As illustrated above, a DesignResult object can be viewed as a table in a Jupyter notebook. For example if a checkpoint is available for the first trial, a table is generated by typing: my_current_results [ 0 ] # display results table for first design trial If only final results are of interest, use the final_results() method: my_final_results = my_jobs . final_results () which returns a list with an entry for each trial that is either a DesignResult object (if a final result is available) or None (otherwise). To lock up the interface and wait for all trials to finish, use the wait() method to return a list of DesignResult objects: my_final_results = my_jobs . wait () To stop all trials, use the stop() method: my_jobs . stop () To restart designs from previous results, use the restart keyword, providing either a list of DesignResult objects from a previous design, or a directory name containing checkpoint files: # restart from a list of DesignResult objects my_jobs = my_design . launch ( trials = 2 , checkpoint = 'new_checkpoints' , restart = my_current_results ) # restart from a checkpoint directory my_jobs = my_design . launch ( trials = 2 , checkpoint = 'new_checkpoints' , restart = 'my_checkpoints' ) An error will be returned if trials and restart specify different numbers of design trials and DesignResult objects. However, if no results exist in the supplied restart directory, the design will be started afresh without any error messages. Hence, you can create a rerunnable design by supplying the same directory to checkpoint and restart : my_jobs = my_design . launch ( trials = 2 , checkpoint = 'my_checkpoints' , restart = 'my_checkpoints' ) Run a complex design job \u00b6 The complex_design class enables specification of a constrained multi-complex design for a specified set of target complexes (keyword complexes ) and a specified physical model (keyword model ). You may optionally: specify hard constraints (keyword hard_constraints ), specify soft constraints (keyword soft_constraints ), specify defect weights (keyword defect_weights ), and specify job options (keyword options ): my_model = Model () my_complexes = [ C1 , C2 ] my_design = complex_design ( complexes = my_complexes , hard_constraints = [], soft_constraints = [], defect_weights = None , options = None , model = my_model ) result = my_design . run ( trials = 2 ) # run 2 independent design trials in the foreground result [ 0 ] Output: A complex_design object supports the launch() , run() , and evaluate() methods just as for a tube_design object (see above). Note Note that a complex_design job is equivalent to a tube_design job with each on-target complex placed in a separate test tube containing no off-target complexes. For this reason, we strongly recommend use of test tube design formulations over complex design formulations so that off-target complexes are present in the design ensemble and the design algorithm can actively design against their formation. Specify hard constraints \u00b6 Hard constraints for a design job are specified as a list, for example: # specify domains a = Domain ( 'N4' , name = 'a' ) b = Domain ( 'N4' , name = 'b' ) c = Domain ( 'N5' , name = 'c' ) d = Domain ( 'N5' , name = 'd' ) e = Domain ( 'N5' , name = 'e' ) f = Domain ( 'N5' , name = 'f' ) A = TargetStrand ([ a , b , c ], name = 'A' ) # source sequence for window constraint gfp = 'auggugagcaagggcgaggagcuguucaccgggguggugcccauccuggucgagcuggacggcgacguaaacggccacaaguucagcguguccggcgagggcgagggcgaugccaccuacggcaagcugacccugaaguucaucugcaccaccggcaagcugcccgugcccuggcccacccucgugaccacccugaccuacggcgugcagugcuucagccgcuaccccgaccacaugaagcagcacgacuucuucaaguccgccaugcccgaaggcuacguccaggagcgcaccaucuucuucaaggacgacggcaacuacaag' # define list of hard constraints my_hard_constraints = [ Match ([ a ], [ b ]), Match ([ a , b , f , f ], [ d , a , d , a ]), Complementarity ([ a , b , f , a , a , b ], [ c , d , e , c , c ], wobble_mutations = True ), Similarity ([ c ], 'S5' , limits = [ 0.2 , 0.8 ]), # GC content Library ([ a ], catalog = [[ 'CTAC' , 'TAAT' ]]), Window ([ a , ~ b ], sources = [ gfp ]), Pattern ([ 'A5' , 'C5' , 'G5' , 'U5' ], scope = A ), Pattern ([ 'A4' , 'C4' , 'G4' , 'U4' , 'M6' , 'K6' , 'W6' , 'S6' , 'R6' , 'Y6' ]), Diversity ( word = 4 , types = 2 ), Diversity ( word = 6 , types = 3 ), Diversity ( word = 10 , types = 4 , scope = [ a , b ]) ] #two ways to add another constraint to the constraint set my_hard_constraints += [ Complementarity ([ e ], [ f ], wobble_mutations = True )] my_hard_constraints . append ( Complementarity ([ e ], [ f ], wobble_mutations = True )) Note Note that the specification of a domain using degenerate nucleotide codes (as in the example above) is an implicit hard sequence constraint. Note Note that NUPACK will return an error if a design specification contains a fixed sequence that violates a hard constraint See below for information about how to specify each type of hard constraint. Match \u00b6 A match constraint forces equal-length concatenations of one or more domains to be identical. A Match hard constraint is specified as follows: a first list of domains for concatenation; alternatively, a target strand may be specified a second list of domains for concatenation; alternatively, a target strand may be specified a = Domain ( 'N10' , name = 'a' ) b = Domain ( 'N4' , name = 'b' ) c = Domain ( 'H6' , name = 'c' ) d = Domain ( 'N6' , name = 'd' ) e = Domain ( 'S2' , name = 'e' ) A = TargetStrand ([ a , b ], name = 'Strand A' ) match1 = Match ([ c ], [ b , ~ e ]) # ~e is the reverse complement of e match2 = Match ([ a , b ], [ d , d , e ]) # specifying target strand A is equivalent to specifying list of domains [a, b] match3 = Match ( A , [ d , d , e ]) Note Constraints that expect a list of domains for concatenation will alternatively accept a target strand. Complementarity \u00b6 A complementarity constraint forces a concatenation of one list of domains to be the reverse complement of an equal-length concatenation of another list of domains. A Complementarity hard constraint is specified as: a first list of domains for concatenation; alternatively, a target strand may be specified a second list of domains for concatenation; alternatively, a target strand may be specified comp1 = Complementarity ([ a , b ], [ c , d , e ]) # specifying target strand A is equivalent to specifying list of domains [a, b] comp2 = Complementarity ( A , [ c , d , e ]) Note Nucleotides that are base-paired in the target structure of an on-target complex are automatically assigned a complementarity constraint. By default, complementary sequences are required to have Watson-Crick base-pairing (A \\cdot \\cdot U or C \\cdot \\cdot G for RNA, A \\cdot \\cdot T or C \\cdot \\cdot G for DNA). To permit wobble mutations for RNA (G \\cdot \\cdot U) globally throughout a design, use the wobble_mutations job option . Alternatively, wobble mutations can be allowed for individual complementarity constraints (keyword wobble_mutations , default: False ): comp2 = Complementarity ([ a , b ], [ c , d , e ], wobble_mutations = True ) It is also possible to force base pairs to be wobble pairs: f = Domain ( 'S2' , name = 'f' ) g = Domain ( 'S2' , name = 'g' ) comp3 = Complementarity ([ f ], [ g ], wobble_mutations = True ) Similarity \u00b6 A similarity constraint forces a concatentation of domains to match a reference sequence of the same length to within a specified fractional range. A Similarity hard constraint is specified as: a list of domains to be concatenated; alternatively a target strand may be specified a reference sequence of the same length as the concatenated domains a fractional range, [l, u] [l, u] , where 0 \\leq l < u \\leq 1 0 \\leq l < u \\leq 1 a = Domain ( 'N10' , name = 'a' ) b = Domain ( 'N20' , name = 'b' ) C = TargetStrand ([ a , b , a ], name = 'Strand C' ) # similarity constraint for a concatenation of domains sim1 = Similarity ([ a , ~ a , b ], 'S5K35' , limits = [ 0.25 , 0.75 ]) # similarity constraint for a target strand sim2 = Similarity ( C , 'S30K10' , limits = [ 0.25 , 0.75 ]) # for a strand # use similarity constraint to enforce 45-55% GC content sim3 = Similarity ([ a , b ], 'S30' , limits = [ 0.45 , 0.55 ]) Note A similarity constraint can be used to constrain sequence composition (e.g., 45-55% GC content as in the example above). Window \u00b6 A window constraint forces a concatenation of domains to have a sequence that is a subsequence of a source sequence. More generally, a window can be drawn from any of multiple source sequences. A Window hard constraint is specified as: Define one or more source sequences as strings. Specify a list of domains for concatenation; alternatively, specify a target strand Specify a list of sources from which the window should be selected a = Domain ( 'N10' , name = 'a' ) b = Domain ( 'N10' , name = 'b' ) c = Domain ( 'N10' , name = 'c' ) e = Domain ( 'N10' , name = 'e' ) A = TargetStrand ([ a , ~ b ], name = 'Strand A' ) gfp = 'AUGGUGAGCAAGGGCGAGGAGCUGUUCACCGGGGUGGUGCCCAUCCUGGUCGAGCUGGACGGCGACGUAAACGGCCACAAGUUCAGCGUGUCCGGCGAGGGCGAGGGCGAUGCCACCUACGGCAAGCUGACCCUGAAGUUCAUCUGCACCACCGGCAAGCUGCCCGUGCCCUGGCCCACCCUCGUGACCACCCUGACCUACGGCGUGCAGUGCUUCAGCCGCUACCCCGACCACAUGAAGCAGCACGACUUCUUCAAGUCCGCCAUGCCCGAAGGCUACGUCCAGGAGCGCACCAUCUUCUUCAAGGACGACGGCAACUACAAG' rfp = 'CCUGCAGGACGGCGAGUUCAUCUACAAGGUGAAGCUGCGCGGCACCAACUUCCCCUCCGACGGCCCCGUAAUGCAGAAGAAGACCAUGGGCUGGGAGGCCUCCUCCGAGCGGAUGUACCCCGAGGACGGCGCCCUGAAGGGCGAGAUCAAGCAGAGGCUGAAGCUGAAGGACGGCGGCCACUACGACGCUGAGGUCAAGACCACCUACAAGGCCAAGAAGCCCGUGCAGCUGCCCGGCGCCUACAACGUCAACAUCAAGUUGGACAUCACCUCCCACAACGAGGACUACACCAUCGUGGAACAGUACGAACGCGCCGAGGGCCGCCACUCCACCGGCGGCAUGGACGAGCUGUACAAGUAA' # constrain window to be drawn from a source window1 = Window ([ a , ~ b ], sources = [ gfp ]) # window constraint for a target strand window2 = Window ( A , sources = [ gfp ]) # constrain window to be drawn from more either of two sources window3 = Window ([ ~ c , e ], sources = [ gfp , rfp ]) Library \u00b6 A library constraint forces a concatenated list of domains to have sequences drawn from a concatenated list of libraries. Each library contains a set of alternative sequences of equal length. A Library hard constraint is specified as: Define one or more libraries of alternative sequences of uniform length. Specify a list of domains for concatentation; alternatively, specify a target strand Specify a list of libraries for concatenation The sum of the length of the domains must equal the sum of the length of the libraries (where we define the length of a library to be the length of any of its elements). a = Domain ( 'N6' , name = 'a' ) b = Domain ( 'N10' , name = 'b' ) c = Domain ( 'N2' , name = 'c' ) d = Domain ( 'N3' , name = 'd' ) e = Domain ( 'N3' , name = 'e' ) A = TargetStrand ([ d , e ], name = 'Strand A' ) # define a library of sequences toeholds = [ 'CAGUGG' , 'AGCUCG' , 'CAGGGC' ] # define a library of codons for each amino acid aaI = [ 'AUU' , 'AUC' , 'AUA' ] aaL = [ 'CUU' , 'CUC' , 'CUA' , 'CUG' , 'UUA' , 'UUG' ] aaV = [ 'GUU' , 'GUC' , 'GUA' , 'GUG' ] aaF = [ 'UUU' , 'UUC' ] aaM = [ 'AUG' ] aaC = [ 'UGU' , 'UGC' ] aaA = [ 'GCU' , 'GCC' , 'GCA' , 'GCG' ] aaG = [ 'GGU' , 'GGC' , 'GGA' , 'GGG' ] aaP = [ 'CCU' , 'CCC' , 'CCA' , 'CCG' ] aaT = [ 'ACU' , 'ACC' , 'ACA' , 'ACG' ] aaS = [ 'UCU' , 'UCC' , 'UCA' , 'UCG' , 'AGU' , 'AGC' ] aaY = [ 'UAU' , 'UAC' ] aaW = [ 'UGG' ] aaQ = [ 'CAA' , 'CAG' ] aaN = [ 'AAU' , 'AAC' ] aaH = [ 'CAU' , 'CAC' ] aaE = [ 'GAA' , 'GAG' ] aaD = [ 'GAU' , 'GAC' ] aaK = [ 'AAA' , 'AAG' ] aaR = [ 'CGU' , 'CGC' , 'CGA' , 'CGG' , 'AGA' , 'AGG' ] aaSTOP = [ 'UAA' , 'UAG' , 'UGA' ] # domain a is drawn from a toehold library lib1 = Library ([ a ], [ toeholds ]) # target strand A is drawn from a toehold library lib1 = Library ( A , [ toeholds ]) # concatenation [b, c] is drawn from a concatenation of 4 codon libraries lib2 = Library ([ b , c ], [ aaI , aaM , aaC , aaG ]) Pattern Prevention \u00b6 A pattern prevention constraint prevents a list of patterns from appearing globally or in a concatenated list of domains. A Pattern hard constraint is specified as: a list of patterns to be prevented optionally a list of domains for concatenation (keyword scope ) where the patterns should be prevented; alternatively, a target strand may be specified if the scope is unspecified (absence of keyword scope ), the constraint is global a = Domain ( 'N12' , name = 'a' ) b = Domain ( 'N12' , name = 'b' ) A = TargetStrand ([ a , ~ a ], name = 'A' ) B = TargetStrand ([ b , ~ b ], name = 'B' ) # pattern prevention for concatenation [a, b] pattern1 = Pattern ([ 'A4' , 'U4' ], scope = [ a , b ]) # pattern prevention for target strand B pattern2 = Pattern ([ 'A4' , 'U4' ], scope = B ) # global pattern prevention pattern3 = Pattern ([ 'A4' , 'C4' , 'G4' , 'U4' , 'M6' , 'K6' , 'W6' , 'S6' , 'R6' , 'Y6' ]) Diversity \u00b6 A diversity constraint forces every word of a specified length to contain a specified degree of sequence diversity, either globally or for a concatenated list of domains. A Diversity hard constraint is specified as: the word length in nucleotides (keyword word ) the minimum number of nucleotide types that must appear in every window (keyword types ) optionally a list of domains for concatenation (keyword scope ) where the diversity should be imposed; alternatively, a target strand may be specified if the scope is unspecified (absence of keyword scope ), the constraint is global a = Domain ( 'N12' , name = 'a' ) b = Domain ( 'N12' , name = 'b' ) A = TargetStrand ([ a , ~ a ], name = 'A' ) C = TargetComplex ([ A , A ], name = 'A+A' ) # global constraints div1 = Diversity ( word = 4 , types = 2 ) div2 = Diversity ( word = 6 , types = 3 ) # local constraint on concatenation [a, b] div3 = Diversity ( word = 10 , types = 4 , scope = [ a , b ]) # local constraint on target strand A div4 = Diversity ( word = 10 , types = 4 , scope = A ) Note A diversity constraint that forces every window of length 4 to contain at least 2 nucleotide types is equivalent to a pattern prevention contraint that prevents patterns: AAAA, CCCC, GGGG, UUUU. Likewise, a diversity constraint that forces every window of length 6 to contain at least 3 nucleotide types is equivalent to a pattern prevention constraint that prevents: MMMMMM, KKKKKK, WWWWWW, SSSSSS, RRRRRR, YYYYYY. We recommend diversity constraints over pattern prevention constraints because they make it more efficient to solve the constraint satisfaction problem that identifies a new validate candidate mutation at every step during sequence optimization. The global constraints div1 and div2 reproduce the global pattern prevention constraint pattern3 . Specify soft constraints \u00b6 Soft constraints for a design job are specified as a list, for example: # define soft for soft constraints my_soft_constraints = [ Pattern ([ 'A4' , 'U4' ], scope = a ), Pattern ([ 'A5' , 'C5' , 'G5' , 'U5' ], scope = A ), # default weight 1 Pattern ([ 'A4' , 'C4' , 'G4' , 'U4' , 'M6' , 'K6' , 'W6' , 'S6' , 'R6' , 'Y6' ], weight = 0.5 ), Similarity ([ b ], 'S12' , limits = [ 0.45 , 0.55 ], weight = 0.25 ), SSM ( word = 4 , scope = [ C ], weight = 0.15 ), EnergyMatch ([ a , b ]), # min energy diff to median EnergyMatch ([ a , b ], energy_ref =- 17 , weight = 0.5 ) # energy diff to reference ] Similarity \u00b6 Similarity soft constraints are specified in nearly the same way as similarity hard constraints. The primary difference is that a weight can be supplied to control the relative design effort spent on the soft constraint. A similarity constraint penalizes a concatentation of domains if it does not match a reference sequence of the same length to within a specified fractional range. A Similarity soft constraint is specified as: a list of domains to be concatenated; alternatively a target strand may be specified a reference sequence of the same length as the concatenated domains a fractional range, [l, u] [l, u] , where 0 \\leq l < u \\leq 1 0 \\leq l < u \\leq 1 an optional weight \\in[0,\\infty) \\in[0,\\infty) (default: 1) that can be used to prioritize or de-prioritize design effort a = Domain ( 'N10' , name = 'a' ) b = Domain ( 'N20' , name = 'b' ) C = TargetStrand ([ a , b , a ], name = 'Strand C' ) # similarity constraint for a concatenation of domains sim1 = Similarity ([ a , ~ a , b ], 'S5K35' , limits = [ 0.25 , 0.75 ]) # similarity constraint for a target strand sim2 = Similarity ( C , 'S30K10' , limits = [ 0.25 , 0.75 ], weight = 2.0 ) # for a strand # use similarity constraint to enforce 45-55% GC content sim3 = Similarity ([ a , b ], 'S30' , limits = [ 0.45 , 0.55 ], weight = 0.25 ) Pattern prevention \u00b6 A pattern prevention constraint penalizes a list of patterns from appearing globally or in a concatenated list of domains. A Pattern soft constraint is specified as: a list of patterns to be prevented optionally a list of domains for concatenation (keyword scope ) where the patterns should be prevented; alternatively, a target strand may be specified if the scope is unspecified (absence of keyword scope ), the constraint is global an optional weight \\in[0,\\infty) \\in[0,\\infty) (default: 1) that can be used to prioritize or de-prioritize design effort a = Domain ( 'N12' , name = 'a' ) b = Domain ( 'N12' , name = 'b' ) A = TargetStrand ([ a , ~ a ], name = 'A' ) B = TargetStrand ([ b , ~ b ], name = 'B' ) # pattern prevention for concatenation [a, b] pattern1 = Pattern ([ 'A4' , 'U4' ], scope = [ a , b ], weight = 2.0 ) # pattern prevention for target strand B pattern2 = Pattern ([ 'A4' , 'U4' ], scope = B ) # global pattern prevention pattern3 = Pattern ([ 'A4' , 'C4' , 'G4' , 'U4' , 'M6' , 'K6' , 'W6' , 'S6' , 'R6' , 'Y6' ], weight = 0.5 ) Sequence symmetry \u00b6 A sequence symmetry constraint penalizes a subsequence of a specified word length if the word appears in more than one location, if its reverse complement appears elsewhere in a location that is not intended to form a duplex with the word, or if the word is self-complementary. An SSM soft constraint is specified as: the word length in nucleotides (keyword word ) optionally a list of on-target complexes (keyword scope ) where the constraint should apply if the scope is unspecified (absence of keyword scope ), the constraint is global an optional weight \\in[0,\\infty) \\in[0,\\infty) (default: 1) that can be used to prioritize or de-prioritize design effort a = Domain ( 'N12' , name = 'a' ) b = Domain ( 'N12' , name = 'b' ) A = TargetStrand ([ a , ~ a ], name = 'A' ) B = TargetStrand ([ b , ~ b ], name = 'B' ) C = TargetComplex ([ A ], \"(10.4)10\" , name = 'C' ) D = TargetComplex ([ A , A ], \"D24 +\" , name = 'D' ) # multiple SSM constraints with different word lengths applied to the same complexes ssm1 = SSM ( word = 4 , scope = [ C , D ], weight = 0.15 ) ssm2 = SSM ( word = 5 , scope = [ C , D ], weight = 0.25 ) ssm3 = SSM ( word = 6 , scope = [ C , D ], weight = 0.45 ) #global SSM constraint applies to all on-target complexes in the design ssm4 = SSM ( word = 6 , weight = 0.5 ) Note Multiple SSM constraints with different window sizes can be specified for a given complex (see example above). Energy match \u00b6 An energy match constraint penalizes a set of duplexes if their structure free energies deviate from the median value, or alternatively deviate from a specified reference free energy. An EnergyMatch soft constraint is specified as: a list of domains, each to be evaluated as a duplex with its reverse complement an optional reference free energy in kcal/mol (keyword energy_ref ) an optional weight \\in[0,\\infty) \\in[0,\\infty) (default: 1) that can be used to prioritize or de-prioritize design effort a = Domain ( 'N12' , name = 'a' ) b = Domain ( 'N12' , name = 'b' ) c = Domain ( 'N12' , name = 'c' ) d = Domain ( 'N12' , name = 'd' ) # match each duplex free energy to the median value diff1 = EnergyMatch ([ a , b , c , d ]) # match each duplex free energy to the specified reference free energy diff2 = EnergyMatch ([ a , b , c , d ], energy_ref =- 17 , weight = 0.5 ) Note An energy match constraint can be used to design a set of toeholds of comparable strength. Specify defect weights \u00b6 Defect weights can be specified to reprioritize design effort at any subset of levels (tube, complex, strand, domain) within design ensemble. A Weights object is created for the set of TargetTube objects to be designed: a1 = Domain ( 'N5' , name = 'a1' ) a2 = Domain ( 'N5' , name = 'a2' ) b = Domain ( 'N10' , name = 'b' ) A = TargetStrand ([ a1 , a2 ], name = 'A' ) B = TargetStrand ([ b ], name = 'B' ) AB = TargetComplex ([ A , B ], structure = '(10+)10' , name = 'AB' ) AA = TargetComplex ([ A , A ], structure = '(10+)10' , name = 'AA' ) t1 = TargetTube ({ AB : 1e-8 }, name = 't1' ) t2 = TargetTube ({ AA : 1e-9 , AB : 1e-10 }, name = 't2' ) my_tubes = [ t1 , t2 ] weights = Weights ( my_tubes ) # All weights are initialized to 1 The weights are initialized to 1, but can be customized to take any value in the interval [0,\\infty) [0,\\infty) . Weights can be manipulated by slicing on any subset of 4 indices (in the following order: Domain, TargetStrand, TargetComplex, TargetTube). For example: # weight on domain a1 in all target strands, target complexes, and target tubes weights [ a1 ] *= 2 # weight on target strand A in all target conplexes and target tubes weights [:, A ] = 4 # weight on tube t2 weights [:, :, :, t2 ] = 2 # weight on target complex AB in tube t1 weights [:, :, AB , t1 ] = 5 # weight on domain a2 in target strand A in all target complexes in all tubes weights [ a2 , A ] = 0.75 # weight on domain a1 in all target strands in target complex AA in tube t2 weights [ a1 , :, AA , t2 ] = 0.5 # weight on domain b in all target strands and target complexes in tube t2 weights [ b , :, :, t2 ] = 3 # global weight on the entire multi-tube ensemble defect weights [:] *= 2 Note Note that multi-tube ensemble defect \\mathcal{M} \\mathcal{M} varies between 0 and 1 so that specifying an increasing number of soft constraints in the augmented objective function will increasingly de-emphasize design effort on the ensemble defect. Specifying a global weight as part of the weighted ensemble defect \\mathcal{M_W} \\mathcal{M_W} (see example above) can be used to balance effort on the ensemble defect against effort on the soft constraints. A Weights object may be displayed as a table in a Jupyter notebook, for example: weights Output: Alternatively, you can view an ASCII representation of the same data by using the print function: print ( weights ) Output: Domain Strand Complex Tube Weight a1 A AA t2 1.0 a1 A AB t1 10.0 a1 A AB t2 4.0 a2 A AA t2 1.5 a2 A AB t1 1.5 a2 A AB t2 1.5 b B AB t1 10.0 b B AB t2 6.0 For experienced Python users, a Weights object contains a pandas.DataFrame as a single member .table . Note For a complex design job , the Weights object is generated for a set of on-target complexes, in which case the 4th index (for tubes) is omitted: my_complexes = [ AB , AA ] complex_weights = Weights ( my_complexes ) # weight on domain a1 in all target strands and target complexes complex_weights [ a1 ] *= 2 # weight on target strand A in all target complexes complex_weights [:, A ] = 4 # weight on domain a2 in target strand A in target complex AA complex_weights [ a2 , A , AA ] = 0.75 Job options \u00b6 Specify any non-default job options (See Supp Info of [ Wolfe17 ] for details). Defaults are shown below: options = DesignOptions ( f_stop = 0.02 , # stop condition for sequence optimization seed = 0 , # random seed if 0; specified seed otherwise (reproducible trial) H_split = 2 , # default: 2 for RNA, 3 for DNA and custom N_split = 12 , f_split = 0.99 , # in interal (0,1) f_stringent = 0.99 , # in interval (0,1) dG_clamp =- 20 , # kcal/mol M_bad = 300 , M_reseed = 50 , M_reopt = 3 , f_passive = 0.01 , # in interval (0,1) f_redecomp = 0.03 , # in interval (0,1) f_refocus = 0.03 , # in interval (0,1) f_sparse = 1e-05 , # threshold pair probs for sparse storage in decomposition tree wobble_mutations = False , # allow wobble pairs in user-assigned domain complements (e.g. between a and a*/~a) max_time = 0 , # max design time in seconds (if nonzero) ) Note Enable wobble_mutations (default False ) so that the designer will consider sequences which may 1) yield wobble ( GU ) pairs in target structures and 2) contain wobble complements in domain reverse complements (e.g. a = GGG , a* = UUU ). Note Set max_time to a positive number to manually control how long a design will take (in seconds). Note that this time limit is somewhat loose as the designer will only stop at timepoints in which the current design may be fully evaluated. Consider using checkpointing as an alternative to optimize the tradeoff between design quality and CPU time. Note Change f_stop to adjust the stop condition for sequence optimization. For multi-tube ensembles with many sequence constraints (especially biological sequence constraints) you may need to increase the stop condition. options = DesignOptions ( f_stop = 0.05 ) By default, NUPACK design jobs run in parallel . Job results \u00b6 The results of NUPACK design jobs can be conveniently displayed as a table, printed as text, or introspected programmatically. Consider the following test tube design job: a = Domain ( 'N20' , name = 'a' ) A = TargetStrand ([ a ], name = 'A' ) B = TargetStrand ([ ~ a ], name = 'B' ) C = TargetComplex ([ A , B ], '(20+)20' , name = 'C' ) tube1 = TargetTube ({ C : 1e-6 }, off_targets = SetSpec ( max_size = 2 ), name = 'tube1' ) soft = [ Similarity ([ a ], 'S20' , limits = [ 0.45 , 0.55 ], weight = 0.05 )] hard = [ Diversity ( word = 4 , types = 2 , scope = [ a ])] my_design = tube_design ([ tube1 ], model = Model (), soft_constraints = soft , hard_constraints = hard ) my_result = my_design . run ( trials = 1 )[ 0 ] Tabular display \u00b6 You can display a summary table of results in a Jupyter notebook, for example: my_result Output: Textual display \u00b6 You can view an ASCII representation of the same data by using the print function: print ( my_result ) Output: Domain results: Domain Sequence a GGGUGCAAAGGUAUGGGAGG a* CCUCCCAUACCUUUGCACCC Strand results: Strand Sequence A GGGUGCAAAGGUAUGGGAGG B CCUCCCAUACCUUUGCACCC Objective function: Objective type Value Weighted ensemble defect 0.00771 Soft constraints: similarity 0.00556 Total 0.0133 Ensemble defect: 0.00771 Complex Complex defect (nt) Normalized complex defect C 0.308 0.00771 On-target complex defects: Tube Tube defect (M) Normalized tube defect tube1 3.08e-07 0.00771 Tube defects: Tube On-target complex Structural defect (M) Concentration defect (M) Total defect (M) tube1 C 3.08e-07 8.73e-16 3.08e-07 On-target complex concentrations: Tube Complex Concentration (M) Target concentration (M) tube1 C 1.00e-06 1.00e-06 Significant off-target complex concentrations (>= 1% max complex concentration in tube): Tube Complex Concentration (M) tube1 - - Programmatic access \u00b6 A DesignResult object allows programmatic access via several fields: .to_analysis : a mapping from an object to be designed ( Domain , TargetStrand , TargetComplex , TargetTube ) specified in terms of degenerate nucleotide codes to the corresponding object containing the designed sequences ( Domain , Strand , Complex , Tube ). These objects are useful for re-analyzing designed sequences in different experimental conditions (with the exception of Domain which is not used for analysis jobs). .defects : ensemble defects at all levels within the design ensemble (each as a pandas.DataFrame ). .concentrations : concentration information for on-target complex and significant off-target complexes. .analysis_result : an AnalysisResult for thermodynamic results computed on the designed ensemble. .domains : a dict from your input domains to their designed equivalents. You can easily retrieve the designed sequences as a simple dict via a usage like {k.name: str(v) for k, v in my_result.domains.items()} . Fields may be displayed individually, for example: my_result . to_analysis Output: my_result . defects Output: my_result . concentrations Output: my_result . analysis_result Output: You can query any field of the DesignResult using Python, for example: # print various designed sequences print ( my_result . to_analysis ( tube1 )) # --> Tube({A: 1e-06, B: 1e-06}, name='tube1') print ( my_result . to_analysis ( C )) # --> GGGUGCAAAGGUAUGGGAGG+CCUCCCAUACCUUUGCACCC print ( my_result . to_analysis ( B )) # --> CCUCCCAUACCUUUGCACCC print ( my_result . to_analysis ( a )) # --> GGGUGCAAAGGUAUGGGAGG # print specific defect contributions print ( my_result . defects . ensemble_defect ) # 0.007708701513018191 print ( my_result . defects . tubes ) # --> each tube print ( my_result . defects . complexes ) # --> each on-target print ( my_result . defects . tube_complexes ) # --> each on-target in each tube Each subfield ( tubes , complexes , tube_complexes ) is a pandas.DataFrame s. For convenience, these tables contain Python objects and the corresponding object name (e.g., tube object and corresponding tube_name string). Evaluate a design \u00b6 The evaluate() method enables generation of a DesignResult object for a tube_design that has fully specified sequences (i.e., contains no degenerate nucleotide codes ), for example: a = Domain ( 'CAGAUAAGAACUGAGUAAGC' , name = 'a' ) A = TargetStrand ([ a ], name = 'A' ) B = TargetStrand ([ ~ a ], name = 'B' ) C = TargetComplex ([ A , B ], '(20+)20' , name = 'C' ) tube1 = TargetTube ({ C : 1e-6 }, off_targets = SetSpec ( max_size = 2 ), name = 'tube1' ) soft = [ Similarity ([ a ], 'S20' , limits = [ 0.45 , 0.55 ], weight = 0.05 )] hard = [ Diversity ( word = 4 , types = 2 , scope = [ a ])] my_evaluated_design = tube_design ([ tube1 ], model = Model (), soft_constraints = soft , hard_constraints = hard ) my_evaluated_result = my_evaluated_design . evaluate () An exception will be raised if any domain contains nucleotides other than ACGTU , or if the hard constraints are incompatible with the given domains. Just as for any DesignResult object, a convenient results table can be displayed in a Jupyter notebook: my_evaluated_result Output: Note Consider using the evaluate() method on an RNA design that was performed with wobble_mutations enabled and that uses both domain a and the reverse complement domain ~a in the specification of the design ensemble. Then the definition of the reverse complement domain ~a is not fully defined since a G in domain a could be paired to either a C or a U in the final designed version of ~a . This ambiguity can be overcome by manually defining ~a using the complement keyword: h = Domain ( 'GGGG' , name = 'h' ) print ( ~ h ) # --> CCCC i = Domain ( 'GGGG' , name = 'i' , complement = 'CUUC' ) print ( ~ i ) # --> CUUC The evaluate() method will raise an exception if wobble_mutations are active and a reverse complement domain has not been manually defined. The following example demonstrates use of the complement keyword to enable evaluation of a design performed with wobble_mutations enabled: a = Domain ( 'CAGAUAAGAACUGAGUAAGC' , complement = 'GCUUAUUCAGUUCUUAUCUG' , name = 'a' ) A = TargetStrand ([ a ], name = 'A' ) B = TargetStrand ([ ~ a ], name = 'B' ) C = TargetComplex ([ A , B ], '(20+)20' , name = 'C' ) tube1 = TargetTube ({ C : 1e-6 }, off_targets = SetSpec ( max_size = 2 ), name = 'tube1' ) soft = [ Similarity ([ a ], 'S20' , limits = [ 0.45 , 0.55 ], weight = 0.05 )] hard = [ Diversity ( word = 4 , types = 2 , scope = [ a ])] options = DesignOptions ( wobble_mutations = True ) wobble_design = tube_design ([ tube1 ], model = Model ( material = 'rna' ), soft_constraints = soft , hard_constraints = hard , options = options ) wobble_result = wobble_design . evaluate () Evaluate a design using a different model, soft constraints, defect weights, and/or domains \u00b6 A DesignResult object can be evaluated using modified domains, a different free energy model, different soft constraints, and/or different defect weights using the evaluate_with method: a = Domain ( 'N20' , name = 'a' ) A = TargetStrand ([ a ], name = 'A' ) B = TargetStrand ([ ~ a ], name = 'B' ) C = TargetComplex ([ A , B ], '(20+)20' , name = 'C' ) tube1 = TargetTube ({ C : 1e-6 }, off_targets = SetSpec ( max_size = 2 ), name = 'tube1' ) soft = [ Similarity ([ a ], 'S20' , limits = [ 0.45 , 0.55 ], weight = 0.05 )] my_design = tube_design ([ tube1 ], model = Model (), soft_constraints = soft ) my_result = my_design . run ( trials = 1 )[ 0 ] # Evaluate the result with a different model new_model = Model ( celsius = 40 ) my_result . evaluate_with ( model = new_model ) # Evaluate the result with a different model and soft constraints new_soft = [ Similarity ([ a ], 'G20' , limits = [ 0.4 , 0.6 ], weight = 0.5 )] my_result . evaluate_with ( model = new_model , soft_constraints = new_soft ) # Evaluate the result with different defect weights new_weights = Weights ([ tube1 ]) new_weights [:, A ] *= 10 my_result . evaluate_with ( defect_weights = new_weights ) # Evaluate the result with a different model and domains new_domains = [ Domain ( 'CAGAUAAGAACUGAGUAAGC' , name = 'a' )] my_result . evaluate_with ( domains = new_domains , model = new_model ) Analyze additional physical quantities for a designed ensemble \u00b6 To analyze additional physical quantities for a designed ensemble (e.g., the MFE structure of each designed on-target complex), use the to_analysis() method to make a version of the design ensemble containing designed sequences and then run a test tube analysis job or complex analysis job as desired. For example: # Tube object based on TargetTube with designed sequences t1_designed = my_result . to_analysis ( tube1 ) # Calculate the MFE structure for each on-target complex in the design ensemble tube_results = complex_analysis ( t1_designed , compute = [ 'mfe' ], model = my_model ) Analyze a designed ensemble using different strand concentrations \u00b6 To re-analyze designed sequences using strand concentrations that differ from those in the design ensemble, use the to_analysis() method to make a version of the design ensemble containing designed sequences, and use the analysis_result field to supply an AnalysisResult object to run a complex concentrations job : t1_designed = my_result . to_analysis ( tube1 ) # Tube object based on TargetTube with designed sequences strandA_designed = my_result . to_analysis ( A ) strandB_designed = my_result . to_analysis ( B ) my_analysis_result = my_result . analysis_result # Re-compute complex concentrations for a different set of strand concentrations conc_results = complex_concentrations ( t1_designed , my_analysis_result , concentrations = { strandA_designed : 1e-8 , strandB_designed : 1e-9 }) Save a job summary \u00b6 To save a textual job summary using the save_text method: my_result . save_text ( 'my-result.txt' ) Save and reload job results \u00b6 Save a DesignResult as a binary file using the save method: my_result . save ( 'my-result.o' ) to enable reloading during a future session using the load method: my_result = DesignResult . load ( 'my-result.o' ) This functionality uses Python\u2019s built-in pickle module. Hochrein13 Hochrein L.M., Schwarzkopf M., Shahgholi M., Yin P., Pierce N.A.: Conditional Dicer Substrate Formation via Shape and Sequence Transduction with Small Conditional RNAs . J. Am. Chem. Soc.. 135 , (2013) HanewichHollatz19 Hanewich-Hollatz M.H., Chen Z., Hochrein L.M., Huang J., Pierce N.A.: Conditional Guide RNAs: Programmable Conditional Regulation of CRISPR/cas Function in Bacterial and Mammalian Cells via Dynamic RNA Nanotechnology . ACS central science. 5 , (2019) Geary14 Geary C., Rothemund P.W., Andersen E.S.: A Single-Stranded Architecture for Cotranscriptional Folding of {{RNA}} Nanostructures . Science. 345 , (2014) Wolfe17 Wolfe B.R., Porubsky N.J., Zadeh J.N., Dirks R.M., Pierce N.A.: Constrained Multistate Sequence Design for Nucleic Acid Reaction Pathway Engineering . J Am. Chem. Soc.. 139 , (2017)","title":"Design Jobs"},{"location":"design/#design-jobs","text":"To enable reaction pathway engineering of dynamic hybridization cascades (e.g., shape and sequence transduction using small conditional RNAs [ Hochrein13 , HanewichHollatz19 ]) or large-scale structural engineering including pseudoknots (e.g., RNA origamis [ Geary14 ]), NUPACK sequence design operates on multistate ensembles: Multi-complex ensemble: the ensemble of an arbitrary number of strand species interacting to form an arbitrary number of complex species. Multi-tube ensemble: the ensemble of an arbitrary number of test tubes containing different subsets of an arbitrary number of strand species introduced at user-specified concentrations. We recommend using the multi-tube design ensemble as it captures concentration and crosstalk effects that are critical in most experimental settings. For reaction pathway engineering, sequence design is formulated as a multistate optimization problem using a set of target test tubes to represent reactant, intermediate, and product states of the system, as well as to model crosstalk between components. Note that we achieve kinetic design of a test tube ensemble by performing equilibrium optimization of a multi-tube ensemble: each target test tube isolates different subsets of components in local equilibrium, enabling optimization of kinetically significant states that would appear insignificant if all components were allowed to interact in a single ensemble. For large-scale structural engineering including the possibility of pseudoknots, each target test tube is unpseudoknotted, but by imposing sequence constraints between tubes, it is possible to collectively impose pseudoknotted design requirements. In a multi-tube design ensemble , each target test tube contains a set of desired \u201con-target\u201d complexes, each with a target secondary structure and target concentration, and a set of undesired \u201coff-target\u201d complexes, each with vanishing target concentration. Optimization of the multi-tube ensemble defect implements both a positive design paradigm, explicitly designing for on-pathway elementary steps, and a negative design paradigm, explicitly designing against off-pathway crosstalk. Defect weights can be specified to prioritize or de-priotize design quality for different portions of the design ensemble. Sequence design is performed subject to user-specified hard constraints (e.g., sequence constraints imposed by the reaction pathway or biological sequences) and soft constraints (e.g., design a set of toeholds to have comparable binding strength).","title":"Design Jobs"},{"location":"design/#specify-a-domain","text":"A domain is a set of consecutive nucleotides that appear as a subsequence of one or more strands in a design. A domain is specified as a sequence (specified 5 ' ' to 3 ' ' using degenerate nucleotide codes ) and a domain name (keyword name ). Consecutive repeats of a single nucleotide code can be represented by the nucleotide code followed by the total number of repeats: a = Domain ( 'AAAA' , name = 'a' ) b = Domain ( 'A4' , name = 'b' ) # equivalent sequence specification c = Domain ( 'NNNNNNNNNN' , name = 'c' ) d = Domain ( 'N10' , name = 'd' ) # equivalent sequence specification e = Domain ( 'RRRRRNNNNN' , name = 'e' ) f = Domain ( 'R5N5' , name = 'f' ) # equivalent sequence specification g = Domain ( 'N10' , name = 'g' ) The reverse complement of domain a is denoted ~a . Complementarity refers to Watson-Crick complementarity if wobble mutations are prohibited (default) or includes the possibility of G \\cdot \\cdot U wobble pairs for RNA if wobble mutations are permitted (see Job Options ). Note Note that starting with NUPACK 4 and the all-new NUPACK Python module, scripts no longer denote the reverse complement of domain a as a* because that would not be valid Python syntax.","title":"Specify a domain"},{"location":"design/#specify-a-target-strand","text":"A TargetStrand is a single RNA or DNA molecule specified as a sequence (specified 5 ' ' to 3 ' ' in terms of previously defined domains) and a target strand name (keyword name ): A = TargetStrand ([ a , b , g ], name = 'Strand A' ) B = TargetStrand ([ d , ~ e ], name = 'Strand B' ) # ~e denotes the reverse complement of e C = TargetStrand ([ e , a , f ], name = 'Strand C' ) D = TargetStrand ([ d , d , d ], name = 'Strand D' ) Additional fields and methods are available for a TargetStrand object: .domains : a tuple of the domains comprising the strand .ndomains() : the number of domains in the strand .nt() : the number of nucleotides in the strand For example: A . domains # --> (<Domain a>, <Domain b>, <Domain g>) A . ndomains () # --> 3 A . nt () # --> 18 The reverse complement of a TargetStrand maybe analogous obtained, for example, as ~A .","title":"Specify a target strand"},{"location":"design/#specify-a-target-complex","text":"A TargetComplex is an on- and/or off-target complex specified as an ordered list of strands (i.e., an ordering of strands around a circle in a polymer graph ) and a complex name (keyword name ). If the complex is to be used as an on-target complex in at least one target test tube, it is specified with an on-target secondary structure (specified in dot-parens-plus, run-length encoded dot-parens-plus, or DU+ notation): # dot-parens-plus notation C1 = TargetComplex ([ A , B , C ], '........((((((((((+))))))))))((((((((((+))))))))))..............' , name = 'C1' ) # run-length encoded dot-parens-plus notation C2 = TargetComplex ([ B , C ], '.10(10+)10.14' , name = 'C2' ) # DU+ notation C3 = TargetComplex ([ D , D ], 'D30 +' , name = 'C3' ) C4 = TargetComplex ([ B , B , B ], 'D10(D10 + D10 +)' , name = 'C4' ) C5 = TargetComplex ([ B , A , B ], 'D8(U12 +) D10(+) U10' , name = 'C5' ) Note The target structure will be used in all target test tubes in which a complex appears as an on-target complex and will be ignored in those target test tubes where a complex appears as an off-target complex. Additional fields and methods are available for a TargetComplex object: .strands : a tuple of the strands .nstrands() : the number of strands in the complex .nt() : the number of nucleotides in the complex For example: C1 . strands # --> (<TargetStrand Strand A>, <TargetStrand Strand B>, <TargetStrand Strand C>) C1 . nstrands () # --> 3 C1 . nt () # --> 62 In certain cases, it may be desirable to adjust the free energy of an on-target complex (for example, if a protein is known to stabilize the complex). For such cases, the optional keyword bonus can be used to specify an additional free energy in kcal/mol (default: 0; negative value is stabilizing, postive value is destabilizing): # destabilize C6 by 1 kcal/mol C6 = TargetComplex ([ B , C ], '.10(10+)10.14' , name = 'C6' , bonus =+ 1.0 ) # stabilize C7 by 10 kcal/mol C7 = TargetComplex ([ B , C ], '.10(10+)10.14' , name = 'C7' , bonus =- 10.0 ) Note Note that a bonus applied to the complex free energy is equivalent to applying the bonus to every structure free energy in the complex ensemble. As a result, the bonus alters the equilibrium complex concentration within the test tube ensemble , but does not alter the equilibrium base-pairing probabilities within the complex ensemble .","title":"Specify a target complex"},{"location":"design/#specify-a-target-tube","text":"A TargetTube is specified as a tube name (keyword name ) and a set of on-target complexes each with a target concentration (keyword on_targets ; units of M ). Off-target complexes (keyword off_targets : defaults to none) can be specified using SetSpec() in any of three ways: Combinatorially using keyword max_size to automatically generate the set of all complexes up to a specified number of strands (default: max_size=1 ). Using keyword include to include an explicitly specified set of complexes (default: None ). Using keyword exclude to exclude an explicitly specified set of complexes (default: None ). For example: t1 = TargetTube ( on_targets = { C1 : 1e-8 , C2 : 1e-8 }, name = 't1' , off_targets = SetSpec ( max_size = 3 , include = [[ B , B , B , B ]], exclude = [ C4 ])) If desired, the on-target and off-target sets for a specified TargetTube can be queried as follows: print ( t1 . on_targets ) # --> {<TargetComplex C1>: 1e-08, <TargetComplex C2>: 1e-08} print ( t1 . off_targets ) # --> {<TargetComplex (Strand A+Strand A+Strand B)>, <TargetComplex (Strand B)>, # <TargetComplex (Strand A+Strand A)>, <TargetComplex (Strand C+Strand B+Strand B)>, # <TargetComplex (Strand A+Strand B+Strand B)>, <TargetComplex (Strand A+Strand C+Strand C)>, # <TargetComplex (Strand C)>, <TargetComplex (Strand C+Strand C+Strand C)>, # <TargetComplex (Strand A+Strand C+Strand B)>, <TargetComplex (Strand C+Strand C)>, # <TargetComplex (Strand A+Strand C)>, <TargetComplex (Strand A+Strand A+Strand C)>, # <TargetComplex (Strand A)>, <TargetComplex (Strand B+Strand B)>, # <TargetComplex (Strand A+Strand B)>, <TargetComplex (Strand A+Strand A+Strand A)>, # <TargetComplex (Strand C+Strand C+Strand B)>, <TargetComplex (Strand B+Strand B+Strand B+Strand B)>} Note Note that include and exclude accept both target complex identifiers (e.g., C4 ) and strand orderings (e.g., [B, B, B, B] ). Note that for an off-target specified using a target complex identifier (e.g., C4 ), the target structure is ignored since by definition, there is no target structure for an off-target complex. Note that any complex included as an on-target complex will not be included as an off-target complex when processing max_size and include . Note Note that used together, max_size and exclude provide a powerful combination for specifying target test tubes . With max_size it is possible to specify a large set of off-target complexes formed from a set of system components. With exclude it is further possible to remove from this large set all of the cognate products that should form between these system components (so they appear as neither on-targets nor off-targets in the tube ensemble). For example, with this approach, the reactive species in a global crosstalk tube can be forced to either perform no reaction (remaining as desired on-targets) or to undergo a crosstalk reaction (forming undesired off-targets), enabling minimization of global crosstalk during sequence optimization. An ensemble that excludes cognate reaction products can never be studied in the lab but provides a important framework for computational sequence optimization.","title":"Specify a target tube"},{"location":"design/#run-a-test-tube-design-job","text":"The tube_design class performs constrained multi-tube design for a specified set of target test tubes (keyword tubes ) and a specified physical model (keyword model ). You may optionally: specify hard constraints (keyword hard_constraints ), specify soft constraints (keyword soft_constraints ), specify defect weights (keyword defect_weights ), and specify job options (keyword options ): my_model = Model () my_tubes = [ t1 ] my_design = tube_design ( tubes = my_tubes , hard_constraints = [], soft_constraints = [], defect_weights = None , options = None , model = my_model ) A tube_design object supports two methods for performing sequence design: run() : run multiple independent design trials in the foreground . launch() : launch multiple independent design trials in the background and save design progress to checkpoint files. Either method can be used to restart from a previous design result (keyword restart ). See below for examples using run() and launch() for the above tube_design job. Note run() is a blocking command that is convenient when you want to run a single quick design trial and wait for the results. launch() is a non-blocking command that offers the preferred mode of operation for large design jobs, enabling you to run long design trials in the background with built-in checkpointing.","title":"Run a test tube design job"},{"location":"design/#run-design-trials-in-the-foreground","text":"Once a test tube design has been specified using tube_design , use run() to run a specified number of independent design trials (keyword trials ) in parallel in the foreground and return a list of DesignResult objects: my_results = my_design . run ( trials = 2 ) # run 2 independent design trials A DesignResult object can be viewed as a table in a Jupyter notebook, for example: my_results [ 0 ] # display results table for first design trial Output: Output table displays: Designed sequences for each domain and strand. Objective function components (weighted ensemble defect and weighted soft constraints (if applicable)). Ensemble defect (unweighted). Complex defect for each on-target in the ensemble (unweighted). Tube defect for each tube in the ensemble (unweighted). Structural defect, concentration defect, and total defect for each on-target complex in each tube (unweighted). Concentration and target concentration for each on-target complex in each tube. Significant off-target complex concentrations in each tube (those off-targets with concentration \\ge \\ge 1% the maximum complex concentration in the tube). The keyword restart may be included to run a design by providing a list of DesignResult objects from a previous design job: new_results = my_design . run ( trials = 2 , restart = my_results ) An error will be thrown if trials and restart specify different numbers of design trials and DesignResult objects.","title":"Run design trials in the foreground"},{"location":"design/#launch-design-trials-in-the-background","text":"Once a test tube design has been specified using tube_design , use launch() to start a specified number of independent design trials (keyword trials ) in parallel in the background. Intermediate results will be saved to a directory specified with keyword checkpoint at a regular interval specified with keyword interval (in seconds, default 600): # start 2 independent design trials my_jobs = my_design . launch ( trials = 2 , checkpoint = 'my_checkpoints' , interval = 600 ) Whereas run() returns a list of DesignResult objects representing completed design trials, launch() returns a list of trial monitors. The design trials will continue in the background. To examine current results based on the latest checkpoint file for each trial, use the current_results() method: my_current_results = my_jobs . current_results () which returns a list with an entry for each trial that is either a DesignResult object (if a checkpoint file or final result is available) or None (otherwise). As illustrated above, a DesignResult object can be viewed as a table in a Jupyter notebook. For example if a checkpoint is available for the first trial, a table is generated by typing: my_current_results [ 0 ] # display results table for first design trial If only final results are of interest, use the final_results() method: my_final_results = my_jobs . final_results () which returns a list with an entry for each trial that is either a DesignResult object (if a final result is available) or None (otherwise). To lock up the interface and wait for all trials to finish, use the wait() method to return a list of DesignResult objects: my_final_results = my_jobs . wait () To stop all trials, use the stop() method: my_jobs . stop () To restart designs from previous results, use the restart keyword, providing either a list of DesignResult objects from a previous design, or a directory name containing checkpoint files: # restart from a list of DesignResult objects my_jobs = my_design . launch ( trials = 2 , checkpoint = 'new_checkpoints' , restart = my_current_results ) # restart from a checkpoint directory my_jobs = my_design . launch ( trials = 2 , checkpoint = 'new_checkpoints' , restart = 'my_checkpoints' ) An error will be returned if trials and restart specify different numbers of design trials and DesignResult objects. However, if no results exist in the supplied restart directory, the design will be started afresh without any error messages. Hence, you can create a rerunnable design by supplying the same directory to checkpoint and restart : my_jobs = my_design . launch ( trials = 2 , checkpoint = 'my_checkpoints' , restart = 'my_checkpoints' )","title":"Launch design trials in the background"},{"location":"design/#run-a-complex-design-job","text":"The complex_design class enables specification of a constrained multi-complex design for a specified set of target complexes (keyword complexes ) and a specified physical model (keyword model ). You may optionally: specify hard constraints (keyword hard_constraints ), specify soft constraints (keyword soft_constraints ), specify defect weights (keyword defect_weights ), and specify job options (keyword options ): my_model = Model () my_complexes = [ C1 , C2 ] my_design = complex_design ( complexes = my_complexes , hard_constraints = [], soft_constraints = [], defect_weights = None , options = None , model = my_model ) result = my_design . run ( trials = 2 ) # run 2 independent design trials in the foreground result [ 0 ] Output: A complex_design object supports the launch() , run() , and evaluate() methods just as for a tube_design object (see above). Note Note that a complex_design job is equivalent to a tube_design job with each on-target complex placed in a separate test tube containing no off-target complexes. For this reason, we strongly recommend use of test tube design formulations over complex design formulations so that off-target complexes are present in the design ensemble and the design algorithm can actively design against their formation.","title":"Run a complex design job"},{"location":"design/#specify-hard-constraints","text":"Hard constraints for a design job are specified as a list, for example: # specify domains a = Domain ( 'N4' , name = 'a' ) b = Domain ( 'N4' , name = 'b' ) c = Domain ( 'N5' , name = 'c' ) d = Domain ( 'N5' , name = 'd' ) e = Domain ( 'N5' , name = 'e' ) f = Domain ( 'N5' , name = 'f' ) A = TargetStrand ([ a , b , c ], name = 'A' ) # source sequence for window constraint gfp = 'auggugagcaagggcgaggagcuguucaccgggguggugcccauccuggucgagcuggacggcgacguaaacggccacaaguucagcguguccggcgagggcgagggcgaugccaccuacggcaagcugacccugaaguucaucugcaccaccggcaagcugcccgugcccuggcccacccucgugaccacccugaccuacggcgugcagugcuucagccgcuaccccgaccacaugaagcagcacgacuucuucaaguccgccaugcccgaaggcuacguccaggagcgcaccaucuucuucaaggacgacggcaacuacaag' # define list of hard constraints my_hard_constraints = [ Match ([ a ], [ b ]), Match ([ a , b , f , f ], [ d , a , d , a ]), Complementarity ([ a , b , f , a , a , b ], [ c , d , e , c , c ], wobble_mutations = True ), Similarity ([ c ], 'S5' , limits = [ 0.2 , 0.8 ]), # GC content Library ([ a ], catalog = [[ 'CTAC' , 'TAAT' ]]), Window ([ a , ~ b ], sources = [ gfp ]), Pattern ([ 'A5' , 'C5' , 'G5' , 'U5' ], scope = A ), Pattern ([ 'A4' , 'C4' , 'G4' , 'U4' , 'M6' , 'K6' , 'W6' , 'S6' , 'R6' , 'Y6' ]), Diversity ( word = 4 , types = 2 ), Diversity ( word = 6 , types = 3 ), Diversity ( word = 10 , types = 4 , scope = [ a , b ]) ] #two ways to add another constraint to the constraint set my_hard_constraints += [ Complementarity ([ e ], [ f ], wobble_mutations = True )] my_hard_constraints . append ( Complementarity ([ e ], [ f ], wobble_mutations = True )) Note Note that the specification of a domain using degenerate nucleotide codes (as in the example above) is an implicit hard sequence constraint. Note Note that NUPACK will return an error if a design specification contains a fixed sequence that violates a hard constraint See below for information about how to specify each type of hard constraint.","title":"Specify hard constraints"},{"location":"design/#match","text":"A match constraint forces equal-length concatenations of one or more domains to be identical. A Match hard constraint is specified as follows: a first list of domains for concatenation; alternatively, a target strand may be specified a second list of domains for concatenation; alternatively, a target strand may be specified a = Domain ( 'N10' , name = 'a' ) b = Domain ( 'N4' , name = 'b' ) c = Domain ( 'H6' , name = 'c' ) d = Domain ( 'N6' , name = 'd' ) e = Domain ( 'S2' , name = 'e' ) A = TargetStrand ([ a , b ], name = 'Strand A' ) match1 = Match ([ c ], [ b , ~ e ]) # ~e is the reverse complement of e match2 = Match ([ a , b ], [ d , d , e ]) # specifying target strand A is equivalent to specifying list of domains [a, b] match3 = Match ( A , [ d , d , e ]) Note Constraints that expect a list of domains for concatenation will alternatively accept a target strand.","title":"Match"},{"location":"design/#complementarity","text":"A complementarity constraint forces a concatenation of one list of domains to be the reverse complement of an equal-length concatenation of another list of domains. A Complementarity hard constraint is specified as: a first list of domains for concatenation; alternatively, a target strand may be specified a second list of domains for concatenation; alternatively, a target strand may be specified comp1 = Complementarity ([ a , b ], [ c , d , e ]) # specifying target strand A is equivalent to specifying list of domains [a, b] comp2 = Complementarity ( A , [ c , d , e ]) Note Nucleotides that are base-paired in the target structure of an on-target complex are automatically assigned a complementarity constraint. By default, complementary sequences are required to have Watson-Crick base-pairing (A \\cdot \\cdot U or C \\cdot \\cdot G for RNA, A \\cdot \\cdot T or C \\cdot \\cdot G for DNA). To permit wobble mutations for RNA (G \\cdot \\cdot U) globally throughout a design, use the wobble_mutations job option . Alternatively, wobble mutations can be allowed for individual complementarity constraints (keyword wobble_mutations , default: False ): comp2 = Complementarity ([ a , b ], [ c , d , e ], wobble_mutations = True ) It is also possible to force base pairs to be wobble pairs: f = Domain ( 'S2' , name = 'f' ) g = Domain ( 'S2' , name = 'g' ) comp3 = Complementarity ([ f ], [ g ], wobble_mutations = True )","title":"Complementarity"},{"location":"design/#similarity","text":"A similarity constraint forces a concatentation of domains to match a reference sequence of the same length to within a specified fractional range. A Similarity hard constraint is specified as: a list of domains to be concatenated; alternatively a target strand may be specified a reference sequence of the same length as the concatenated domains a fractional range, [l, u] [l, u] , where 0 \\leq l < u \\leq 1 0 \\leq l < u \\leq 1 a = Domain ( 'N10' , name = 'a' ) b = Domain ( 'N20' , name = 'b' ) C = TargetStrand ([ a , b , a ], name = 'Strand C' ) # similarity constraint for a concatenation of domains sim1 = Similarity ([ a , ~ a , b ], 'S5K35' , limits = [ 0.25 , 0.75 ]) # similarity constraint for a target strand sim2 = Similarity ( C , 'S30K10' , limits = [ 0.25 , 0.75 ]) # for a strand # use similarity constraint to enforce 45-55% GC content sim3 = Similarity ([ a , b ], 'S30' , limits = [ 0.45 , 0.55 ]) Note A similarity constraint can be used to constrain sequence composition (e.g., 45-55% GC content as in the example above).","title":"Similarity"},{"location":"design/#window","text":"A window constraint forces a concatenation of domains to have a sequence that is a subsequence of a source sequence. More generally, a window can be drawn from any of multiple source sequences. A Window hard constraint is specified as: Define one or more source sequences as strings. Specify a list of domains for concatenation; alternatively, specify a target strand Specify a list of sources from which the window should be selected a = Domain ( 'N10' , name = 'a' ) b = Domain ( 'N10' , name = 'b' ) c = Domain ( 'N10' , name = 'c' ) e = Domain ( 'N10' , name = 'e' ) A = TargetStrand ([ a , ~ b ], name = 'Strand A' ) gfp = 'AUGGUGAGCAAGGGCGAGGAGCUGUUCACCGGGGUGGUGCCCAUCCUGGUCGAGCUGGACGGCGACGUAAACGGCCACAAGUUCAGCGUGUCCGGCGAGGGCGAGGGCGAUGCCACCUACGGCAAGCUGACCCUGAAGUUCAUCUGCACCACCGGCAAGCUGCCCGUGCCCUGGCCCACCCUCGUGACCACCCUGACCUACGGCGUGCAGUGCUUCAGCCGCUACCCCGACCACAUGAAGCAGCACGACUUCUUCAAGUCCGCCAUGCCCGAAGGCUACGUCCAGGAGCGCACCAUCUUCUUCAAGGACGACGGCAACUACAAG' rfp = 'CCUGCAGGACGGCGAGUUCAUCUACAAGGUGAAGCUGCGCGGCACCAACUUCCCCUCCGACGGCCCCGUAAUGCAGAAGAAGACCAUGGGCUGGGAGGCCUCCUCCGAGCGGAUGUACCCCGAGGACGGCGCCCUGAAGGGCGAGAUCAAGCAGAGGCUGAAGCUGAAGGACGGCGGCCACUACGACGCUGAGGUCAAGACCACCUACAAGGCCAAGAAGCCCGUGCAGCUGCCCGGCGCCUACAACGUCAACAUCAAGUUGGACAUCACCUCCCACAACGAGGACUACACCAUCGUGGAACAGUACGAACGCGCCGAGGGCCGCCACUCCACCGGCGGCAUGGACGAGCUGUACAAGUAA' # constrain window to be drawn from a source window1 = Window ([ a , ~ b ], sources = [ gfp ]) # window constraint for a target strand window2 = Window ( A , sources = [ gfp ]) # constrain window to be drawn from more either of two sources window3 = Window ([ ~ c , e ], sources = [ gfp , rfp ])","title":"Window"},{"location":"design/#library","text":"A library constraint forces a concatenated list of domains to have sequences drawn from a concatenated list of libraries. Each library contains a set of alternative sequences of equal length. A Library hard constraint is specified as: Define one or more libraries of alternative sequences of uniform length. Specify a list of domains for concatentation; alternatively, specify a target strand Specify a list of libraries for concatenation The sum of the length of the domains must equal the sum of the length of the libraries (where we define the length of a library to be the length of any of its elements). a = Domain ( 'N6' , name = 'a' ) b = Domain ( 'N10' , name = 'b' ) c = Domain ( 'N2' , name = 'c' ) d = Domain ( 'N3' , name = 'd' ) e = Domain ( 'N3' , name = 'e' ) A = TargetStrand ([ d , e ], name = 'Strand A' ) # define a library of sequences toeholds = [ 'CAGUGG' , 'AGCUCG' , 'CAGGGC' ] # define a library of codons for each amino acid aaI = [ 'AUU' , 'AUC' , 'AUA' ] aaL = [ 'CUU' , 'CUC' , 'CUA' , 'CUG' , 'UUA' , 'UUG' ] aaV = [ 'GUU' , 'GUC' , 'GUA' , 'GUG' ] aaF = [ 'UUU' , 'UUC' ] aaM = [ 'AUG' ] aaC = [ 'UGU' , 'UGC' ] aaA = [ 'GCU' , 'GCC' , 'GCA' , 'GCG' ] aaG = [ 'GGU' , 'GGC' , 'GGA' , 'GGG' ] aaP = [ 'CCU' , 'CCC' , 'CCA' , 'CCG' ] aaT = [ 'ACU' , 'ACC' , 'ACA' , 'ACG' ] aaS = [ 'UCU' , 'UCC' , 'UCA' , 'UCG' , 'AGU' , 'AGC' ] aaY = [ 'UAU' , 'UAC' ] aaW = [ 'UGG' ] aaQ = [ 'CAA' , 'CAG' ] aaN = [ 'AAU' , 'AAC' ] aaH = [ 'CAU' , 'CAC' ] aaE = [ 'GAA' , 'GAG' ] aaD = [ 'GAU' , 'GAC' ] aaK = [ 'AAA' , 'AAG' ] aaR = [ 'CGU' , 'CGC' , 'CGA' , 'CGG' , 'AGA' , 'AGG' ] aaSTOP = [ 'UAA' , 'UAG' , 'UGA' ] # domain a is drawn from a toehold library lib1 = Library ([ a ], [ toeholds ]) # target strand A is drawn from a toehold library lib1 = Library ( A , [ toeholds ]) # concatenation [b, c] is drawn from a concatenation of 4 codon libraries lib2 = Library ([ b , c ], [ aaI , aaM , aaC , aaG ])","title":"Library"},{"location":"design/#pattern-prevention","text":"A pattern prevention constraint prevents a list of patterns from appearing globally or in a concatenated list of domains. A Pattern hard constraint is specified as: a list of patterns to be prevented optionally a list of domains for concatenation (keyword scope ) where the patterns should be prevented; alternatively, a target strand may be specified if the scope is unspecified (absence of keyword scope ), the constraint is global a = Domain ( 'N12' , name = 'a' ) b = Domain ( 'N12' , name = 'b' ) A = TargetStrand ([ a , ~ a ], name = 'A' ) B = TargetStrand ([ b , ~ b ], name = 'B' ) # pattern prevention for concatenation [a, b] pattern1 = Pattern ([ 'A4' , 'U4' ], scope = [ a , b ]) # pattern prevention for target strand B pattern2 = Pattern ([ 'A4' , 'U4' ], scope = B ) # global pattern prevention pattern3 = Pattern ([ 'A4' , 'C4' , 'G4' , 'U4' , 'M6' , 'K6' , 'W6' , 'S6' , 'R6' , 'Y6' ])","title":"Pattern Prevention"},{"location":"design/#diversity","text":"A diversity constraint forces every word of a specified length to contain a specified degree of sequence diversity, either globally or for a concatenated list of domains. A Diversity hard constraint is specified as: the word length in nucleotides (keyword word ) the minimum number of nucleotide types that must appear in every window (keyword types ) optionally a list of domains for concatenation (keyword scope ) where the diversity should be imposed; alternatively, a target strand may be specified if the scope is unspecified (absence of keyword scope ), the constraint is global a = Domain ( 'N12' , name = 'a' ) b = Domain ( 'N12' , name = 'b' ) A = TargetStrand ([ a , ~ a ], name = 'A' ) C = TargetComplex ([ A , A ], name = 'A+A' ) # global constraints div1 = Diversity ( word = 4 , types = 2 ) div2 = Diversity ( word = 6 , types = 3 ) # local constraint on concatenation [a, b] div3 = Diversity ( word = 10 , types = 4 , scope = [ a , b ]) # local constraint on target strand A div4 = Diversity ( word = 10 , types = 4 , scope = A ) Note A diversity constraint that forces every window of length 4 to contain at least 2 nucleotide types is equivalent to a pattern prevention contraint that prevents patterns: AAAA, CCCC, GGGG, UUUU. Likewise, a diversity constraint that forces every window of length 6 to contain at least 3 nucleotide types is equivalent to a pattern prevention constraint that prevents: MMMMMM, KKKKKK, WWWWWW, SSSSSS, RRRRRR, YYYYYY. We recommend diversity constraints over pattern prevention constraints because they make it more efficient to solve the constraint satisfaction problem that identifies a new validate candidate mutation at every step during sequence optimization. The global constraints div1 and div2 reproduce the global pattern prevention constraint pattern3 .","title":"Diversity"},{"location":"design/#specify-soft-constraints","text":"Soft constraints for a design job are specified as a list, for example: # define soft for soft constraints my_soft_constraints = [ Pattern ([ 'A4' , 'U4' ], scope = a ), Pattern ([ 'A5' , 'C5' , 'G5' , 'U5' ], scope = A ), # default weight 1 Pattern ([ 'A4' , 'C4' , 'G4' , 'U4' , 'M6' , 'K6' , 'W6' , 'S6' , 'R6' , 'Y6' ], weight = 0.5 ), Similarity ([ b ], 'S12' , limits = [ 0.45 , 0.55 ], weight = 0.25 ), SSM ( word = 4 , scope = [ C ], weight = 0.15 ), EnergyMatch ([ a , b ]), # min energy diff to median EnergyMatch ([ a , b ], energy_ref =- 17 , weight = 0.5 ) # energy diff to reference ]","title":"Specify soft constraints"},{"location":"design/#similarity_1","text":"Similarity soft constraints are specified in nearly the same way as similarity hard constraints. The primary difference is that a weight can be supplied to control the relative design effort spent on the soft constraint. A similarity constraint penalizes a concatentation of domains if it does not match a reference sequence of the same length to within a specified fractional range. A Similarity soft constraint is specified as: a list of domains to be concatenated; alternatively a target strand may be specified a reference sequence of the same length as the concatenated domains a fractional range, [l, u] [l, u] , where 0 \\leq l < u \\leq 1 0 \\leq l < u \\leq 1 an optional weight \\in[0,\\infty) \\in[0,\\infty) (default: 1) that can be used to prioritize or de-prioritize design effort a = Domain ( 'N10' , name = 'a' ) b = Domain ( 'N20' , name = 'b' ) C = TargetStrand ([ a , b , a ], name = 'Strand C' ) # similarity constraint for a concatenation of domains sim1 = Similarity ([ a , ~ a , b ], 'S5K35' , limits = [ 0.25 , 0.75 ]) # similarity constraint for a target strand sim2 = Similarity ( C , 'S30K10' , limits = [ 0.25 , 0.75 ], weight = 2.0 ) # for a strand # use similarity constraint to enforce 45-55% GC content sim3 = Similarity ([ a , b ], 'S30' , limits = [ 0.45 , 0.55 ], weight = 0.25 )","title":"Similarity"},{"location":"design/#pattern-prevention_1","text":"A pattern prevention constraint penalizes a list of patterns from appearing globally or in a concatenated list of domains. A Pattern soft constraint is specified as: a list of patterns to be prevented optionally a list of domains for concatenation (keyword scope ) where the patterns should be prevented; alternatively, a target strand may be specified if the scope is unspecified (absence of keyword scope ), the constraint is global an optional weight \\in[0,\\infty) \\in[0,\\infty) (default: 1) that can be used to prioritize or de-prioritize design effort a = Domain ( 'N12' , name = 'a' ) b = Domain ( 'N12' , name = 'b' ) A = TargetStrand ([ a , ~ a ], name = 'A' ) B = TargetStrand ([ b , ~ b ], name = 'B' ) # pattern prevention for concatenation [a, b] pattern1 = Pattern ([ 'A4' , 'U4' ], scope = [ a , b ], weight = 2.0 ) # pattern prevention for target strand B pattern2 = Pattern ([ 'A4' , 'U4' ], scope = B ) # global pattern prevention pattern3 = Pattern ([ 'A4' , 'C4' , 'G4' , 'U4' , 'M6' , 'K6' , 'W6' , 'S6' , 'R6' , 'Y6' ], weight = 0.5 )","title":"Pattern prevention"},{"location":"design/#sequence-symmetry","text":"A sequence symmetry constraint penalizes a subsequence of a specified word length if the word appears in more than one location, if its reverse complement appears elsewhere in a location that is not intended to form a duplex with the word, or if the word is self-complementary. An SSM soft constraint is specified as: the word length in nucleotides (keyword word ) optionally a list of on-target complexes (keyword scope ) where the constraint should apply if the scope is unspecified (absence of keyword scope ), the constraint is global an optional weight \\in[0,\\infty) \\in[0,\\infty) (default: 1) that can be used to prioritize or de-prioritize design effort a = Domain ( 'N12' , name = 'a' ) b = Domain ( 'N12' , name = 'b' ) A = TargetStrand ([ a , ~ a ], name = 'A' ) B = TargetStrand ([ b , ~ b ], name = 'B' ) C = TargetComplex ([ A ], \"(10.4)10\" , name = 'C' ) D = TargetComplex ([ A , A ], \"D24 +\" , name = 'D' ) # multiple SSM constraints with different word lengths applied to the same complexes ssm1 = SSM ( word = 4 , scope = [ C , D ], weight = 0.15 ) ssm2 = SSM ( word = 5 , scope = [ C , D ], weight = 0.25 ) ssm3 = SSM ( word = 6 , scope = [ C , D ], weight = 0.45 ) #global SSM constraint applies to all on-target complexes in the design ssm4 = SSM ( word = 6 , weight = 0.5 ) Note Multiple SSM constraints with different window sizes can be specified for a given complex (see example above).","title":"Sequence symmetry"},{"location":"design/#energy-match","text":"An energy match constraint penalizes a set of duplexes if their structure free energies deviate from the median value, or alternatively deviate from a specified reference free energy. An EnergyMatch soft constraint is specified as: a list of domains, each to be evaluated as a duplex with its reverse complement an optional reference free energy in kcal/mol (keyword energy_ref ) an optional weight \\in[0,\\infty) \\in[0,\\infty) (default: 1) that can be used to prioritize or de-prioritize design effort a = Domain ( 'N12' , name = 'a' ) b = Domain ( 'N12' , name = 'b' ) c = Domain ( 'N12' , name = 'c' ) d = Domain ( 'N12' , name = 'd' ) # match each duplex free energy to the median value diff1 = EnergyMatch ([ a , b , c , d ]) # match each duplex free energy to the specified reference free energy diff2 = EnergyMatch ([ a , b , c , d ], energy_ref =- 17 , weight = 0.5 ) Note An energy match constraint can be used to design a set of toeholds of comparable strength.","title":"Energy match"},{"location":"design/#specify-defect-weights","text":"Defect weights can be specified to reprioritize design effort at any subset of levels (tube, complex, strand, domain) within design ensemble. A Weights object is created for the set of TargetTube objects to be designed: a1 = Domain ( 'N5' , name = 'a1' ) a2 = Domain ( 'N5' , name = 'a2' ) b = Domain ( 'N10' , name = 'b' ) A = TargetStrand ([ a1 , a2 ], name = 'A' ) B = TargetStrand ([ b ], name = 'B' ) AB = TargetComplex ([ A , B ], structure = '(10+)10' , name = 'AB' ) AA = TargetComplex ([ A , A ], structure = '(10+)10' , name = 'AA' ) t1 = TargetTube ({ AB : 1e-8 }, name = 't1' ) t2 = TargetTube ({ AA : 1e-9 , AB : 1e-10 }, name = 't2' ) my_tubes = [ t1 , t2 ] weights = Weights ( my_tubes ) # All weights are initialized to 1 The weights are initialized to 1, but can be customized to take any value in the interval [0,\\infty) [0,\\infty) . Weights can be manipulated by slicing on any subset of 4 indices (in the following order: Domain, TargetStrand, TargetComplex, TargetTube). For example: # weight on domain a1 in all target strands, target complexes, and target tubes weights [ a1 ] *= 2 # weight on target strand A in all target conplexes and target tubes weights [:, A ] = 4 # weight on tube t2 weights [:, :, :, t2 ] = 2 # weight on target complex AB in tube t1 weights [:, :, AB , t1 ] = 5 # weight on domain a2 in target strand A in all target complexes in all tubes weights [ a2 , A ] = 0.75 # weight on domain a1 in all target strands in target complex AA in tube t2 weights [ a1 , :, AA , t2 ] = 0.5 # weight on domain b in all target strands and target complexes in tube t2 weights [ b , :, :, t2 ] = 3 # global weight on the entire multi-tube ensemble defect weights [:] *= 2 Note Note that multi-tube ensemble defect \\mathcal{M} \\mathcal{M} varies between 0 and 1 so that specifying an increasing number of soft constraints in the augmented objective function will increasingly de-emphasize design effort on the ensemble defect. Specifying a global weight as part of the weighted ensemble defect \\mathcal{M_W} \\mathcal{M_W} (see example above) can be used to balance effort on the ensemble defect against effort on the soft constraints. A Weights object may be displayed as a table in a Jupyter notebook, for example: weights Output: Alternatively, you can view an ASCII representation of the same data by using the print function: print ( weights ) Output: Domain Strand Complex Tube Weight a1 A AA t2 1.0 a1 A AB t1 10.0 a1 A AB t2 4.0 a2 A AA t2 1.5 a2 A AB t1 1.5 a2 A AB t2 1.5 b B AB t1 10.0 b B AB t2 6.0 For experienced Python users, a Weights object contains a pandas.DataFrame as a single member .table . Note For a complex design job , the Weights object is generated for a set of on-target complexes, in which case the 4th index (for tubes) is omitted: my_complexes = [ AB , AA ] complex_weights = Weights ( my_complexes ) # weight on domain a1 in all target strands and target complexes complex_weights [ a1 ] *= 2 # weight on target strand A in all target complexes complex_weights [:, A ] = 4 # weight on domain a2 in target strand A in target complex AA complex_weights [ a2 , A , AA ] = 0.75","title":"Specify defect weights"},{"location":"design/#job-options","text":"Specify any non-default job options (See Supp Info of [ Wolfe17 ] for details). Defaults are shown below: options = DesignOptions ( f_stop = 0.02 , # stop condition for sequence optimization seed = 0 , # random seed if 0; specified seed otherwise (reproducible trial) H_split = 2 , # default: 2 for RNA, 3 for DNA and custom N_split = 12 , f_split = 0.99 , # in interal (0,1) f_stringent = 0.99 , # in interval (0,1) dG_clamp =- 20 , # kcal/mol M_bad = 300 , M_reseed = 50 , M_reopt = 3 , f_passive = 0.01 , # in interval (0,1) f_redecomp = 0.03 , # in interval (0,1) f_refocus = 0.03 , # in interval (0,1) f_sparse = 1e-05 , # threshold pair probs for sparse storage in decomposition tree wobble_mutations = False , # allow wobble pairs in user-assigned domain complements (e.g. between a and a*/~a) max_time = 0 , # max design time in seconds (if nonzero) ) Note Enable wobble_mutations (default False ) so that the designer will consider sequences which may 1) yield wobble ( GU ) pairs in target structures and 2) contain wobble complements in domain reverse complements (e.g. a = GGG , a* = UUU ). Note Set max_time to a positive number to manually control how long a design will take (in seconds). Note that this time limit is somewhat loose as the designer will only stop at timepoints in which the current design may be fully evaluated. Consider using checkpointing as an alternative to optimize the tradeoff between design quality and CPU time. Note Change f_stop to adjust the stop condition for sequence optimization. For multi-tube ensembles with many sequence constraints (especially biological sequence constraints) you may need to increase the stop condition. options = DesignOptions ( f_stop = 0.05 ) By default, NUPACK design jobs run in parallel .","title":"Job options"},{"location":"design/#job-results","text":"The results of NUPACK design jobs can be conveniently displayed as a table, printed as text, or introspected programmatically. Consider the following test tube design job: a = Domain ( 'N20' , name = 'a' ) A = TargetStrand ([ a ], name = 'A' ) B = TargetStrand ([ ~ a ], name = 'B' ) C = TargetComplex ([ A , B ], '(20+)20' , name = 'C' ) tube1 = TargetTube ({ C : 1e-6 }, off_targets = SetSpec ( max_size = 2 ), name = 'tube1' ) soft = [ Similarity ([ a ], 'S20' , limits = [ 0.45 , 0.55 ], weight = 0.05 )] hard = [ Diversity ( word = 4 , types = 2 , scope = [ a ])] my_design = tube_design ([ tube1 ], model = Model (), soft_constraints = soft , hard_constraints = hard ) my_result = my_design . run ( trials = 1 )[ 0 ]","title":"Job results"},{"location":"design/#tabular-display","text":"You can display a summary table of results in a Jupyter notebook, for example: my_result Output:","title":"Tabular display"},{"location":"design/#textual-display","text":"You can view an ASCII representation of the same data by using the print function: print ( my_result ) Output: Domain results: Domain Sequence a GGGUGCAAAGGUAUGGGAGG a* CCUCCCAUACCUUUGCACCC Strand results: Strand Sequence A GGGUGCAAAGGUAUGGGAGG B CCUCCCAUACCUUUGCACCC Objective function: Objective type Value Weighted ensemble defect 0.00771 Soft constraints: similarity 0.00556 Total 0.0133 Ensemble defect: 0.00771 Complex Complex defect (nt) Normalized complex defect C 0.308 0.00771 On-target complex defects: Tube Tube defect (M) Normalized tube defect tube1 3.08e-07 0.00771 Tube defects: Tube On-target complex Structural defect (M) Concentration defect (M) Total defect (M) tube1 C 3.08e-07 8.73e-16 3.08e-07 On-target complex concentrations: Tube Complex Concentration (M) Target concentration (M) tube1 C 1.00e-06 1.00e-06 Significant off-target complex concentrations (>= 1% max complex concentration in tube): Tube Complex Concentration (M) tube1 - -","title":"Textual display"},{"location":"design/#programmatic-access","text":"A DesignResult object allows programmatic access via several fields: .to_analysis : a mapping from an object to be designed ( Domain , TargetStrand , TargetComplex , TargetTube ) specified in terms of degenerate nucleotide codes to the corresponding object containing the designed sequences ( Domain , Strand , Complex , Tube ). These objects are useful for re-analyzing designed sequences in different experimental conditions (with the exception of Domain which is not used for analysis jobs). .defects : ensemble defects at all levels within the design ensemble (each as a pandas.DataFrame ). .concentrations : concentration information for on-target complex and significant off-target complexes. .analysis_result : an AnalysisResult for thermodynamic results computed on the designed ensemble. .domains : a dict from your input domains to their designed equivalents. You can easily retrieve the designed sequences as a simple dict via a usage like {k.name: str(v) for k, v in my_result.domains.items()} . Fields may be displayed individually, for example: my_result . to_analysis Output: my_result . defects Output: my_result . concentrations Output: my_result . analysis_result Output: You can query any field of the DesignResult using Python, for example: # print various designed sequences print ( my_result . to_analysis ( tube1 )) # --> Tube({A: 1e-06, B: 1e-06}, name='tube1') print ( my_result . to_analysis ( C )) # --> GGGUGCAAAGGUAUGGGAGG+CCUCCCAUACCUUUGCACCC print ( my_result . to_analysis ( B )) # --> CCUCCCAUACCUUUGCACCC print ( my_result . to_analysis ( a )) # --> GGGUGCAAAGGUAUGGGAGG # print specific defect contributions print ( my_result . defects . ensemble_defect ) # 0.007708701513018191 print ( my_result . defects . tubes ) # --> each tube print ( my_result . defects . complexes ) # --> each on-target print ( my_result . defects . tube_complexes ) # --> each on-target in each tube Each subfield ( tubes , complexes , tube_complexes ) is a pandas.DataFrame s. For convenience, these tables contain Python objects and the corresponding object name (e.g., tube object and corresponding tube_name string).","title":"Programmatic access"},{"location":"design/#evaluate-a-design","text":"The evaluate() method enables generation of a DesignResult object for a tube_design that has fully specified sequences (i.e., contains no degenerate nucleotide codes ), for example: a = Domain ( 'CAGAUAAGAACUGAGUAAGC' , name = 'a' ) A = TargetStrand ([ a ], name = 'A' ) B = TargetStrand ([ ~ a ], name = 'B' ) C = TargetComplex ([ A , B ], '(20+)20' , name = 'C' ) tube1 = TargetTube ({ C : 1e-6 }, off_targets = SetSpec ( max_size = 2 ), name = 'tube1' ) soft = [ Similarity ([ a ], 'S20' , limits = [ 0.45 , 0.55 ], weight = 0.05 )] hard = [ Diversity ( word = 4 , types = 2 , scope = [ a ])] my_evaluated_design = tube_design ([ tube1 ], model = Model (), soft_constraints = soft , hard_constraints = hard ) my_evaluated_result = my_evaluated_design . evaluate () An exception will be raised if any domain contains nucleotides other than ACGTU , or if the hard constraints are incompatible with the given domains. Just as for any DesignResult object, a convenient results table can be displayed in a Jupyter notebook: my_evaluated_result Output: Note Consider using the evaluate() method on an RNA design that was performed with wobble_mutations enabled and that uses both domain a and the reverse complement domain ~a in the specification of the design ensemble. Then the definition of the reverse complement domain ~a is not fully defined since a G in domain a could be paired to either a C or a U in the final designed version of ~a . This ambiguity can be overcome by manually defining ~a using the complement keyword: h = Domain ( 'GGGG' , name = 'h' ) print ( ~ h ) # --> CCCC i = Domain ( 'GGGG' , name = 'i' , complement = 'CUUC' ) print ( ~ i ) # --> CUUC The evaluate() method will raise an exception if wobble_mutations are active and a reverse complement domain has not been manually defined. The following example demonstrates use of the complement keyword to enable evaluation of a design performed with wobble_mutations enabled: a = Domain ( 'CAGAUAAGAACUGAGUAAGC' , complement = 'GCUUAUUCAGUUCUUAUCUG' , name = 'a' ) A = TargetStrand ([ a ], name = 'A' ) B = TargetStrand ([ ~ a ], name = 'B' ) C = TargetComplex ([ A , B ], '(20+)20' , name = 'C' ) tube1 = TargetTube ({ C : 1e-6 }, off_targets = SetSpec ( max_size = 2 ), name = 'tube1' ) soft = [ Similarity ([ a ], 'S20' , limits = [ 0.45 , 0.55 ], weight = 0.05 )] hard = [ Diversity ( word = 4 , types = 2 , scope = [ a ])] options = DesignOptions ( wobble_mutations = True ) wobble_design = tube_design ([ tube1 ], model = Model ( material = 'rna' ), soft_constraints = soft , hard_constraints = hard , options = options ) wobble_result = wobble_design . evaluate ()","title":"Evaluate a design"},{"location":"design/#evaluate-a-design-using-a-different-model-soft-constraints-defect-weights-andor-domains","text":"A DesignResult object can be evaluated using modified domains, a different free energy model, different soft constraints, and/or different defect weights using the evaluate_with method: a = Domain ( 'N20' , name = 'a' ) A = TargetStrand ([ a ], name = 'A' ) B = TargetStrand ([ ~ a ], name = 'B' ) C = TargetComplex ([ A , B ], '(20+)20' , name = 'C' ) tube1 = TargetTube ({ C : 1e-6 }, off_targets = SetSpec ( max_size = 2 ), name = 'tube1' ) soft = [ Similarity ([ a ], 'S20' , limits = [ 0.45 , 0.55 ], weight = 0.05 )] my_design = tube_design ([ tube1 ], model = Model (), soft_constraints = soft ) my_result = my_design . run ( trials = 1 )[ 0 ] # Evaluate the result with a different model new_model = Model ( celsius = 40 ) my_result . evaluate_with ( model = new_model ) # Evaluate the result with a different model and soft constraints new_soft = [ Similarity ([ a ], 'G20' , limits = [ 0.4 , 0.6 ], weight = 0.5 )] my_result . evaluate_with ( model = new_model , soft_constraints = new_soft ) # Evaluate the result with different defect weights new_weights = Weights ([ tube1 ]) new_weights [:, A ] *= 10 my_result . evaluate_with ( defect_weights = new_weights ) # Evaluate the result with a different model and domains new_domains = [ Domain ( 'CAGAUAAGAACUGAGUAAGC' , name = 'a' )] my_result . evaluate_with ( domains = new_domains , model = new_model )","title":"Evaluate a design using a different model, soft constraints, defect weights, and/or domains"},{"location":"design/#analyze-additional-physical-quantities-for-a-designed-ensemble","text":"To analyze additional physical quantities for a designed ensemble (e.g., the MFE structure of each designed on-target complex), use the to_analysis() method to make a version of the design ensemble containing designed sequences and then run a test tube analysis job or complex analysis job as desired. For example: # Tube object based on TargetTube with designed sequences t1_designed = my_result . to_analysis ( tube1 ) # Calculate the MFE structure for each on-target complex in the design ensemble tube_results = complex_analysis ( t1_designed , compute = [ 'mfe' ], model = my_model )","title":"Analyze additional physical quantities for a designed ensemble"},{"location":"design/#analyze-a-designed-ensemble-using-different-strand-concentrations","text":"To re-analyze designed sequences using strand concentrations that differ from those in the design ensemble, use the to_analysis() method to make a version of the design ensemble containing designed sequences, and use the analysis_result field to supply an AnalysisResult object to run a complex concentrations job : t1_designed = my_result . to_analysis ( tube1 ) # Tube object based on TargetTube with designed sequences strandA_designed = my_result . to_analysis ( A ) strandB_designed = my_result . to_analysis ( B ) my_analysis_result = my_result . analysis_result # Re-compute complex concentrations for a different set of strand concentrations conc_results = complex_concentrations ( t1_designed , my_analysis_result , concentrations = { strandA_designed : 1e-8 , strandB_designed : 1e-9 })","title":"Analyze a designed ensemble using different strand concentrations"},{"location":"design/#save-a-job-summary","text":"To save a textual job summary using the save_text method: my_result . save_text ( 'my-result.txt' )","title":"Save a job summary"},{"location":"design/#save-and-reload-job-results","text":"Save a DesignResult as a binary file using the save method: my_result . save ( 'my-result.o' ) to enable reloading during a future session using the load method: my_result = DesignResult . load ( 'my-result.o' ) This functionality uses Python\u2019s built-in pickle module. Hochrein13 Hochrein L.M., Schwarzkopf M., Shahgholi M., Yin P., Pierce N.A.: Conditional Dicer Substrate Formation via Shape and Sequence Transduction with Small Conditional RNAs . J. Am. Chem. Soc.. 135 , (2013) HanewichHollatz19 Hanewich-Hollatz M.H., Chen Z., Hochrein L.M., Huang J., Pierce N.A.: Conditional Guide RNAs: Programmable Conditional Regulation of CRISPR/cas Function in Bacterial and Mammalian Cells via Dynamic RNA Nanotechnology . ACS central science. 5 , (2019) Geary14 Geary C., Rothemund P.W., Andersen E.S.: A Single-Stranded Architecture for Cotranscriptional Folding of {{RNA}} Nanostructures . Science. 345 , (2014) Wolfe17 Wolfe B.R., Porubsky N.J., Zadeh J.N., Dirks R.M., Pierce N.A.: Constrained Multistate Sequence Design for Nucleic Acid Reaction Pathway Engineering . J Am. Chem. Soc.. 139 , (2017)","title":"Save and reload job results"},{"location":"model/","text":"Model Specification \u00b6 Specify a physical model \u00b6 NUPACK 4 analysis and design jobs are run based on a physical model created using the Model class: model1 = Model ( material = 'rna' , ensemble = 'stacking' , celsius = 37 , sodium = 1.0 , magnesium = 0.0 ) Any unspecified properties take on their default values (which happen to be the ones specified for model1 above). Model options \u00b6 The valid options for each property are described below. Material \u00b6 NUPACK 4 algorithms use the following temperature-dependent RNA and DNA free energy parameter sets specified by the keyword material (default: material='rna' ): rna06 (shorthand: rna ) Based on [ Mathews99 ] and [ Lu06 ] with additional parameters [ Xia98 , Zuker03 ] including coaxial stacking [ Mathews99 , Turner10 ] and dangle stacking [ Serra95 , Zuker03 , Turner10 ] in 1M Na ^+ ^+ . rna95 Based on [ Serra95 ] with additional parameters [ Zuker03 ] including coaxial stacking [ Mathews99 , Turner10 ] and dangle stacking [ Serra95 , Zuker03 , Turner10 ] in 1M Na ^+ ^+ . dna04 (shorthand: dna ) Based on [ Santalucia98 ] and [ Santalucia04 ] with additional parameters [ Zuker03 ] including coaxial stacking [ Peyret00 ] and dangle stacking [ Bommarito00 , Zuker03 ] in user-specified concentrations of Na ^+ ^+ and Mg ^{++} ^{++} [ Santalucia98 , Peyret00 , Santalucia04 ]. custom-parameters Custom parameters provided in a JSON file (e.g., custom-parameters.json ) using the same format as the provided parameter files. Provide \\Delta G_{37}(\\mathrm{loop}) \\Delta G_{37}(\\mathrm{loop}) and \\Delta H(\\mathrm{loop}) \\Delta H(\\mathrm{loop}) values to allow calculations at different temperatures or only \\Delta G(\\mathrm{loop}) \\Delta G(\\mathrm{loop}) values to allow calculations at one temperature. Place the JSON file in the same directory as the default parameter files (specify material = 'custom-parameters' ) or specify the full path to the file ( material = 'path/to/my/custom-parameters.json' ). Free energies are expressed in kcal/mol. Base pairs are either Watson-Crick pairs ( G \\cdot \\cdot C and A \\cdot \\cdot U for RNA; G \\cdot \\cdot C and A \\cdot \\cdot T for DNA) or wobble pairs ( G \\cdot \\cdot U for RNA). Note that for DNA, G and T form a mismatch and not a wobble pair [ Santalucia04 ]. DNA/RNA hybrids are not allowed. Stacking \u00b6 NUPACK 4 algorithms perform calculations on the following complex ensembles specified by the keyword ensemble (default: ensemble='stacking' ): stacking Complex ensemble with coaxial and dangle stacking (ensemble \\overline\\Gamma^\\shortparallel(\\phi) \\overline\\Gamma^\\shortparallel(\\phi) ). dangle-stacking Complex ensemble with dangle stacking. coaxial-stacking Complex ensemble with coaxial stacking. nostacking Complex ensemble without coaxial and dangle stacking (ensemble \\overline\\Gamma(\\phi) \\overline\\Gamma(\\phi) ). Temperature \u00b6 celsius Temperature is specified in ^\\circ ^\\circ C using the keyword celsius (default: celsius=37 ). kelvin Alternatively, the temperature can be specified in K using the keyword kelvin . Salt \u00b6 The default salt conditions for RNA and DNA parameter sets are [\\mathrm{Na}^+] = 1 {\\rm M} [\\mathrm{Na}^+] = 1 {\\rm M} ; these are the only salt conditions for RNA. Salt corrections are available for DNA parameters to permit calculations in user-specified sodium, potassium, ammonium, and magnesium ion concentrations. sodium Based on [ Santalucia98 , SantaLucia04 ] the sum of the concentrations of (monovalent) sodium, potassium, and ammonium ions, [{\\rm Na}^+] + [\\mathrm{K}^+] + [\\mathrm{NH}_4^+] [{\\rm Na}^+] + [\\mathrm{K}^+] + [\\mathrm{NH}_4^+] , is specified in units of molar (default: 1.0, range: [0.05,1.1]) using the keyword sodium . magnesium Based on [ Peyret00 , Koehler05 ] the concentration of (divalent) magnesium ions, [{\\rm Mg}^{++}] [{\\rm Mg}^{++}] , is specified in units of molar (default: 0.0, range: [0.0,0.2]) using the keyword magnesium . Examples Define a model for DNA calculations at 23 ^\\circ ^\\circ C in [{\\rm Na}^{+}]= 0.5 [{\\rm Na}^{+}]= 0.5 M and [{\\rm Mg}^{++}]= 0.01 [{\\rm Mg}^{++}]= 0.01 M: model2 = Model ( material = 'dna' , celsius = 23 , sodium = 0.5 , magnesium = 0.01 ) Note that ensemble is unspecified so it defaults to ensemble='stacking' . Define a model using custom parameters at 45 ^\\circ ^\\circ C without coaxial and dangle stacking: model3 = Model ( material = 'path/to/my/custom-parameters.json' , ensemble = 'nostacking' , celsius = 45 ) Historical options \u00b6 For backwards compatibility with NUPACK 3, the following historical complex ensembles without coaxial stacking and with approximate dangle stacking are supported: none-nupack3 No dangle stacking and no coaxial stacking (dangles none option for NUPACK 3) some-nupack3 Some dangle stacking and no coaxial stacking (dangles some option for NUPACK 3). A dangle energy is incorporated for each unpaired base flanking a duplex (a base flanking two duplexes contributes only the minimum of the two possible dangle energies). all-nupack3 All dangle stacking and no coaxial stacking (dangles all option for NUPACK 3). A dangle energy is incorporated for each unpaired base flanking a duplex (a base flanking two duplexes contributes both possible dangle energies). For these historical ensembles, base pairs are either Watson-Crick pairs ( G \\cdot \\cdot C and A \\cdot \\cdot U for RNA; G \\cdot \\cdot C and A \\cdot \\cdot T for DNA) or wobble pairs ( G \\cdot \\cdot U for RNA; G \\cdot \\cdot T for DNA). Note that for the historical ensembles, G \\cdot \\cdot T is classified as a DNA wobble pair and not as a mismatch. The historical ensembles prohibit a wobble pair ( G \\cdot \\cdot U or G \\cdot \\cdot T ) as a terminal base pair in an exterior loop or a multiloop. As a result, an attempt to evaluate a free energy for a sequence \\phi \\phi and secondary structure s s that place a wobble pair as a terminal base pair in an exterior loop or multiloop will return \\overline{\\Delta G}(\\phi,s)=\\Delta G(\\phi,s) = \\infty \\overline{\\Delta G}(\\phi,s)=\\Delta G(\\phi,s) = \\infty . These historical ensembles can be used for calculations in combination with the following historical DNA and RNA parameter sets: rna95-nupack3 Same as rna95 except that terminal mismatch free energies in exterior loops and multiloops are replaced by two dangle stacking free energies. dna04-nupack3 Same as dna04 except that G \\cdot \\cdot T was treated as a wobble pair (analogous to a G \\cdot \\cdot U RNA wobble pair) instead of classifying G and T as a mismatch. Note that while terminal mismatch free energies in exterior loops and multiloops are replaced by two dangle stacking free energies, this is the same treatment as in dna04 , as terminal mismatch parameters are not public for DNA [ Santalucia04 ]. rna99-nupack3 Parameters from [ Mathews99 ] with terminal mismatch free energies in exterior loops and multiloops replaced by two dangle stacking free energies. Parameters are provided only for 37 ^\\circ ^\\circ C. Compute loop free energy \u00b6 The loop_energy method operates on a Model object to calculate the loop free energy in kcal/mol. The loop sequence is specified with keyword loop and the loop structure is specified with keyword structure . For example: my_model = Model ( material = 'RNA' , ensemble = 'stacking' ) #Calculate the free energy of an unstructured strand dGloop2 = my_model . loop_energy ( loop = 'AAUU' , structure = '....' ) print ( dGloop2 ) # --> 0.0 #Calculate the free energy of a hairpin loop dGloop3 = my_model . loop_energy ( loop = 'AACCCUU' , structure = '(.....)' ) print ( dGloop3 ) # --> 5.15 #Calculate the free energy of an exterior loop dGloop4 = my_model . loop_energy ( loop = 'AA+UU' , structure = '((+))' ) print ( dGloop4 ) # --> -0.9 #Calculate the free energy of a multiloop dGloop5 = my_model . loop_energy ( loop = 'AAU+ACU+AGU' , structure = '(.(+).(+).)' ) print ( dGloop5 ) # --> 9.355 Compute stacking state free energies \u00b6 The stack_energies method operates on a Model object to calculate the stacking state free energies for the subensemble of stacking states in a single loop. The loop sequence is specified with keyword loop and the loop structure is specified with keyword structure . The algorithm returns a list of stacking states and the free energy for each in kcal/mol. For a loop defined as a list of N snippets, a stacking state is specified as a string composed of one letter per snippet. For each snippet, the returned letter is: 's' if the snippet contains only 2 nucleotides, each base-paired to a nucleotide in the adjacent snippet, with the two base pairs coaxially stacked on each other 'b' if both the 5 ' ' and 3 ' ' unpaired nucleotides are dangle stacking on adjacent base pairs '5' if only the 5 ' ' -most unpaired base is dangle stacking on its adjacent base pair '3' if only the 3 ' ' -most unpaired base is dangle stacking its adjacent base pair 'n' if none of the above apply (i.e., the snippet does not have a dangle at either the 5 ' ' or 3 ' ' end nor does it contain only 2 adjacent nucleotides participating in a coaxial stack) For example, the following figures illustrate snippet annotations for coaxial and dangle stacking states in representative multiloops and exterior loops: For a specified multiloop or exterior loop sequence and structure, the stack_energies method returns a set of stacking state strings each with a corresponding stacking state free energy (kcal/mol): # Calculate the dangle stacking state free energies for an exterior loop my_model . stack_energies ( loop = 'CA+UC' , structure = '.(+).' ) # --> {'35': -0.15, '3n': 0.15, 'n5': 0.35, 'nn': 0.45} # Calculate the coaxial stacking state free energies for an exterior loop my_model . stack_energies ( loop = 'AA+U+U' , structure = '((+)+)' ) # --> {'nnn': 0.9, 'snn': 0.0} # Calculate the coxial stacking state free energies for a multiloop my_model . stack_energies ( loop = 'AU+AU+AU' , structure = '((+)(+))' ) # --> {'nnn': 11.9725, 'nns': 10.8725, 'nsn': 10.8725, 'snn': 10.8725} For loops that are not multiloops or exterior loops, the loop free energy is returned with a string indicating that there is no stacking state. For example, for a hairpin loop: my_model . stack_energies ( loop = 'AAAAU' , structure = '(...)' ) # --> {'n': 5.85} Mathews99 Mathews D.H., Sabina J., Zuker M., Turner D.H.: Expanded Sequence Dependence of Thermodynamic Parameters Improves Prediction of RNA Secondary Structure . J. Mol. Biol.. 288 , (1999) Lu06 Lu Z.J., Turner D.H., Mathews D.H.: A Set of Nearest Neighbor Parameters for Predicting the Enthalpy Change of RNA Secondary Structure Formation . Nucleic acids research. 34 , (2006) Xia98 Xia T., SantaLucia J., Burkard M., Kierzek R., Schroeder S., Jiao X., Cox C., Turner D.: Thermodynamic Parameters for an Expanded Nearest-Neighbor Model for Formation of RNA Duplexes with Watson-Crick Base Pairs . Biochemistry. 37 , (1998) Zuker03 Zuker M.: Mfold Web Server for Nucleic Acid Folding and Hybridization Prediction . Nucleic Acids Res.. 31 , (2003) Turner10 Turner D.H., Mathews D.H.: NNDB: The Nearest Neighbor Parameter Database for Predicting Stability of Nucleic Acid Secondary Structure . Nucleic Acids Res.. 38 , (2010) Serra95 Serra M.J., Turner D.H.: Predicting Thermodynamic Properties of RNA . Methods Enzymol.. 259 , (1995) Santalucia98 SantaLucia J.: A Unified View of Polymer, Dumbbell, and Oligonucleotide DNA Nearest-Neighbor Thermodynamics . Proc. Natl. Acad. Sci. USA. 95 , (1998) Santalucia04 SantaLucia J., Hicks D.: The thermodynamics of DNA structural motifs . Annu. Rev. Biophys. Biomol. Struct.. 33 , (2004) Peyret00 Peyret N.: Prediction of Nucleic Acid Hybridization: Parameters and Algorithms . (2000) Bommarito00 Bommarito S., Peyret N., SantaLucia J.: Thermodynamic Parameters for DNA Sequences with Dangling Ends . Nucleic Acids Res.. 28 , (2000) SantaLucia04 SantaLucia J., Hicks D.: The thermodynamics of DNA structural motifs . Annu. Rev. Biophys. Biomol. Struct.. 33 , (2004) Koehler05 Koehler R.T., Peyret N.: Thermodynamic Properties of DNA Sequences: Characteristic Values for the Human Genome . Bioinformatics. 21 , (2005)","title":"Model Specification"},{"location":"model/#model-specification","text":"","title":"Model Specification"},{"location":"model/#specify-a-physical-model","text":"NUPACK 4 analysis and design jobs are run based on a physical model created using the Model class: model1 = Model ( material = 'rna' , ensemble = 'stacking' , celsius = 37 , sodium = 1.0 , magnesium = 0.0 ) Any unspecified properties take on their default values (which happen to be the ones specified for model1 above).","title":"Specify a physical model"},{"location":"model/#model-options","text":"The valid options for each property are described below.","title":"Model options"},{"location":"model/#material","text":"NUPACK 4 algorithms use the following temperature-dependent RNA and DNA free energy parameter sets specified by the keyword material (default: material='rna' ): rna06 (shorthand: rna ) Based on [ Mathews99 ] and [ Lu06 ] with additional parameters [ Xia98 , Zuker03 ] including coaxial stacking [ Mathews99 , Turner10 ] and dangle stacking [ Serra95 , Zuker03 , Turner10 ] in 1M Na ^+ ^+ . rna95 Based on [ Serra95 ] with additional parameters [ Zuker03 ] including coaxial stacking [ Mathews99 , Turner10 ] and dangle stacking [ Serra95 , Zuker03 , Turner10 ] in 1M Na ^+ ^+ . dna04 (shorthand: dna ) Based on [ Santalucia98 ] and [ Santalucia04 ] with additional parameters [ Zuker03 ] including coaxial stacking [ Peyret00 ] and dangle stacking [ Bommarito00 , Zuker03 ] in user-specified concentrations of Na ^+ ^+ and Mg ^{++} ^{++} [ Santalucia98 , Peyret00 , Santalucia04 ]. custom-parameters Custom parameters provided in a JSON file (e.g., custom-parameters.json ) using the same format as the provided parameter files. Provide \\Delta G_{37}(\\mathrm{loop}) \\Delta G_{37}(\\mathrm{loop}) and \\Delta H(\\mathrm{loop}) \\Delta H(\\mathrm{loop}) values to allow calculations at different temperatures or only \\Delta G(\\mathrm{loop}) \\Delta G(\\mathrm{loop}) values to allow calculations at one temperature. Place the JSON file in the same directory as the default parameter files (specify material = 'custom-parameters' ) or specify the full path to the file ( material = 'path/to/my/custom-parameters.json' ). Free energies are expressed in kcal/mol. Base pairs are either Watson-Crick pairs ( G \\cdot \\cdot C and A \\cdot \\cdot U for RNA; G \\cdot \\cdot C and A \\cdot \\cdot T for DNA) or wobble pairs ( G \\cdot \\cdot U for RNA). Note that for DNA, G and T form a mismatch and not a wobble pair [ Santalucia04 ]. DNA/RNA hybrids are not allowed.","title":"Material"},{"location":"model/#stacking","text":"NUPACK 4 algorithms perform calculations on the following complex ensembles specified by the keyword ensemble (default: ensemble='stacking' ): stacking Complex ensemble with coaxial and dangle stacking (ensemble \\overline\\Gamma^\\shortparallel(\\phi) \\overline\\Gamma^\\shortparallel(\\phi) ). dangle-stacking Complex ensemble with dangle stacking. coaxial-stacking Complex ensemble with coaxial stacking. nostacking Complex ensemble without coaxial and dangle stacking (ensemble \\overline\\Gamma(\\phi) \\overline\\Gamma(\\phi) ).","title":"Stacking"},{"location":"model/#temperature","text":"celsius Temperature is specified in ^\\circ ^\\circ C using the keyword celsius (default: celsius=37 ). kelvin Alternatively, the temperature can be specified in K using the keyword kelvin .","title":"Temperature"},{"location":"model/#salt","text":"The default salt conditions for RNA and DNA parameter sets are [\\mathrm{Na}^+] = 1 {\\rm M} [\\mathrm{Na}^+] = 1 {\\rm M} ; these are the only salt conditions for RNA. Salt corrections are available for DNA parameters to permit calculations in user-specified sodium, potassium, ammonium, and magnesium ion concentrations. sodium Based on [ Santalucia98 , SantaLucia04 ] the sum of the concentrations of (monovalent) sodium, potassium, and ammonium ions, [{\\rm Na}^+] + [\\mathrm{K}^+] + [\\mathrm{NH}_4^+] [{\\rm Na}^+] + [\\mathrm{K}^+] + [\\mathrm{NH}_4^+] , is specified in units of molar (default: 1.0, range: [0.05,1.1]) using the keyword sodium . magnesium Based on [ Peyret00 , Koehler05 ] the concentration of (divalent) magnesium ions, [{\\rm Mg}^{++}] [{\\rm Mg}^{++}] , is specified in units of molar (default: 0.0, range: [0.0,0.2]) using the keyword magnesium . Examples Define a model for DNA calculations at 23 ^\\circ ^\\circ C in [{\\rm Na}^{+}]= 0.5 [{\\rm Na}^{+}]= 0.5 M and [{\\rm Mg}^{++}]= 0.01 [{\\rm Mg}^{++}]= 0.01 M: model2 = Model ( material = 'dna' , celsius = 23 , sodium = 0.5 , magnesium = 0.01 ) Note that ensemble is unspecified so it defaults to ensemble='stacking' . Define a model using custom parameters at 45 ^\\circ ^\\circ C without coaxial and dangle stacking: model3 = Model ( material = 'path/to/my/custom-parameters.json' , ensemble = 'nostacking' , celsius = 45 )","title":"Salt"},{"location":"model/#historical-options","text":"For backwards compatibility with NUPACK 3, the following historical complex ensembles without coaxial stacking and with approximate dangle stacking are supported: none-nupack3 No dangle stacking and no coaxial stacking (dangles none option for NUPACK 3) some-nupack3 Some dangle stacking and no coaxial stacking (dangles some option for NUPACK 3). A dangle energy is incorporated for each unpaired base flanking a duplex (a base flanking two duplexes contributes only the minimum of the two possible dangle energies). all-nupack3 All dangle stacking and no coaxial stacking (dangles all option for NUPACK 3). A dangle energy is incorporated for each unpaired base flanking a duplex (a base flanking two duplexes contributes both possible dangle energies). For these historical ensembles, base pairs are either Watson-Crick pairs ( G \\cdot \\cdot C and A \\cdot \\cdot U for RNA; G \\cdot \\cdot C and A \\cdot \\cdot T for DNA) or wobble pairs ( G \\cdot \\cdot U for RNA; G \\cdot \\cdot T for DNA). Note that for the historical ensembles, G \\cdot \\cdot T is classified as a DNA wobble pair and not as a mismatch. The historical ensembles prohibit a wobble pair ( G \\cdot \\cdot U or G \\cdot \\cdot T ) as a terminal base pair in an exterior loop or a multiloop. As a result, an attempt to evaluate a free energy for a sequence \\phi \\phi and secondary structure s s that place a wobble pair as a terminal base pair in an exterior loop or multiloop will return \\overline{\\Delta G}(\\phi,s)=\\Delta G(\\phi,s) = \\infty \\overline{\\Delta G}(\\phi,s)=\\Delta G(\\phi,s) = \\infty . These historical ensembles can be used for calculations in combination with the following historical DNA and RNA parameter sets: rna95-nupack3 Same as rna95 except that terminal mismatch free energies in exterior loops and multiloops are replaced by two dangle stacking free energies. dna04-nupack3 Same as dna04 except that G \\cdot \\cdot T was treated as a wobble pair (analogous to a G \\cdot \\cdot U RNA wobble pair) instead of classifying G and T as a mismatch. Note that while terminal mismatch free energies in exterior loops and multiloops are replaced by two dangle stacking free energies, this is the same treatment as in dna04 , as terminal mismatch parameters are not public for DNA [ Santalucia04 ]. rna99-nupack3 Parameters from [ Mathews99 ] with terminal mismatch free energies in exterior loops and multiloops replaced by two dangle stacking free energies. Parameters are provided only for 37 ^\\circ ^\\circ C.","title":"Historical options"},{"location":"model/#compute-loop-free-energy","text":"The loop_energy method operates on a Model object to calculate the loop free energy in kcal/mol. The loop sequence is specified with keyword loop and the loop structure is specified with keyword structure . For example: my_model = Model ( material = 'RNA' , ensemble = 'stacking' ) #Calculate the free energy of an unstructured strand dGloop2 = my_model . loop_energy ( loop = 'AAUU' , structure = '....' ) print ( dGloop2 ) # --> 0.0 #Calculate the free energy of a hairpin loop dGloop3 = my_model . loop_energy ( loop = 'AACCCUU' , structure = '(.....)' ) print ( dGloop3 ) # --> 5.15 #Calculate the free energy of an exterior loop dGloop4 = my_model . loop_energy ( loop = 'AA+UU' , structure = '((+))' ) print ( dGloop4 ) # --> -0.9 #Calculate the free energy of a multiloop dGloop5 = my_model . loop_energy ( loop = 'AAU+ACU+AGU' , structure = '(.(+).(+).)' ) print ( dGloop5 ) # --> 9.355","title":"Compute loop free energy"},{"location":"model/#compute-stacking-state-free-energies","text":"The stack_energies method operates on a Model object to calculate the stacking state free energies for the subensemble of stacking states in a single loop. The loop sequence is specified with keyword loop and the loop structure is specified with keyword structure . The algorithm returns a list of stacking states and the free energy for each in kcal/mol. For a loop defined as a list of N snippets, a stacking state is specified as a string composed of one letter per snippet. For each snippet, the returned letter is: 's' if the snippet contains only 2 nucleotides, each base-paired to a nucleotide in the adjacent snippet, with the two base pairs coaxially stacked on each other 'b' if both the 5 ' ' and 3 ' ' unpaired nucleotides are dangle stacking on adjacent base pairs '5' if only the 5 ' ' -most unpaired base is dangle stacking on its adjacent base pair '3' if only the 3 ' ' -most unpaired base is dangle stacking its adjacent base pair 'n' if none of the above apply (i.e., the snippet does not have a dangle at either the 5 ' ' or 3 ' ' end nor does it contain only 2 adjacent nucleotides participating in a coaxial stack) For example, the following figures illustrate snippet annotations for coaxial and dangle stacking states in representative multiloops and exterior loops: For a specified multiloop or exterior loop sequence and structure, the stack_energies method returns a set of stacking state strings each with a corresponding stacking state free energy (kcal/mol): # Calculate the dangle stacking state free energies for an exterior loop my_model . stack_energies ( loop = 'CA+UC' , structure = '.(+).' ) # --> {'35': -0.15, '3n': 0.15, 'n5': 0.35, 'nn': 0.45} # Calculate the coaxial stacking state free energies for an exterior loop my_model . stack_energies ( loop = 'AA+U+U' , structure = '((+)+)' ) # --> {'nnn': 0.9, 'snn': 0.0} # Calculate the coxial stacking state free energies for a multiloop my_model . stack_energies ( loop = 'AU+AU+AU' , structure = '((+)(+))' ) # --> {'nnn': 11.9725, 'nns': 10.8725, 'nsn': 10.8725, 'snn': 10.8725} For loops that are not multiloops or exterior loops, the loop free energy is returned with a string indicating that there is no stacking state. For example, for a hairpin loop: my_model . stack_energies ( loop = 'AAAAU' , structure = '(...)' ) # --> {'n': 5.85} Mathews99 Mathews D.H., Sabina J., Zuker M., Turner D.H.: Expanded Sequence Dependence of Thermodynamic Parameters Improves Prediction of RNA Secondary Structure . J. Mol. Biol.. 288 , (1999) Lu06 Lu Z.J., Turner D.H., Mathews D.H.: A Set of Nearest Neighbor Parameters for Predicting the Enthalpy Change of RNA Secondary Structure Formation . Nucleic acids research. 34 , (2006) Xia98 Xia T., SantaLucia J., Burkard M., Kierzek R., Schroeder S., Jiao X., Cox C., Turner D.: Thermodynamic Parameters for an Expanded Nearest-Neighbor Model for Formation of RNA Duplexes with Watson-Crick Base Pairs . Biochemistry. 37 , (1998) Zuker03 Zuker M.: Mfold Web Server for Nucleic Acid Folding and Hybridization Prediction . Nucleic Acids Res.. 31 , (2003) Turner10 Turner D.H., Mathews D.H.: NNDB: The Nearest Neighbor Parameter Database for Predicting Stability of Nucleic Acid Secondary Structure . Nucleic Acids Res.. 38 , (2010) Serra95 Serra M.J., Turner D.H.: Predicting Thermodynamic Properties of RNA . Methods Enzymol.. 259 , (1995) Santalucia98 SantaLucia J.: A Unified View of Polymer, Dumbbell, and Oligonucleotide DNA Nearest-Neighbor Thermodynamics . Proc. Natl. Acad. Sci. USA. 95 , (1998) Santalucia04 SantaLucia J., Hicks D.: The thermodynamics of DNA structural motifs . Annu. Rev. Biophys. Biomol. Struct.. 33 , (2004) Peyret00 Peyret N.: Prediction of Nucleic Acid Hybridization: Parameters and Algorithms . (2000) Bommarito00 Bommarito S., Peyret N., SantaLucia J.: Thermodynamic Parameters for DNA Sequences with Dangling Ends . Nucleic Acids Res.. 28 , (2000) SantaLucia04 SantaLucia J., Hicks D.: The thermodynamics of DNA structural motifs . Annu. Rev. Biophys. Biomol. Struct.. 33 , (2004) Koehler05 Koehler R.T., Peyret N.: Thermodynamic Properties of DNA Sequences: Characteristic Values for the Human Genome . Bioinformatics. 21 , (2005)","title":"Compute stacking state free energies"},{"location":"start/","text":"Getting Started \u00b6 Example Jupyter notebooks \u00b6 Here, we provide Jupyter notebooks for a variety of examples that can be downloaded for interactive use. Analysis examples \u00b6 Analyze the equilibrium base-pairing properties one or more test tube ensembles (or one or more complex ensembles) \u2014 these are the all-purpose sequence analysis tools . Tube analysis: analyze a test tube ensemble Multi-tube analysis: analyze a set of test tube ensembles Complex analysis: analyze a complex ensemble Multi-complex analysis: analyze a set of complex ensembles Design examples \u00b6 Design the the sequences for one or more test tube ensembles (or one or more complex ensembles) \u2014 these are the all-purpose sequence design tools . Tube design: design a test tube ensemble Multi-tube design (simple): design specification ( tex ) design a one-step reaction pathway design N orthogonal one-step reaction pathways Multi-tube design (advanced): design specification ( tex ) design a multi-step reaction pathway design N orthogonal multi-step reaction pathways Complex design: design a complex ensemble Sample \\LaTeX \\LaTeX files are provided for the multi-tube design specifications to assist with making new design specs in a standardized format. Utilities examples \u00b6 Analyze or design a single complex ensemble \u2014 these are quick tools applicable when your ensemble is a single complex. Utilities: analyze or design a complex ensemble Note Note that each Jupyter notebook starts by loading the NUPACK Python module: from nupack import * Installation requirements \u00b6 NUPACK 4 is a C++ library distributed as a Python package. The following Python packages are required: Python 3.8-3.12 numpy scipy pandas The following packages are recommended to facilitate interactive usage: matplotlib jupyterlab NUPACK 4 Python packages can be installed for Mac/Linux operating systems or on the Linux subsystem of Windows 10/11. Alternatively, NUPACK may be compiled from source on Mac/Linux. An easy way to install all of these dependencies is by installing Anaconda . Mac/Linux installation \u00b6 Warning Note that for new Macs using an M1 or M2 (arm64) architecture, you must make sure to use a native Python distribution. Separate downloads for the Anaconda or miniconda distributions are available \u2013 make sure to choose the distributions labeled \u201cM1\u201d. Importing NUPACK will only function correctly using a native Python distribution. You may use the command python3 -c \"import platform; print(platform.machine())\" to see your installed architecture; this should be arm64 when using an M-series Mac. Verify your Python installation (make sure you have Python 3.8 or newer): python3 --version If this command does not run, troubleshoot your Python installation. You may not have your $PATH environment variable set correctly. Update your installation of pip and install the optional dependencies. Run the following commands python3 -m pip install -U pip python3 -m pip install -U matplotlib jupyterlab Alternatively, if you are using Anaconda, replace the above commands with: conda install --update-all pip matplotlib jupyterlab If this command does not run, troubleshoot your Anaconda installation. You may not have your $PATH environment variable set correctly. After agreeing to the NUPACK license , download the NUPACK package (e.g., nupack-4.0.0 ) into your Downloads folder and make sure it is unzipped. Install the NUPACK 4 Python module by running the following command in your terminal (type y when prompted): python3 -m pip install -U nupack -f ~/Downloads/nupack-VERSION/package Make sure to replace nupack-VERSION with the correct folder name (e.g., nupack-4.0.0 ). Check that the correct nupack version is now installed by running the following commmand: python3 -m pip show nupack If the version is not correct, go back to Step 4, double-check the folder name, and rerun the command. Validate your NUPACK 4 installation by running the following commands: python3 -m pip install -U pytest python3 -m pytest -v --pyargs nupack You can now conveniently run NUPACK 4 jobs as Jupyter notebooks (see above for example notebooks ). You can launch a web-based Jupyter notebook browser from the command line: jupyter lab and browse to open your notebook of choice. Click Run->Run All Cells to run the entire notebook. If no browser window appears, try navigating to the displayed link in your terminal. If this doesn\u2019t work, troubleshoot your Jupyter installation. Windows installation \u00b6 NUPACK may be installed on Windows 10/11 using the Windows Subsystem for Linux 2 (WSL2). Click the start menu and search for \u201cWindows Features\u201d. Click on \u201cTurn Windows features on or off\u201d. Check the \u201cWindows Subsystem for Linux\u201d icon Download Ubuntu from the Microsoft Store Open the Ubuntu app and set a username and password (Optional) Open the properties window and enable copy paste Install NUPACK as if using Linux using the following commands (type y when prompted): mkdir nupack-latest cd nupack-latest cp /mnt/c/Users/YOUR-USERNAME/Downloads/nupack-VERSION.zip ./ sudo apt install unzip unzip nupack-latest.zip cd .. wget https://repo.anaconda.com/miniconda/Miniconda3-latest-Linux-x86_64.sh /bin/bash Miniconda3-latest-Linux-x86_64.sh -b miniconda3/bin/conda update -n base -c defaults conda rm Miniconda3-latest-Linux-x86_64.sh export PATH = $HOME /miniconda3/bin: $PATH echo 'export PATH=$HOME/miniconda3/bin:$PATH' >> ~/.bashrc conda install numpy scipy pip matplotlib pandas jupyterlab pip install -U nupack -f ./nupack-VERSION/package jupyter lab Make sure to replace /YOUR-USERNAME/Downloads above with the appropriate directory and nupack-VERSION with the correct version (e.g., nupack-4.0.0 ). Use your web browser to open localhost:8888 and use Jupyter Lab to open an example notebook . Source installation \u00b6 For Mac/Linux users, installation of binaries via pip is by far the easiest option and is strongly recommended. However, if necessary, NUPACK can be built from source. The following are required: C++17 compliant compiler (Clang or AppleClang) CMake On Mac, it is recommended to use the Clang provided by Homebrew as it is generally kept more up to date than Apple\u2019s builtin version. After installing Homebrew, install Clang via brew install llvm . Then add the flag -DCMAKE_CXX_COMPILER=/opt/homebrew/opt/llvm/bin/clang++ or -DCMAKE_CXX_COMPILER=/usr/local/opt/llvm/bin/clang++ to your cmake command (use the one corresponding to where brew installed binaries). Directions: On a Mac/Linux system, navigate to the source directory within the NUPACK download: cd ~/Downloads/nupack-VERSION/source Make sure to replace nupack-VERSION with the correct folder name (e.g., nupack-4.0.0 ). Build the included vcpkg submodule using: ./external/vcpkg/bootstrap-vcpkg.sh or if you are using a Mac and have not previously installed a C++ compiler, using the following flags: ./external/vcpkg/bootstrap-vcpkg.sh --useSystemBinaries --allowAppleClang Next install the dependencies for NUPACK compilation using vcpkg : ./external/vcpkg/vcpkg install gecode armadillo tbb nlohmann-json jsoncpp taskflow protobuf \\ tclap spdlog fmt boost-context boost-graph boost-align boost-coroutine2 boost-algorithm libsimdpp magic-enum \\ boost-variant boost-thread boost-sort boost-geometry boost-odeint boost-ublas boost-exception yaml-cpp boost-algorithm Make a build directory and navigate into it: mkdir build cd build Run the CMake configuration: cmake .. -DCMAKE_BUILD_TYPE = Release You may add custom compilation options as flags to the cmake command if desired. Some examples might be: Add -DCMAKE_CXX_COMPILER=clang++ to use the clang++ compiler. As noted above, compilers besides clang are not generally supported. Add -DREBIND_PYTHON=/usr/local/bin/python3 to build for a specific Python executable (by default, the python in the user\u2019s $PATH is used). Add -DCMAKE_CXX_FLAGS=\"<custom compile options>\" to add custom C++ compilation flags. Add -DCMAKE_POSITION_INDEPENDENT_CODE=ON in the offchance you run into a compilation error asking you to recompile with -fPIC . Build the C++ code: cmake --build . --target nupack-python Install the NUPACK Python module: pip3 install .","title":"Getting Started"},{"location":"start/#getting-started","text":"","title":"Getting Started"},{"location":"start/#example-jupyter-notebooks","text":"Here, we provide Jupyter notebooks for a variety of examples that can be downloaded for interactive use.","title":"Example Jupyter notebooks"},{"location":"start/#analysis-examples","text":"Analyze the equilibrium base-pairing properties one or more test tube ensembles (or one or more complex ensembles) \u2014 these are the all-purpose sequence analysis tools . Tube analysis: analyze a test tube ensemble Multi-tube analysis: analyze a set of test tube ensembles Complex analysis: analyze a complex ensemble Multi-complex analysis: analyze a set of complex ensembles","title":"Analysis examples"},{"location":"start/#design-examples","text":"Design the the sequences for one or more test tube ensembles (or one or more complex ensembles) \u2014 these are the all-purpose sequence design tools . Tube design: design a test tube ensemble Multi-tube design (simple): design specification ( tex ) design a one-step reaction pathway design N orthogonal one-step reaction pathways Multi-tube design (advanced): design specification ( tex ) design a multi-step reaction pathway design N orthogonal multi-step reaction pathways Complex design: design a complex ensemble Sample \\LaTeX \\LaTeX files are provided for the multi-tube design specifications to assist with making new design specs in a standardized format.","title":"Design examples"},{"location":"start/#utilities-examples","text":"Analyze or design a single complex ensemble \u2014 these are quick tools applicable when your ensemble is a single complex. Utilities: analyze or design a complex ensemble Note Note that each Jupyter notebook starts by loading the NUPACK Python module: from nupack import *","title":"Utilities examples"},{"location":"start/#installation-requirements","text":"NUPACK 4 is a C++ library distributed as a Python package. The following Python packages are required: Python 3.8-3.12 numpy scipy pandas The following packages are recommended to facilitate interactive usage: matplotlib jupyterlab NUPACK 4 Python packages can be installed for Mac/Linux operating systems or on the Linux subsystem of Windows 10/11. Alternatively, NUPACK may be compiled from source on Mac/Linux. An easy way to install all of these dependencies is by installing Anaconda .","title":"Installation requirements"},{"location":"start/#maclinux-installation","text":"Warning Note that for new Macs using an M1 or M2 (arm64) architecture, you must make sure to use a native Python distribution. Separate downloads for the Anaconda or miniconda distributions are available \u2013 make sure to choose the distributions labeled \u201cM1\u201d. Importing NUPACK will only function correctly using a native Python distribution. You may use the command python3 -c \"import platform; print(platform.machine())\" to see your installed architecture; this should be arm64 when using an M-series Mac. Verify your Python installation (make sure you have Python 3.8 or newer): python3 --version If this command does not run, troubleshoot your Python installation. You may not have your $PATH environment variable set correctly. Update your installation of pip and install the optional dependencies. Run the following commands python3 -m pip install -U pip python3 -m pip install -U matplotlib jupyterlab Alternatively, if you are using Anaconda, replace the above commands with: conda install --update-all pip matplotlib jupyterlab If this command does not run, troubleshoot your Anaconda installation. You may not have your $PATH environment variable set correctly. After agreeing to the NUPACK license , download the NUPACK package (e.g., nupack-4.0.0 ) into your Downloads folder and make sure it is unzipped. Install the NUPACK 4 Python module by running the following command in your terminal (type y when prompted): python3 -m pip install -U nupack -f ~/Downloads/nupack-VERSION/package Make sure to replace nupack-VERSION with the correct folder name (e.g., nupack-4.0.0 ). Check that the correct nupack version is now installed by running the following commmand: python3 -m pip show nupack If the version is not correct, go back to Step 4, double-check the folder name, and rerun the command. Validate your NUPACK 4 installation by running the following commands: python3 -m pip install -U pytest python3 -m pytest -v --pyargs nupack You can now conveniently run NUPACK 4 jobs as Jupyter notebooks (see above for example notebooks ). You can launch a web-based Jupyter notebook browser from the command line: jupyter lab and browse to open your notebook of choice. Click Run->Run All Cells to run the entire notebook. If no browser window appears, try navigating to the displayed link in your terminal. If this doesn\u2019t work, troubleshoot your Jupyter installation.","title":"Mac/Linux installation"},{"location":"start/#windows-installation","text":"NUPACK may be installed on Windows 10/11 using the Windows Subsystem for Linux 2 (WSL2). Click the start menu and search for \u201cWindows Features\u201d. Click on \u201cTurn Windows features on or off\u201d. Check the \u201cWindows Subsystem for Linux\u201d icon Download Ubuntu from the Microsoft Store Open the Ubuntu app and set a username and password (Optional) Open the properties window and enable copy paste Install NUPACK as if using Linux using the following commands (type y when prompted): mkdir nupack-latest cd nupack-latest cp /mnt/c/Users/YOUR-USERNAME/Downloads/nupack-VERSION.zip ./ sudo apt install unzip unzip nupack-latest.zip cd .. wget https://repo.anaconda.com/miniconda/Miniconda3-latest-Linux-x86_64.sh /bin/bash Miniconda3-latest-Linux-x86_64.sh -b miniconda3/bin/conda update -n base -c defaults conda rm Miniconda3-latest-Linux-x86_64.sh export PATH = $HOME /miniconda3/bin: $PATH echo 'export PATH=$HOME/miniconda3/bin:$PATH' >> ~/.bashrc conda install numpy scipy pip matplotlib pandas jupyterlab pip install -U nupack -f ./nupack-VERSION/package jupyter lab Make sure to replace /YOUR-USERNAME/Downloads above with the appropriate directory and nupack-VERSION with the correct version (e.g., nupack-4.0.0 ). Use your web browser to open localhost:8888 and use Jupyter Lab to open an example notebook .","title":"Windows installation"},{"location":"start/#source-installation","text":"For Mac/Linux users, installation of binaries via pip is by far the easiest option and is strongly recommended. However, if necessary, NUPACK can be built from source. The following are required: C++17 compliant compiler (Clang or AppleClang) CMake On Mac, it is recommended to use the Clang provided by Homebrew as it is generally kept more up to date than Apple\u2019s builtin version. After installing Homebrew, install Clang via brew install llvm . Then add the flag -DCMAKE_CXX_COMPILER=/opt/homebrew/opt/llvm/bin/clang++ or -DCMAKE_CXX_COMPILER=/usr/local/opt/llvm/bin/clang++ to your cmake command (use the one corresponding to where brew installed binaries). Directions: On a Mac/Linux system, navigate to the source directory within the NUPACK download: cd ~/Downloads/nupack-VERSION/source Make sure to replace nupack-VERSION with the correct folder name (e.g., nupack-4.0.0 ). Build the included vcpkg submodule using: ./external/vcpkg/bootstrap-vcpkg.sh or if you are using a Mac and have not previously installed a C++ compiler, using the following flags: ./external/vcpkg/bootstrap-vcpkg.sh --useSystemBinaries --allowAppleClang Next install the dependencies for NUPACK compilation using vcpkg : ./external/vcpkg/vcpkg install gecode armadillo tbb nlohmann-json jsoncpp taskflow protobuf \\ tclap spdlog fmt boost-context boost-graph boost-align boost-coroutine2 boost-algorithm libsimdpp magic-enum \\ boost-variant boost-thread boost-sort boost-geometry boost-odeint boost-ublas boost-exception yaml-cpp boost-algorithm Make a build directory and navigate into it: mkdir build cd build Run the CMake configuration: cmake .. -DCMAKE_BUILD_TYPE = Release You may add custom compilation options as flags to the cmake command if desired. Some examples might be: Add -DCMAKE_CXX_COMPILER=clang++ to use the clang++ compiler. As noted above, compilers besides clang are not generally supported. Add -DREBIND_PYTHON=/usr/local/bin/python3 to build for a specific Python executable (by default, the python in the user\u2019s $PATH is used). Add -DCMAKE_CXX_FLAGS=\"<custom compile options>\" to add custom C++ compilation flags. Add -DCMAKE_POSITION_INDEPENDENT_CODE=ON in the offchance you run into a compilation error asking you to recompile with -fPIC . Build the C++ code: cmake --build . --target nupack-python Install the NUPACK Python module: pip3 install .","title":"Source installation"},{"location":"utilities/","text":"Utilities Jobs \u00b6 Utilities commands analyze or design a single complex ensemble. For each command, the strand ordering of the complex is specified using keyword strands and the physical model is specified using keyword model . For commands that require a structure (e.g., calculation of the equilibrium structure probability using prob ), the structure is specified using the keyword structure . By default, NUPACK utilities jobs run in parallel . To initialize a model for the following examples, run the following code: my_model = Model ( material = 'RNA' ) Compute partition function \u00b6 pfunc calculates the partition function of the complex as well as the free energy of the complex: partition_function = pfunc ( strands = [ 'CCC' , 'GGG' ], model = my_model ) print ( partition_function ) # --> (Decimal('4525.512868'), -5.187871791642832) Compute structure free energy \u00b6 structure_energy calculates the structure free energy for the specified secondary structure: dGstruc = structure_energy ( strands = [ 'AAAA' , 'UUUU' ], structure = '((((+))))' , model = my_model ) print ( dGstruc ) # --> -0.18135141907945873 Compute equilibrium structure probability \u00b6 structure_probability calculates the equilibrium structure probability of a specified secondary structure contained in the complex ensemble: probability = structure_probability ( strands = [ 'CCC' , 'GGG' ], structure = '(((+)))' , model = my_model ) print ( probability ) # --> 0.7152766753194949 Compute Boltzmann-sampled structures \u00b6 sample calculates a set of Boltzmann-sampled structures from the complex ensemble. The number of structures is specified using the keyword num_sample : sampled_structures = sample ( strands = [ 'CCC' , 'GGG' ], num_sample = 3 , model = my_model ) print ( sampled_structures ) # --> [Structure('(((+)))'), Structure('(((+)))'), Structure('(((+)))')] Compute equilibrium base-pairing probabilities \u00b6 pairs calculates the matrix of equilibrium base-pairing probabilities : probability_matrix = pairs ( strands = [ 'CCC' , 'GGG' ], model = my_model ) print ( probability_matrix ) # --> # [[0.1002 0.0000 0.0000 0.0007 0.1474 0.7518] # [0.0000 0.0037 0.0000 0.1474 0.8307 0.0182] # [0.0000 0.0000 0.1904 0.7910 0.0185 0.0001] # [0.0007 0.1474 0.7910 0.0609 0.0000 0.0000] # [0.1474 0.8307 0.0185 0.0000 0.0035 0.0000] # [0.7518 0.0182 0.0001 0.0000 0.0000 0.2299]] (Convert the result to a numpy array via probability_matrix.to_array() .) Compute MFE proxy structure(s) \u00b6 mfe calculates MFE proxy structure . The algorithm returns the MFE proxy secondary structure, the free energy of the MFE stacking state, and the free energy of the MFE proxy secondary structure: mfe_structures = mfe ( strands = [ 'CCC' , 'GGG' ], model = my_model ) print ( 'Free energy of MFE proxy structure: %.2f kcal/mol' % mfe_structures [ 0 ] . energy ) print ( 'MFE proxy structure in dot-parens-plus notation: %s ' % mfe_structures [ 0 ] . structure ) print ( 'MFE proxy structure as structure matrix: \\n %s ' % mfe_structures [ 0 ] . structure . matrix ()) Output: Free energy of MFE proxy structure: -4.98 kcal/mol MFE proxy structure in dot-parens-plus notation: (((+))) MFE proxy structure as structure matrix: [[0 0 0 0 0 1] [0 0 0 0 1 0] [0 0 0 1 0 0] [0 0 1 0 0 0] [0 1 0 0 0 0] [1 0 0 0 0 0]] If there is more than one MFE stacking state, the algorithm returns a list of the corresponding MFE proxy secondary structures, each with the free energy of the MFE proxy secondary structure and the (same) free energy of the MFE stacking state. Compute suboptimal proxy structures \u00b6 subopt calculates the set of suboptimal proxy structures with a stacking state within a specified free energy gap of the MFE stacking state. The (non-negative) free energy gap is specified with keyword energy_gap in kcal/mol. The algorithm returns a list of suboptimal proxy secondary strutures, each with the free energy of the suboptimal proxy secondary structure and with the free energy of its lowest-energy stacking state that falls within the energy gap: subopt_structures = subopt ( strands = [ 'CCC' , 'GGG' ], energy_gap = 1.5 , model = my_model ) print ( subopt_structures ) # --> [StructureEnergy(Structure('(((+)))'), energy=-4.981351375579834, stack_energy=-4.981351375579834), # StructureEnergy(Structure('((.+)).'), energy=-4.000725746154785, stack_energy=-3.781351089477539)] Compute complex ensemble size \u00b6 ensemble_size calculates the complex ensemble size in terms of either number of secondary structures or number of stacking states. Specify a physical model with nostacking to obtain the number of secondary structures: num_struc = ensemble_size ( strands = [ 'CCC' , 'GGG' ], model = Model ( material = 'RNA' , ensemble = 'nostacking' )) print ( num_struc ) # --> 18 Specify a physical model with stacking to obtain the number of stacking states: num_stack = ensemble_size ( strands = [ 'CCC' , 'GGG' ], model = Model ( material = 'RNA' , ensemble = 'stacking' )) print ( num_stack ) # --> 90 Design a sequence \u00b6 des performs complex design to generate a sequence intended to adopt a target secondary structure at equilibrium within the ensemble of the complex. The strand ordering of the complex can be specified using IUPAC degenerate nucleotide codes to incorporate any sequence constraints (the strand ordering can be omitted if there are no sequence constraints). The target structure is specified using keyword structure : # design a sequence without sequence constraints designed_sequence1 = des ( structure = '(((+)))' , model = my_model ) print ( designed_sequence1 ) # --> ['GGC', 'GCC'] # alternative specification to design a sequence without sequence constraints designed_sequence1 = des ( strands = [ 'NNN' , 'NNN' ], structure = '(((+)))' , model = my_model ) print ( designed_sequence1 ) # --> ['GGC', 'GCC'] # design a sequence with sequence constraints designed_sequence2 = des ( strands = [ 'HHH' , 'BBW' ], structure = '(((+)))' , model = my_model ) print ( designed_sequence2 ) # --> ['ACC', 'GGU'] Compute complex ensemble defect \u00b6 defect evaluates the normalized complex ensemble defect with respect to the structure specified using keyword structure : ensemble_defect = defect ( strands = [ 'CCC' , 'GGG' ], structure = '(((+)))' , model = my_model ) print ( ensemble_defect ) # --> 0.20883411169052118 Represent a structure \u00b6 A secondary structure can be defined using any of three notations (keyword Structure ): s1 = Structure ( '((((((((((((+..........))))))))))))' ) # dot-parens-plus notation s2 = Structure ( '(12+.10)12' ) # run-length-encoded dot-parens-plus notation s3 = Structure ( 'D12 (+ U10)' ) # DU+ notation Any object or command that accepts a structure as an argument (e.g, TargetComplex in Design or structure_probability in Utilities) will accept either a structure defined in one of the above three notations, or a previously defined Structure object: dGstruc = structure_energy ( strands = [ 'AAAA' , 'TTTT' ], structure = '((((+))))' , model = my_model ) my_struc = Structure ( '((((+))))' ) dGstruc = structure_energy ( strands = [ 'AAAA' , 'TTTT' ], structure = my_struc , model = my_model ) Structure supports the following methods to assist with structure representation: pairlist() : A pair list contains a list S S of zero-based indices such that S_i = j S_i = j if bases i i and j j are paired, and S_i = i S_i = i if base i i is unpaired. matrix() : A structure matrix of the structure. nicks() : A list of zero-based indices of each base 3 ' ' of a nick between strands (one entry per strand) dotparensplus() : Representation of the structure in dot-parens-plus notation. rle_dotparensplus() : Representation of the structure in run-length-encoded dot-parens-plus notation. For example: s4 = Structure ( '(((+))).' ) print ( s4 . pairlist ()) # --> [5 4 3 2 1 0 6] print ( s4 . matrix ()) # --> [[0 0 0 0 0 1 0] # [0 0 0 0 1 0 0] # [0 0 0 1 0 0 0] # [0 0 1 0 0 0 0] # [0 1 0 0 0 0 0] # [1 0 0 0 0 0 0] # [0 0 0 0 0 0 1]] print ( s4 . nicks ()) # --> [3 7] print ( s4 . dotparensplus ()) # --> (((+))). print ( s4 . rle_dotparensplus ()) # --> (3+)3. Compute sequence distance \u00b6 seq_distance calculates the sequence distance for two sequences that have the same number of nucleotides: seq_distance ( 'ACGUUUU+ACCC' , 'ACGUUUU+AGGG' ) # --> 3 seq_distance ( 'G5' , 'G3C2' ) # --> 2 Compute structure distance \u00b6 struc_distance calculates the structure distance for two structures that have the same number of nucleotides: struc_distance ( '((((((((+..........))))))))' , '(((((((.+...........)))))))' ) # --> 2 struc_distance ( '.15' , '(5.5)5' ) # --> 10 Note Note that sequence distance and structure distance are defined independent of whether the nick locations match between two sequences or two structures. However, seq_distance and struc_distance will return a warning if the nick locations do not match.","title":"Utilities Jobs"},{"location":"utilities/#utilities-jobs","text":"Utilities commands analyze or design a single complex ensemble. For each command, the strand ordering of the complex is specified using keyword strands and the physical model is specified using keyword model . For commands that require a structure (e.g., calculation of the equilibrium structure probability using prob ), the structure is specified using the keyword structure . By default, NUPACK utilities jobs run in parallel . To initialize a model for the following examples, run the following code: my_model = Model ( material = 'RNA' )","title":"Utilities Jobs"},{"location":"utilities/#compute-partition-function","text":"pfunc calculates the partition function of the complex as well as the free energy of the complex: partition_function = pfunc ( strands = [ 'CCC' , 'GGG' ], model = my_model ) print ( partition_function ) # --> (Decimal('4525.512868'), -5.187871791642832)","title":"Compute partition function"},{"location":"utilities/#compute-structure-free-energy","text":"structure_energy calculates the structure free energy for the specified secondary structure: dGstruc = structure_energy ( strands = [ 'AAAA' , 'UUUU' ], structure = '((((+))))' , model = my_model ) print ( dGstruc ) # --> -0.18135141907945873","title":"Compute structure free energy"},{"location":"utilities/#compute-equilibrium-structure-probability","text":"structure_probability calculates the equilibrium structure probability of a specified secondary structure contained in the complex ensemble: probability = structure_probability ( strands = [ 'CCC' , 'GGG' ], structure = '(((+)))' , model = my_model ) print ( probability ) # --> 0.7152766753194949","title":"Compute equilibrium structure probability"},{"location":"utilities/#compute-boltzmann-sampled-structures","text":"sample calculates a set of Boltzmann-sampled structures from the complex ensemble. The number of structures is specified using the keyword num_sample : sampled_structures = sample ( strands = [ 'CCC' , 'GGG' ], num_sample = 3 , model = my_model ) print ( sampled_structures ) # --> [Structure('(((+)))'), Structure('(((+)))'), Structure('(((+)))')]","title":"Compute Boltzmann-sampled structures"},{"location":"utilities/#compute-equilibrium-base-pairing-probabilities","text":"pairs calculates the matrix of equilibrium base-pairing probabilities : probability_matrix = pairs ( strands = [ 'CCC' , 'GGG' ], model = my_model ) print ( probability_matrix ) # --> # [[0.1002 0.0000 0.0000 0.0007 0.1474 0.7518] # [0.0000 0.0037 0.0000 0.1474 0.8307 0.0182] # [0.0000 0.0000 0.1904 0.7910 0.0185 0.0001] # [0.0007 0.1474 0.7910 0.0609 0.0000 0.0000] # [0.1474 0.8307 0.0185 0.0000 0.0035 0.0000] # [0.7518 0.0182 0.0001 0.0000 0.0000 0.2299]] (Convert the result to a numpy array via probability_matrix.to_array() .)","title":"Compute equilibrium base-pairing probabilities"},{"location":"utilities/#compute-mfe-proxy-structures","text":"mfe calculates MFE proxy structure . The algorithm returns the MFE proxy secondary structure, the free energy of the MFE stacking state, and the free energy of the MFE proxy secondary structure: mfe_structures = mfe ( strands = [ 'CCC' , 'GGG' ], model = my_model ) print ( 'Free energy of MFE proxy structure: %.2f kcal/mol' % mfe_structures [ 0 ] . energy ) print ( 'MFE proxy structure in dot-parens-plus notation: %s ' % mfe_structures [ 0 ] . structure ) print ( 'MFE proxy structure as structure matrix: \\n %s ' % mfe_structures [ 0 ] . structure . matrix ()) Output: Free energy of MFE proxy structure: -4.98 kcal/mol MFE proxy structure in dot-parens-plus notation: (((+))) MFE proxy structure as structure matrix: [[0 0 0 0 0 1] [0 0 0 0 1 0] [0 0 0 1 0 0] [0 0 1 0 0 0] [0 1 0 0 0 0] [1 0 0 0 0 0]] If there is more than one MFE stacking state, the algorithm returns a list of the corresponding MFE proxy secondary structures, each with the free energy of the MFE proxy secondary structure and the (same) free energy of the MFE stacking state.","title":"Compute MFE proxy structure(s)"},{"location":"utilities/#compute-suboptimal-proxy-structures","text":"subopt calculates the set of suboptimal proxy structures with a stacking state within a specified free energy gap of the MFE stacking state. The (non-negative) free energy gap is specified with keyword energy_gap in kcal/mol. The algorithm returns a list of suboptimal proxy secondary strutures, each with the free energy of the suboptimal proxy secondary structure and with the free energy of its lowest-energy stacking state that falls within the energy gap: subopt_structures = subopt ( strands = [ 'CCC' , 'GGG' ], energy_gap = 1.5 , model = my_model ) print ( subopt_structures ) # --> [StructureEnergy(Structure('(((+)))'), energy=-4.981351375579834, stack_energy=-4.981351375579834), # StructureEnergy(Structure('((.+)).'), energy=-4.000725746154785, stack_energy=-3.781351089477539)]","title":"Compute suboptimal proxy structures"},{"location":"utilities/#compute-complex-ensemble-size","text":"ensemble_size calculates the complex ensemble size in terms of either number of secondary structures or number of stacking states. Specify a physical model with nostacking to obtain the number of secondary structures: num_struc = ensemble_size ( strands = [ 'CCC' , 'GGG' ], model = Model ( material = 'RNA' , ensemble = 'nostacking' )) print ( num_struc ) # --> 18 Specify a physical model with stacking to obtain the number of stacking states: num_stack = ensemble_size ( strands = [ 'CCC' , 'GGG' ], model = Model ( material = 'RNA' , ensemble = 'stacking' )) print ( num_stack ) # --> 90","title":"Compute complex ensemble size"},{"location":"utilities/#design-a-sequence","text":"des performs complex design to generate a sequence intended to adopt a target secondary structure at equilibrium within the ensemble of the complex. The strand ordering of the complex can be specified using IUPAC degenerate nucleotide codes to incorporate any sequence constraints (the strand ordering can be omitted if there are no sequence constraints). The target structure is specified using keyword structure : # design a sequence without sequence constraints designed_sequence1 = des ( structure = '(((+)))' , model = my_model ) print ( designed_sequence1 ) # --> ['GGC', 'GCC'] # alternative specification to design a sequence without sequence constraints designed_sequence1 = des ( strands = [ 'NNN' , 'NNN' ], structure = '(((+)))' , model = my_model ) print ( designed_sequence1 ) # --> ['GGC', 'GCC'] # design a sequence with sequence constraints designed_sequence2 = des ( strands = [ 'HHH' , 'BBW' ], structure = '(((+)))' , model = my_model ) print ( designed_sequence2 ) # --> ['ACC', 'GGU']","title":"Design a sequence"},{"location":"utilities/#compute-complex-ensemble-defect","text":"defect evaluates the normalized complex ensemble defect with respect to the structure specified using keyword structure : ensemble_defect = defect ( strands = [ 'CCC' , 'GGG' ], structure = '(((+)))' , model = my_model ) print ( ensemble_defect ) # --> 0.20883411169052118","title":"Compute complex ensemble defect"},{"location":"utilities/#represent-a-structure","text":"A secondary structure can be defined using any of three notations (keyword Structure ): s1 = Structure ( '((((((((((((+..........))))))))))))' ) # dot-parens-plus notation s2 = Structure ( '(12+.10)12' ) # run-length-encoded dot-parens-plus notation s3 = Structure ( 'D12 (+ U10)' ) # DU+ notation Any object or command that accepts a structure as an argument (e.g, TargetComplex in Design or structure_probability in Utilities) will accept either a structure defined in one of the above three notations, or a previously defined Structure object: dGstruc = structure_energy ( strands = [ 'AAAA' , 'TTTT' ], structure = '((((+))))' , model = my_model ) my_struc = Structure ( '((((+))))' ) dGstruc = structure_energy ( strands = [ 'AAAA' , 'TTTT' ], structure = my_struc , model = my_model ) Structure supports the following methods to assist with structure representation: pairlist() : A pair list contains a list S S of zero-based indices such that S_i = j S_i = j if bases i i and j j are paired, and S_i = i S_i = i if base i i is unpaired. matrix() : A structure matrix of the structure. nicks() : A list of zero-based indices of each base 3 ' ' of a nick between strands (one entry per strand) dotparensplus() : Representation of the structure in dot-parens-plus notation. rle_dotparensplus() : Representation of the structure in run-length-encoded dot-parens-plus notation. For example: s4 = Structure ( '(((+))).' ) print ( s4 . pairlist ()) # --> [5 4 3 2 1 0 6] print ( s4 . matrix ()) # --> [[0 0 0 0 0 1 0] # [0 0 0 0 1 0 0] # [0 0 0 1 0 0 0] # [0 0 1 0 0 0 0] # [0 1 0 0 0 0 0] # [1 0 0 0 0 0 0] # [0 0 0 0 0 0 1]] print ( s4 . nicks ()) # --> [3 7] print ( s4 . dotparensplus ()) # --> (((+))). print ( s4 . rle_dotparensplus ()) # --> (3+)3.","title":"Represent a structure"},{"location":"utilities/#compute-sequence-distance","text":"seq_distance calculates the sequence distance for two sequences that have the same number of nucleotides: seq_distance ( 'ACGUUUU+ACCC' , 'ACGUUUU+AGGG' ) # --> 3 seq_distance ( 'G5' , 'G3C2' ) # --> 2","title":"Compute sequence distance"},{"location":"utilities/#compute-structure-distance","text":"struc_distance calculates the structure distance for two structures that have the same number of nucleotides: struc_distance ( '((((((((+..........))))))))' , '(((((((.+...........)))))))' ) # --> 2 struc_distance ( '.15' , '(5.5)5' ) # --> 10 Note Note that sequence distance and structure distance are defined independent of whether the nick locations match between two sequences or two structures. However, seq_distance and struc_distance will return a warning if the nick locations do not match.","title":"Compute structure distance"}]}